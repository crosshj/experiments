<style>
    body {
        overflow: hidden;
        margin: 0;
        background: #8a8a8a;
    }
    #canvas {
        padding-left: 275px;
    }
    .box {
        filter: url(#outline);
        fill: rgb(216, 216, 216);
    }
    .node {
        fill: #aaa;
    }
    .node:hover {
        fill: red;
    }
    .heavy {
        font: bold 12px sans-serif;
        color: red;
    }
    .link path {
        stroke: #eee;
        opacity: 1;
        stroke-width: 2;
        cursor: crosshair;
        fill: none;
    }
</style>

<svg id="canvas" preserveAspectRatio="none" viewBox="0 0 500 500" xmlns="http://www.w3.org/2000/svg"
    onload="makeDraggable(evt)">
    <defs>
        <filter id="outline">
            <feMorphology operator="dilate" in="SourceAlpha" radius="1" />
            <feComposite in="SourceGraphic" />
        </filter>
    </defs>


    <g id="outputs" class="box draggable-group" transform="translate(30,40)">
        <rect x="0" y="1" width="76" height="76" rx="5" ry="5"></rect>
        <circle class="node" cx="76" cy="11" r="5"></circle>
        <circle class="node" cx="76" cy="66" r="5"></circle>
        <text x="15" y="-8" class="heavy">outputs</text>
    </g>

    <g class="box draggable-group" transform="translate(200,100)">
        <rect x="10" y="1" width="76" height="76" rx="5" ry="5"></rect>
        <circle class="node" cx="10" cy="11" r="5"></circle>
        <circle class="node" cx="10" cy="66" r="5"></circle>
        <text x="25" y="-8" class="heavy">inputs</text>
    </g>

    <g class="link">
        <path d="M 112 105 C
            162 105
            144 167
            204 167"></path>
    </g>

</svg>

<script>
    (function(){
        if(!document.location+''.includes('localhost')){
            return;
        }
        function getHash(str){
            return str.split('').reduce((prevHash, currVal) =>
                (((prevHash << 5) - prevHash) + currVal.charCodeAt(0))|0, 0);
        }
        var hash;
        function pageIsChanged(){
            fetch(document.location).then(x => x.text()).then(x => {
                const newHash = getHash(x);
                hash = hash || newHash;

                if(hash === newHash){
                    return;
                }
                document.location.reload();
            });
        }

        console.log('=== Simple Hot Reload ===');
        var refreshInterval = setInterval(pageIsChanged, 1000);
    })();
</script>

<script>
    function makeDraggable(evt) {
        var svg = evt.target;

        svg.addEventListener('mousedown', startDrag);
        svg.addEventListener('mousemove', drag);
        svg.addEventListener('mouseup', endDrag);
        svg.addEventListener('mouseleave', endDrag);
        svg.addEventListener('touchstart', startDrag, {passive: true});
        svg.addEventListener('touchmove', drag, {passive: true});
        svg.addEventListener('touchend', endDrag);
        svg.addEventListener('touchleave', endDrag);
        svg.addEventListener('touchcancel', endDrag);

        function getMousePosition(evt) {
            var CTM = svg.getScreenCTM();
            if (evt.touches) { evt = evt.touches[0]; }
            return {
                x: (evt.clientX - CTM.e) / CTM.a,
                y: (evt.clientY - CTM.f) / CTM.d
            };
        }

        var selectedElement, offset, transform;

        var links = [{
            start: '#outputs circle:nth-child(3)',
            end: '#outputs circle:nth-child(3)'
        }];

        function updateConnectedLinks(){

        }

        function initialiseDragging(evt) {
            offset = getMousePosition(evt);

            // Make sure the first transform on the element is a translate transform
            var transforms = selectedElement.transform.baseVal;

            if (transforms.length === 0 || transforms.getItem(0).type !== SVGTransform.SVG_TRANSFORM_TRANSLATE) {
                // Create an transform that translates by (0, 0)
                var translate = svg.createSVGTransform();
                translate.setTranslate(0, 0);
                selectedElement.transform.baseVal.insertItemBefore(translate, 0);
            }

            // Get initial translation
            transform = transforms.getItem(0);
            offset.x -= transform.matrix.e;
            offset.y -= transform.matrix.f;

            updateConnectedLinks(evt);
        }

        function startDrag(evt){
            const nodeDrag = {
                test: () => evt.target.classList.contains('node'),
                start: () => {
                    console.log('wire drag start');
                    evt.stopPropagation();
                    evt.preventDefault();
                }
            };
            const groupDrag = {
                test: () => evt.target.parentNode.classList.contains('draggable-group'),
                start: () => {
                    selectedElement = evt.target.parentNode;
                    initialiseDragging(evt);
                }
            };

            const result = [
                nodeDrag, groupDrag
            ].filter(x => {
                try {
                    return x.test();
                } catch (e){
                    return false;
                }
            })[0];

            result && result.start();
        }

        function drag(evt) {
            if (!selectedElement) {
                return;
            }
            evt.preventDefault();
            var coord = getMousePosition(evt);
            transform.setTranslate(coord.x - offset.x, coord.y - offset.y);
        }

        function endDrag(evt) {
            selectedElement = false;
        }
    }
</script>