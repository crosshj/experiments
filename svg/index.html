<!--

    NOTES:
    - move towards greater objective-orientation in code

    ISSUES:

    TODO:
    - wires: CRUD
    - boxes: CRUD
    - boxes: indicator on node that it is linked (small dot)
    - wires: animation and indicators (arrows)
    - boxes: collision detection
    - page: zoom/pan with memory
    - creation of scene from json

    RESOURCES:
    - path tool - https://codepen.io/thebabydino/full/EKLNvZ
    - path info - https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths

-->

<head>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Boxes and Wires Playground</title>
</head>

<style>
  body {
    overflow: hidden;
    margin: 0;
    /* background: #8a8a8a; */
    /* background: transparent; */
    background-color: #8179af;
    background: url(terrain1.svg);
    background-size: 1400px 100%;
    display: flex;
    flex-direction: column;
    justify-content: start;
    align-items: center;
  }

  #canvas {
    /* padding-left: 275px; */
    width: 550px;
    /* border: 1px solid #06c300; */
    background: #33ccdd22;
    margin-top: 20px;
  }

  .box {
    filter: url(#outline);
    fill: #17670057;
    cursor: default;
  }

  .node {
    /* fill: purple; */
  }

  .node:hover {
    fill: purple;
  }

  .heavy {
    font: bold 13px monospace;
    fill: #000;
    pointer-events: none;
  }

  .link path {
    stroke: #aa00aa;
    opacity: 1;
    stroke-width: 1px;
    fill: none;
  }

  .link line.control {
    stroke: #aa00aa66;
    stroke-dasharray: 5;
    fill: none;
    stroke-width: 1;
  }

  .link .control-circle {
    fill: none;
    stroke: #aa00aa66;
  }

</style>

<svg id="canvas" preserveAspectRatio="none" viewBox="0 0 500 500" xmlns="http://www.w3.org/2000/svg"
  onload="makeDraggable(evt)">
  <defs>
    <filter id="outline">
      <feMorphology operator="dilate" in="SourceGraphic" result="DILATED" radius="1" />
      <feFlood flood-color="#aa00aa" flood-opacity="1" result="COLORED"></feFlood>
      <feComposite in="COLORED" in2="DILATED" operator="in" result="OUTLINE"></feComposite>

      <feMerge>
        <feMergeNode in="OUTLINE" />
        <feMergeNode in="SourceGraphic" />
      </feMerge>
    </filter>
  </defs>

  <g id="links">
    <!-- LINKS ARE CREATED DYNAMICALLY -->
  </g>

</svg>

<script>
  function makeDraggable(evt) {
    var svg = evt.target;

    svg.addEventListener('mousedown', startDrag);
    svg.addEventListener('mousemove', drag);
    svg.addEventListener('mouseup', endDrag);
    svg.addEventListener('mouseleave', endDrag);
    svg.addEventListener('touchstart', startDrag, { passive: false });
    svg.addEventListener('touchmove', drag, { passive: false });
    svg.addEventListener('touchend', endDrag);
    svg.addEventListener('touchleave', endDrag);
    svg.addEventListener('touchcancel', endDrag);

    function getMousePosition(evt) {
      var CTM = svg.getScreenCTM();
      if (evt.touches) { evt = evt.touches[0]; }
      return {
        x: (evt.clientX - CTM.e) / CTM.a,
        y: (evt.clientY - CTM.f) / CTM.d
      };
    }

    var selectedElement, offset, transform;

    var units = [{
      label: 'shadrach',
      x: 10,
      y: 10,
      width: 150,
      height: 100,
      nodes: [null, null, null, {
        label: 'first'
      }, null, {
        label: 'second'
      }]
    },{
      label: 'meshach',
      x: 200,
      y: 200,
      nodes: [{
        label: 'first'
      }, null, {
        label: 'second'
      }, {
        label: 'third'
      }, null, {
        label: 'fourth'
      }]
    }, {
      label: 'abednego',
      x: 300,
      y: 350,
      nodes: [{
        label: 'first'
      }, null, {
        label: 'second'
      }, null]
    }];

    units.forEach(drawUnit);
    units.getNode = (label, nodeLabel) => {
      const unitElement = (units.find(x => x.label === label) || {}).element;
      if(!unitElement){
        return;
      }
      return unitElement.querySelector(`circle[data-label="${nodeLabel}"]`);
    };

    var links = [{
      start: units.getNode('shadrach', 'second'),
      end: units.getNode('meshach', 'second')
    }, {
      start: units.getNode('shadrach', 'first'),
      end: units.getNode('meshach', 'first'),
    }, {
      start: units.getNode('meshach', 'fourth'),
      end: units.getNode('abednego', 'first')
    }];

    function drawLink(link){
      var linkElement = link.element;
      if(!linkElement){
        linkElement = link.element = createLinkElement(link);
      }
      link.originalPathD = link.originalPathD || linkElement.querySelector('path')
        .getAttribute('d')
        .replace(/\n/g, ' ')
        .replace(/ +(?= )/g, '');
      link.startOriginalOffsetX = link.start.parentNode
        .getAttribute('transform').match(/[0-9]+/g)[0];
      link.startOriginalOffsetY = link.start.parentNode
        .getAttribute('transform').match(/[0-9]+/g)[1];
      link.endOriginalOffsetX = link.end.parentNode
        .getAttribute('transform').match(/[0-9]+/g)[0];
      link.endOriginalOffsetY = link.end.parentNode
        .getAttribute('transform').match(/[0-9]+/g)[1];

      link.startOffsetX = Number(link.startOriginalOffsetX);
      link.startOffsetY = Number(link.startOriginalOffsetY)
      link.endOffsetX = Number(link.endOriginalOffsetX);
      link.endOffsetY = Number(link.endOriginalOffsetY);

      const pathD = link.originalPathD;
      const pathObj = pathDToObj(pathD);

      const controlPoints = calculateControls(pathObj);
      pathObj.c1 = controlPoints.c1;
      pathObj.c2 = controlPoints.c2;

      link.originalPathD = objToPathD(pathObj);
      link.element.querySelector('path').setAttribute('d', link.originalPathD)
    }

    links.forEach(drawLink);

    function drawUnit(unit){
      const width = Number(unit.width || 76);
      const height = unit.height || 76;

      const namespaceURI = document.getElementById('canvas').namespaceURI;
      const unitElement = document.createElementNS(namespaceURI, "g");
      unitElement.setAttribute('class', 'box draggable-group');
      unitElement.setAttribute('transform', `translate(${unit.x}, ${unit.y})`);
      var unitElementHTML = `
        <rect x="10" y="1" width="${width}" height="${height}" rx="5" ry="5"></rect>
        <text x="20" y="40" class="heavy">${unit.label}</text>
      `;

      var positions = [{
        x: 10, y: 10 //top-left
      }, {
        x: 10, y: height/2 //middle-left
      }, {
        x: 10, y: height-10 //bottom-left
      }, {
        x: 10 + width/2, y: height //bottom-middle
      }, {
        x: 10 + width, y: 10 //top-right
      }, {
        x: 10 + width, y: height/2 //middle-right
      }, {
        x: 10 + width, y: height-10 //bottom-right
      }, {
        x: 10 + width/2, y: 0 //top-middle
      }];

      unit.nodes.forEach(n => {
        if(!n){
          positions.shift();
          return;
        }
        const pos = positions.shift();
        unitElementHTML += `
          <circle data-label="${n.label}" class="node" cx="${pos.x}" cy="${pos.y}" r="5"></circle>
        `;
      });
      unitElement.innerHTML = unitElementHTML;
      const canvas = document.querySelector('#canvas');

      unit.element = unitElement;
      canvas.appendChild(unitElement);
    }

    function calculateControls(p) {
      const xDifference = p.c3.x - p.m.x;
      const yDifference = p.c3.y - p.m.y;

      const xMult = xDifference < 0
        ? -2
        : 0.5;
      const yMult = 0;

      const yCurve = Math.abs(xDifference) < 20
        ? 150 * (Math.abs(xDifference)/20)
        : 100;
      const yOffset = xDifference < 0
        ? yDifference < 0 ? -yCurve : yCurve
        : 0

      // const xMult = xDifference < 0
      //   ? - Math.abs(xDifference / 5 )
      //   : 0 //1 - Math.abs(xDifference) / Math.abs(yDifference);
      // const yMult = yDifference < 0
      //   ? - Math.abs(yDifference / 5 )
      //   : 0 //1 - Math.abs(yDifference) / Math.abs(xDifference);

      const controls = {
        c1: {
          x: p.m.x + (xDifference * xMult),
          y: p.m.y + (yDifference * yMult) + yOffset
        },
        c2: {
          x: p.c3.x - (xDifference * xMult),
          y: p.c3.y - (yDifference * yMult) - yOffset
        }
      };


      // console.log({
      //   xDifference, yDifference
      // });

      return controls;
    }

    function drawControls({ namespaceURI, link, linkElement, pathObj }){
        if(!link.controlLine1){
          link.controlLine1 = document.createElementNS(namespaceURI, "line");
          link.controlLine1.classList.add('control');
          linkElement.appendChild(link.controlLine1);
        }
        if(!link.controlLine2){
          link.controlLine2 = document.createElementNS(namespaceURI, "line");
          link.controlLine2.classList.add('control');
          linkElement.appendChild(link.controlLine2);
        }
        if(!link.controlLine3){
          link.controlLine3 = document.createElementNS(namespaceURI, "line");
          link.controlLine3.classList.add('control');
          linkElement.appendChild(link.controlLine3);
        }
        const controlCircleRadius = 3;
        if(!link.controlCircle1){
          link.controlCircle1 = document.createElementNS(namespaceURI, "circle");
          link.controlCircle1.classList.add('control-circle');
          link.controlCircle1.setAttribute('r', controlCircleRadius);
          linkElement.appendChild(link.controlCircle1);
        }
        if(!link.controlCircle2){
          link.controlCircle2 = document.createElementNS(namespaceURI, "circle");
          link.controlCircle2.classList.add('control-circle');
          link.controlCircle2.setAttribute('r', controlCircleRadius);
          linkElement.appendChild(link.controlCircle2);
        }

        link.controlCircle1.setAttribute('cx', pathObj.c1.x);
        link.controlCircle1.setAttribute('cy', pathObj.c1.y);
        link.controlCircle2.setAttribute('cx', pathObj.c2.x);
        link.controlCircle2.setAttribute('cy', pathObj.c2.y);

        link.controlLine1.setAttribute('x1', pathObj.m.x);
        link.controlLine1.setAttribute('y1', pathObj.m.y);
        link.controlLine1.setAttribute('x2', pathObj.c1.x);
        link.controlLine1.setAttribute('y2', pathObj.c1.y);

        link.controlLine2.classList.add('control');
        link.controlLine2.setAttribute('x1', pathObj.c1.x);
        link.controlLine2.setAttribute('y1', pathObj.c1.y);
        link.controlLine2.setAttribute('x2', pathObj.c2.x);
        link.controlLine2.setAttribute('y2', pathObj.c2.y);

        link.controlLine3.classList.add('control');
        link.controlLine3.setAttribute('x1', pathObj.c2.x);
        link.controlLine3.setAttribute('y1', pathObj.c2.y);
        link.controlLine3.setAttribute('x2', pathObj.c3.x);
        link.controlLine3.setAttribute('y2', pathObj.c3.y);
    }

    function createLinkElement(link){
        const namespaceURI = document.getElementById('canvas').namespaceURI;
        const linkElement = document.createElementNS(namespaceURI, "g");
        linkElement.classList.add('link');

        const linkPath = document.createElementNS(namespaceURI, "path");

        const startParentTransform = link.start.parentNode.getAttribute('transform');
        const endParentTransform = link.end.parentNode.getAttribute('transform');
        const startCoords = {
          x: Number(startParentTransform.match(/[0-9]+/g)[0]) + Number(link.start.getAttribute('cx')),
          y: Number(startParentTransform.match(/[0-9]+/g)[1]) + Number(link.start.getAttribute('cy'))
        };
        const endCoords = {
          x: Number(endParentTransform.match(/[0-9]+/g)[0]) + Number(link.end.getAttribute('cx')),
          y: Number(endParentTransform.match(/[0-9]+/g)[1]) + Number(link.end.getAttribute('cy'))
        };
        const pathObj = {
          m: startCoords,
          c3: endCoords
        };
        const controls = calculateControls(pathObj);
        pathObj.c1 = controls.c1;
        pathObj.c2 = controls.c2;
        const originalPathD = objToPathD(pathObj);
        linkPath.setAttribute('d', originalPathD)

        linkElement.appendChild(linkPath);

        drawControls({ namespaceURI, link, linkElement, pathObj });

        const linksGroup = document.querySelector('#canvas #links');
        linksGroup.appendChild(linkElement);

        return linkElement;
    }

    function pathDToObj(pathD) {
      const matches = pathD.match(/[0-9]+/g).map(Number);
      return {
        m: {
          x: matches[0],
          y: matches[1]
        },
        c1: {
          x: matches[2],
          y: matches[3]
        },
        c2: {
          x: matches[4],
          y: matches[5]
        },
        c3: {
          x: matches[6],
          y: matches[7]
        }
      };
    }

    function objToPathD(o) {
      return `M ${o.m.x} ${o.m.y} C ${o.c1.x} ${o.c1.y} ${o.c2.x} ${o.c2.y} ${o.c3.x} ${o.c3.y}`;
    }

    function updateConnectedLinks(event, x, y) {
      //console.log('updateConnectedLinks');
      const target = event.target.parentNode;
      links.forEach(link => {
        const containsStart = target.classList.contains('box') && target.contains(link.start);
        const containsEnd = target.classList.contains('box') && target.contains(link.end);
        if (!containsStart && !containsEnd) {
          return;
        }

        const pathD = link.originalPathD;
        const pathObj = pathDToObj(pathD);

        if (containsStart) {
          link.startOffsetX = x;
          link.startOffsetY = y;
        }
        if (containsEnd) {
          link.endOffsetX = x;
          link.endOffsetY = y;
        }

        pathObj.m.x += (link.startOffsetX - link.startOriginalOffsetX);
        pathObj.m.y += (link.startOffsetY - link.startOriginalOffsetY);
        pathObj.c3.x += (link.endOffsetX - link.endOriginalOffsetX);
        pathObj.c3.y += (link.endOffsetY - link.endOriginalOffsetY);

        const controlPoints = calculateControls(pathObj);
        pathObj.c1 = controlPoints.c1;
        pathObj.c2 = controlPoints.c2;

        drawControls({ link, linkElement: link.element, pathObj })

        const newPathString = objToPathD(pathObj);
        link.element.querySelector('path').setAttribute('d', newPathString);
        //console.log(newPathString);
      });
    }

    function initialiseDragging(evt) {
      offset = getMousePosition(evt);

      // Make sure the first transform on the element is a translate transform
      var transforms = selectedElement.transform.baseVal;

      if (transforms.length === 0 || transforms.getItem(0).type !== SVGTransform.SVG_TRANSFORM_TRANSLATE) {
        // Create an transform that translates by (0, 0)
        var translate = svg.createSVGTransform();
        translate.setTranslate(0, 0);
        selectedElement.transform.baseVal.insertItemBefore(translate, 0);
      }

      // Get initial translation
      transform = transforms.getItem(0);
      offset.x -= transform.matrix.e;
      offset.y -= transform.matrix.f;
    }

    function startDrag(evt) {
      const nodeDrag = {
        test: () => evt.target.classList.contains('node'),
        start: () => {
          console.log('wire drag start');
          evt.stopPropagation();
          evt.preventDefault();
        }
      };
      const groupDrag = {
        test: () => evt.target.parentNode.classList.contains('draggable-group'),
        start: () => {
          selectedElement = evt.target.parentNode;
          initialiseDragging(evt);
        }
      };

      const result = [
        nodeDrag, groupDrag
      ].filter(x => {
        try {
          return x.test();
        } catch (e) {
          return false;
        }
      })[0];

      result && result.start();
    }

    function drag(evt) {
      if (!selectedElement) {
        return;
      }
      evt.preventDefault();
      var coord = getMousePosition(evt);
      transform.setTranslate(coord.x - offset.x, coord.y - offset.y);
      updateConnectedLinks(evt, coord.x - offset.x, coord.y - offset.y);
    }

    function endDrag(evt) {
      selectedElement = false;
    }
  }
</script>

<script>
  (function () {
    if (!(document.location + '').includes('localhost')) {
      return;
    }
    function getHash(str) {
      return str.split('').reduce((prevHash, currVal) =>
        (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
    }
    var hash;
    function pageIsChanged() {
      fetch(document.location).then(x => x.text()).then(x => {
        const newHash = getHash(x);
        hash = hash || newHash;

        if (hash === newHash) {
          return;
        }
        document.location.reload();
      });
    }

    console.log('=== Simple Live Reload ===');
    var refreshInterval = setInterval(pageIsChanged, 1000);
  })();
</script>
