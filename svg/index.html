<!--

    NOTES:
    - move towards greater objective-orientation in code

    ISSUES:

    TODO:
    - wires: CRUD
    - boxes: CRUD
    - boxes: indicator on node that it is linked (small dot)
    - wires: animation and indicators (arrows)
    - boxes: collision detection
    - page: zoom/pan with memory
    - creation of scene from json

    RESOURCES:
    - path tool - https://codepen.io/thebabydino/full/EKLNvZ
    - path info - https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths

-->

<head>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Boxes and Wires Playground</title>
</head>

<style>
  body {
    overflow: hidden;
    margin: 0;
    /* background: #8a8a8a; */
    /* background: transparent; */
    background-color: #8179af;
    background: url(terrain1.svg);
    background-size: 1400px 100%;
    display: flex;
    flex-direction: column;
    justify-content: start;
    align-items: center;
  }

  #canvas {
    /* padding-left: 275px; */
    width: 550px;
    border: 1px solid #06c300;
    background: #00c5514d;
    margin-top: 20px;
  }

  .box {
    filter: url(#outline);
    fill: #17670057;
  }

  .node {
    fill: #607b6a;
  }

  .node:hover {
    fill: greenyellow;
  }

  .heavy {
    font: bold 13px monospace;
    fill: #000;
  }

  .link path {
    stroke: #046d14;
    opacity: 1;
    stroke-width: 1px;
    cursor: crosshair;
    fill: none;
  }
</style>

<svg id="canvas" preserveAspectRatio="none" viewBox="0 0 500 500" xmlns="http://www.w3.org/2000/svg"
  onload="makeDraggable(evt)">
  <defs>
    <filter id="outline">
      <feMorphology operator="dilate" in="SourceGraphic" result="DILATED" radius="1" />
      <feFlood flood-color="#06c300" flood-opacity="1" result="COLORED"></feFlood>
      <feComposite in="COLORED" in2="DILATED" operator="in" result="OUTLINE"></feComposite>

      <feMerge>
        <feMergeNode in="OUTLINE" />
        <feMergeNode in="SourceGraphic" />
      </feMerge>
    </filter>
  </defs>

  <g id="exampleLink" class="link">
    <path d="
          M 107 106
          C 158 106
            158 167
            209 167">
    </path>
  </g>
  <g id="exampleLink2" class="link">
    <path d="
          M 107 51
          C 158 51
            158 111
            209 111">
    </path>
  </g>

  <g id="outputs" class="box draggable-group" transform="translate(30,40)">
    <rect x="0" y="1" width="76" height="76" rx="5" ry="5"></rect>
    <circle class="node" cx="76" cy="11" r="5"></circle>
    <circle class="node" cx="76" cy="66" r="5"></circle>
    <text x="15" y="15" class="heavy">outputs</text>
  </g>

  <g id="inputs" class="box draggable-group" transform="translate(200,100)">
    <rect x="10" y="1" width="76" height="76" rx="5" ry="5"></rect>
    <circle class="node" cx="10" cy="11" r="5"></circle>
    <circle class="node" cx="10" cy="66" r="5"></circle>
    <text x="25" y="15" class="heavy">inputs</text>
  </g>

</svg>

<script>
  function makeDraggable(evt) {
    var svg = evt.target;

    svg.addEventListener('mousedown', startDrag);
    svg.addEventListener('mousemove', drag);
    svg.addEventListener('mouseup', endDrag);
    svg.addEventListener('mouseleave', endDrag);
    svg.addEventListener('touchstart', startDrag, { passive: false });
    svg.addEventListener('touchmove', drag, { passive: false });
    svg.addEventListener('touchend', endDrag);
    svg.addEventListener('touchleave', endDrag);
    svg.addEventListener('touchcancel', endDrag);

    function getMousePosition(evt) {
      var CTM = svg.getScreenCTM();
      if (evt.touches) { evt = evt.touches[0]; }
      return {
        x: (evt.clientX - CTM.e) / CTM.a,
        y: (evt.clientY - CTM.f) / CTM.d
      };
    }

    var selectedElement, offset, transform;

    var links = [{
      element: document.getElementById('exampleLink'),
      start: document.querySelector('#outputs circle:nth-child(3)'),
      end: document.querySelector('#inputs circle:nth-child(3)'),
    }, {
      element: document.getElementById('exampleLink2'),
      start: document.querySelector('#outputs circle:nth-child(2)'),
      end: document.querySelector('#inputs circle:nth-child(2)'),
    }];

    function calculateControls(p) {
      const xDifference = p.c3.x - p.m.x;
      const yDifference = p.c3.y - p.m.y;

      const xMult = xDifference < 0
        ? -2
        : 0.5;
      const yMult = 0;

      const yCurve = Math.abs(xDifference) < 30
        ? 150 * (Math.abs(xDifference)/30)
        : 150;
      const yOffset = xDifference < 30
        ? yDifference < 0 ? -yCurve : yCurve
        : 0

      // const xMult = xDifference < 0
      //   ? - Math.abs(xDifference / 5 )
      //   : 0 //1 - Math.abs(xDifference) / Math.abs(yDifference);
      // const yMult = yDifference < 0
      //   ? - Math.abs(yDifference / 5 )
      //   : 0 //1 - Math.abs(yDifference) / Math.abs(xDifference);

      const controls = {
        c1: {
          x: p.m.x + (xDifference * xMult),
          y: p.m.y + (yDifference * yMult) + yOffset
        },
        c2: {
          x: p.c3.x - (xDifference * xMult),
          y: p.c3.y - (yDifference * yMult) - yOffset
        }
      };


      // console.log({
      //   xDifference, yDifference
      // });

      return controls;
    }

    links.forEach(link => {
      link.originalPathD = link.element.querySelector('path')
        .getAttribute('d')
        .replace(/\n/g, ' ')
        .replace(/ +(?= )/g, '');
      link.startOriginalOffsetX = link.start.parentNode.getAttribute('transform').match(/[0-9]+/g)[0];
      link.startOriginalOffsetY = link.start.parentNode.getAttribute('transform').match(/[0-9]+/g)[1];
      link.endOriginalOffsetX = link.end.parentNode.getAttribute('transform').match(/[0-9]+/g)[0];
      link.endOriginalOffsetY = link.end.parentNode.getAttribute('transform').match(/[0-9]+/g)[1];

      link.startOffsetX = Number(link.startOriginalOffsetX);
      link.startOffsetY = Number(link.startOriginalOffsetY)
      link.endOffsetX = Number(link.endOriginalOffsetX);
      link.endOffsetY = Number(link.endOriginalOffsetY);

      const pathD = link.originalPathD;
      const pathObj = pathDToObj(pathD);

      const controlPoints = calculateControls(pathObj);
      pathObj.c1 = controlPoints.c1;
      pathObj.c2 = controlPoints.c2;

      link.originalPathD = objToPathD(pathObj);
      link.element.querySelector('path').setAttribute('d', link.originalPathD)
    });

    function pathDToObj(pathD) {
      const matches = pathD.match(/[0-9]+/g).map(Number);
      return {
        m: {
          x: matches[0],
          y: matches[1]
        },
        c1: {
          x: matches[2],
          y: matches[3]
        },
        c2: {
          x: matches[4],
          y: matches[5]
        },
        c3: {
          x: matches[6],
          y: matches[7]
        }
      };
    }

    function objToPathD(o) {
      return `M ${o.m.x} ${o.m.y} C ${o.c1.x} ${o.c1.y} ${o.c2.x} ${o.c2.y} ${o.c3.x} ${o.c3.y}`;
    }

    function updateConnectedLinks(event, x, y) {
      //console.log('updateConnectedLinks');
      const target = event.target.parentNode;
      links.forEach(link => {
        const containsStart = target.classList.contains('box') && target.contains(link.start);
        const containsEnd = target.classList.contains('box') && target.contains(link.end);
        if (!containsStart && !containsEnd) {
          return;
        }

        const pathD = link.originalPathD;
        const pathObj = pathDToObj(pathD);

        if (containsStart) {
          link.startOffsetX = x;
          link.startOffsetY = y;
        }
        if (containsEnd) {
          link.endOffsetX = x;
          link.endOffsetY = y;
        }

        pathObj.m.x += (link.startOffsetX - link.startOriginalOffsetX);
        pathObj.m.y += (link.startOffsetY - link.startOriginalOffsetY);
        pathObj.c3.x += (link.endOffsetX - link.endOriginalOffsetX);
        pathObj.c3.y += (link.endOffsetY - link.endOriginalOffsetY);

        const controlPoints = calculateControls(pathObj);
        pathObj.c1 = controlPoints.c1;
        pathObj.c2 = controlPoints.c2;

        const newPathString = objToPathD(pathObj);
        link.element.querySelector('path').setAttribute('d', newPathString);
        //console.log(newPathString);
      });
    }

    function initialiseDragging(evt) {
      offset = getMousePosition(evt);

      // Make sure the first transform on the element is a translate transform
      var transforms = selectedElement.transform.baseVal;

      if (transforms.length === 0 || transforms.getItem(0).type !== SVGTransform.SVG_TRANSFORM_TRANSLATE) {
        // Create an transform that translates by (0, 0)
        var translate = svg.createSVGTransform();
        translate.setTranslate(0, 0);
        selectedElement.transform.baseVal.insertItemBefore(translate, 0);
      }

      // Get initial translation
      transform = transforms.getItem(0);
      offset.x -= transform.matrix.e;
      offset.y -= transform.matrix.f;
    }

    function startDrag(evt) {
      const nodeDrag = {
        test: () => evt.target.classList.contains('node'),
        start: () => {
          console.log('wire drag start');
          evt.stopPropagation();
          evt.preventDefault();
        }
      };
      const groupDrag = {
        test: () => evt.target.parentNode.classList.contains('draggable-group'),
        start: () => {
          selectedElement = evt.target.parentNode;
          initialiseDragging(evt);
        }
      };

      const result = [
        nodeDrag, groupDrag
      ].filter(x => {
        try {
          return x.test();
        } catch (e) {
          return false;
        }
      })[0];

      result && result.start();
    }

    function drag(evt) {
      if (!selectedElement) {
        return;
      }
      evt.preventDefault();
      var coord = getMousePosition(evt);
      transform.setTranslate(coord.x - offset.x, coord.y - offset.y);
      updateConnectedLinks(evt, coord.x - offset.x, coord.y - offset.y);
    }

    function endDrag(evt) {
      selectedElement = false;
    }
  }
</script>

<script>
  (function () {
    if (!(document.location + '').includes('localhost')) {
      return;
    }
    function getHash(str) {
      return str.split('').reduce((prevHash, currVal) =>
        (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
    }
    var hash;
    function pageIsChanged() {
      fetch(document.location).then(x => x.text()).then(x => {
        const newHash = getHash(x);
        hash = hash || newHash;

        if (hash === newHash) {
          return;
        }
        document.location.reload();
      });
    }

    console.log('=== Simple Live Reload ===');
    var refreshInterval = setInterval(pageIsChanged, 1000);
  })();
</script>