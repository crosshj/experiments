<body>
    <h3>test tool for all things service worker related</h3>
    <pre>
        - selectively refresh modules, files, etc
        - can integrate with browsersync?
        - ...
    </pre>
    <ul id="actions-list"></ul>
</body>



<script>(async () => {
    let swRegistrations;
    if ('serviceWorker' in navigator) {
        swRegistrations = await navigator.serviceWorker.getRegistrations();
    }
    let indexDBdatabases;
    try {
        indexDBdatabases = await indexedDB.databases();
    } catch(e){}

    function deleteIndexDB(databaseName){
        return new Promise((resolve, reject) => {
            var req = indexedDB.deleteDatabase(databaseName);
            req.onsuccess = function () {
                resolve("Deleted database successfully");
            };
            req.onerror = function () {
                reject("Couldn't delete database");
            };
            req.onblocked = function () {
                reject("Couldn't delete database due to the operation being blocked");
            };
            setTimeout(() => reject('database delete timed out after 5 secs'), 5000)
        });
    }


    const actions = {
        "spacer0": "",
        "reboot:  what does this entail?": {
            handler: async (e, callback) => {

            }
        },
        "tree cache (sessionStorage)": {
            verb: 'CLEAR',
            handler: async (e, callback) => {

            }
        },
        "app cache: tree, tabs, editor (sessionSession)": {
            verb: 'CLEAR',
            handler: async (e, callback) => {

            }
        },
        "service worker requests cache (cache Storage)": {
            verb: 'CLEAR',
            handler: async (e, callback) => {

            }
        },
        "service worker handlers (indexedDB)": {
            verb: 'CLEAR',
            value: indexDBdatabases.find(x => x.name === 'serviceWorker') ? '[X]': '[ ]',
            handler: async (e, callback) => {
                try {
                    await deleteIndexDB("serviceWorker");
                } catch(e){
                    console.error(e);
                }
            }
        },
        "serviceRequestHandler cache (indexedDB)": {
            verb: 'CLEAR',
            value: indexDBdatabases.find(x => x.name === 'serviceRequest') ? '[X]': '[ ]',
            handler: async (e, callback) => {
                try {
                    await deleteIndexDB("serviceRequest");
                } catch(e){
                    console.error(e);
                }
            }
        },
        "localStorage reloadServices - headers['x-cache'] - /service/read (serviceRequestHandler)": {
            verb: 'TOGGLE',
            value: !!JSON.parse(localStorage.getItem('reloadServices')) ? 'true' : 'false',
            handler: async (e, callback) => {
                const current = JSON.parse(localStorage.getItem('reloadServices')||'false');
                localStorage.setItem('reloadServices', !current);
                document.location.reload();
            }
        },
        "serviceHandler << how to reload this?": {
            verb: 'RELOAD',
            handler: async (e, callback) => {

            }
        },
        "service worker registration": {
            verb: 'REMOVE',
            value: swRegistrations && swRegistrations.length ? '[X]' : '[ ]',
            handler: async (e, callback) => {
                localStorage.removeItem('moduleCache');

                if (!'serviceWorker' in navigator) {
                    return; // service worker not available
                }

                const registrations = await navigator.serviceWorker.getRegistrations()
                for(let registration of registrations) {
                    await registration.unregister();
                }

                try {
                    await deleteIndexDB("serviceWorker");
                } catch(e){
                    console.error(e);
                }
                try {
                    await deleteIndexDB("serviceRequest");
                } catch(e){
                    console.error(e);
                }
                document.location.reload();

                //heavy-handed approach which forces clients to refresh
                /*
                for(let registration of registrations) {
                    registration.unregister()
                        .then(function() {
                            return self.clients.matchAll();
                        })
                        .then(function(clients) {
                            clients
                                .forEach(client => {
                                    if (client.url && "navigate" in client){
                                        client.navigate(client.url);
                                    }
                                });
                        });
                }
                */
            }
        },
        "moduleCache - used by index.sw (localStorage) ": {
            verb: 'CLEAR',
            value: !!localStorage.getItem('moduleCache') ? '[X]' : '[ ]',
            handler: async (e, callback) => {
                localStorage.removeItem('moduleCache');
                document.location.reload();
            }
        },
        "spacer1": ''
    };

    const routes = [
        'POST|/service/create/:id?',
        'GET|/service/read/:id?',
        'POST|/service/update/:id?',
        'POST|/service/delete/:id?',
        'GET|/manage/:id?',
        'GET|/monitor/:id?',
        'GET|/persist/:id?'
    ];

    routes.forEach(route => {
        actions[route.replace('|', ' ')] = {
            fields: ["id"],
            verb: 'FETCH',
            handler: async (e, callback) => {
                try {
                    const id = e.target.parentNode.querySelector('[name=id]').value;
                    const response = await fetch(route.split('|')[1].replace(':id?', id));
                    const json = await response.json();
                    callback(null, json);
                } catch(e){
                    callback(e);
                }
            }
        }
    })

    const actionsList = document.getElementById('actions-list');

    var fragment = new DocumentFragment();
    for(let i=0, len=Object.keys(actions).length; i<len; i++){
        const actionName = Object.keys(actions)[i];
        const thisAction = actions[actionName];
        const li = document.createElement('li');

        if(actionName.includes('spacer') && !thisAction){
            li.classList.add('spacer');
            fragment.appendChild(li);
            continue;
        }

        let fieldsEl = '';
        if(thisAction.fields){
            fieldsEl = thisAction.fields.map(f => `
                <input class="field-${f}" type="text" name="${f}" placeholder="${f}"/>
            `).join('\n');
        }
        li.innerHTML = `
            <span class="value">${(thisAction.value || '')}</span>
            <div class="action-description">
                <span class="description">${actionName.replace(':id?', '')}</span>
                ${fieldsEl}
            </div>
            <button>${thisAction.verb || "EXECUTE"}</button>
        `;
        li.querySelector('button').onclick = (e) => {
            const callback = (error, data) => error
                ? console.error(error)
                : console.log(data);
            thisAction.handler(e, callback);
        };
        fragment.appendChild(li);
    }
    actionsList.appendChild(fragment);

})(); // async
</script>

<style>
    body {
        display: flex;
        flex-direction: column;
        align-items: center;
        background: #333;
        color: #b1b1b1;
        font-family: sans-serif;
        font-size: 1.1rem;
        font-weight: lighter;
        padding-bottom: 200px;
    }
    ::-webkit-scrollbar {
       display: none;
    }
    ul {
        margin: 0;
        padding: 0;
        width: 43rem;
    }
    li {
        list-style: none;
        padding: 9px 20px;
        background: #222;
        margin: 12px 0;
        display: flex;
        justify-content: space-between;
    }
    li.spacer {
        background: transparent;
        height: 1em;
    }
    .action-description {
        flex: 1;
        margin-left: 15px;
    }
    span.value {
        display: inline-block;
        min-width: 4rem;
        text-align: center;
        font-family: monospace;
        color: #fff7;
    }
    pre {
        white-space: pre-line;
        width: 41rem;
        background: #222222;
        padding: 21px;
        box-sizing: content-box;
    }
    button {
        background: #4d7b5b88;
        border: 1px;
        padding: 5px;
        min-width: 7em;
        color: #a9c7b5;
    }
    button:hover {
        background: #5b8a69;
        color: white;
    }
    input[type="text"] {
        background: #0f0f0f;
        color: white;
        width: 2em;
        border: 0;
        padding-bottom: 0;
        padding-top: 2px;
        font-size: 1em;
        padding-left: 4px;
    }
    input[type="text"]:focus {
        background: #395241;
        outline-style: none;
        color: #a9cab3;
    }
    input:focus::-webkit-input-placeholder {
        color: #a9cab388;
    }
</style>

