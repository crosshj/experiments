<!--

    https://github.com/bbbsssss/brainfuck-js

-->
<html>
<head>
    <title>BRAINFUCK CODE EVAL DEMO</title>
</head>
<body>
    <h3>BRAINFUCK CODE EVAL DEMO</h3>
    <pre>

INPUT:
<code class="language-input language">
<!--
+++++ +++               Set Cell #0 to 8
[
    >++++               Add 4 to Cell #1; will always set Cell #1 to

    [                   as the cell will be cleared by the loop
        >++             Add 4*2 to Cell #2
        >+++            Add 4*3 to Cell #3
        >+++            Add 4*3 to Cell #4
        >+              Add 4 to Cell #5
        <<<<-           Decrement the loop counter in Cell #1
    ]                   Loop till Cell #1 is zero
    >+                  Add 1 to Cell #2
    >+                  Add 1 to Cell #3
    >-                  Subtract 1 from Cell #4
    >>+                 Add 1 to Cell #6
    [<]                 Move to first zero cell you find; this will
                        be Cell #1 which was cleared by the prev loop
    <-                  Decrement the loop Counter in Cell #0
]                       Loop till Cell #0 is zero

The result of this is:
Cell No :   0   1   2   3   4   5   6
Contents:   0   0  72 104  88  32   8
Pointer :   ^

>>.                     Cell #2 has value 72 which is 'H'
>---.                   Subtract 3 from Cell #3 to get 101 which is 'e'
+++++ ++..+++.          Likewise for 'llo' from Cell #3
>>.                     Cell #5 is 32 for the space
<-.                     Subtract 1 from Cell #4 for 87 to give a 'W'
<.                      Cell #3 was set to 'o' from the end of 'Hello'
+++.----- -.----- ---.  Cell #3 for 'rl' and 'd'
>>+.                    Add 1 to Cell #5 gives us an exclamation point
>++.                    And finally a newline from Cell #6
-->
</code>

OUTPUT:
<code class="language-output language">
</code>

</pre>
</body>
<script>
    const inputDOM = document.querySelector('.language-input');
    const outputDOM = document.querySelector('.language-output');

    const appendScript = (url) => {
        return new Promise((resolve, reject) => {
            var script = document.createElement('script');
            script.crossOrigin = "anonymous";
            script.onload = resolve;
            script.src = url;
            document.head.appendChild(script);
        });
    };

    let loading = true;
    outputDOM.innerHTML = '\nloading...';

    const doEach = (a) => {
        if (loading) {
            outputDOM.innerHTML = '\n';
            loading = false;
        }
        outputDOM.innerHTML += a;
    };

    // TODO: is there a better way to tell Opal where to write?
    window.process = {
        stdout: {
            write: doEach
        }
    };

    const codeFromComment = Array.from(
        document.querySelector('.language-input').childNodes
    )
        .filter(x => x.nodeType === 8)
        .map(x => x.data).join('\n');
    inputDOM.innerText = codeFromComment;

    outputDOM.innerHTML = '\n' + bf(codeFromComment, '');

    /**
     * interpret a bf program
     *
     * program -- a string containing the bf program
     * input   -- a user input string to be processed by the program (default: '')
     * debug   -- a boolean flag to specify whether operations should be logged to the JavaScript console (default: false)
     * bits    -- cell size in bits (default: 8)
     */
    function bf(program, input, debug, bits) {
        // default parameter values
        input = (input || '').split('');
        debug = (typeof debug === undefined) ? false : debug;
        bits = bits || 8;

        // setup and initialization
        var maxVal = Math.pow(2, bits) - 1;
        var a = new Array(); // data array
        var n = new Array(); // nesting level pointer array
        var op = 0;          // operation counter used in debug outputput
        var p = 0;           // data pointer
        var x = 0;           // x flag used when a loop is encountered and the assocated data pointer is already 0
        var output = '';

        // begin stepping through program
        // i is the instruction pointer
        for (var i = 0; i < program.length; i++) {
        if (debug) ++op;

        switch (program[i]) {
            case '>':
            incrementPointer(i);
            break;
            case '<':
            decrementPointer(i);
            break;
            case '+':
            incrementByte(i);
            break;
            case '-':
            decrementByte(i);
            break;
            case '.':
            outputByte(i);
            break;
            case ',':
            inputByte(i);
            break;
            case '[':
            beginLoop(i);
            break;
            case ']':
            i = endLoop(i);
            break;
            default:
            break;
        }
        }

        // empty arrays
        a = null;
        n = null;

        // return any output
        return output;

        function incrementPointer(i) {

        if (x) return;
        ++p;
        if (debug) log(i, 'array pos. now '+p);
        }

        function decrementPointer(i) {

        if (x) return;
        if (p > 0) {
            --p;
            if (debug) log(i, 'array pos. now '+p);
        }
        else {
            if (debug) log(i, 'array pos. is already '+p);
        }
        }

        function incrementByte(i) {

        if (x) return;
        if ((a[p] || 0) < maxVal) {
            a[p] = (a[p] || 0) + 1;
        }
        else {
            a[p] = 0;
        }
        if (debug) log(i, 'a['+p+'] = '+a[p]);
        }

        function decrementByte(i) {

        if (x) return;
        if ((a[p] || 0) > 0) {
            a[p] = (a[p] || 0) - 1;
        }
        else {
            a[p] = maxVal;
        }
        if (debug) log(i, 'a['+p+'] = '+a[p]);
        }

        function outputByte(i) {

        if (x) return;
        output = output + String.fromCharCode(a[p]);
        if (debug) log(i, 'output \''+a[p]+'\' '+String.fromCharCode(a[p]));
        }

        function inputByte(i) {

        if (x != 0) {
            return;
        }
        var read = input.shift();
        if (read === undefined && program[i+1] == '+') a[p] = -1;
        else if (read === undefined) a[p] = 0;
        else a[p] = read.charCodeAt(0);
        if (debug) log(i, 'read in '+read+' ('+a[p]+')');
        }

        function beginLoop(i) {

        if (x != 0) {
            ++x;
            return;
        }
        if ((a[p] || 0) > 0) {
            n.push(i);
            if (debug) log(i, 'Array['+p+'] is \''+a[p]+'\' ** Loop nesting level: '+(n.length - 1)+'.');
        }
        else {
            ++x;
            if (debug) log(i, 'Array['+p+'] is \''+(a[p] || 0)+'\' ** Loop nesting level: '+(n.length - 1)+'.');
            if (debug) log(i, 'Not entering a loop but skipping this block');
        }
        }

        function endLoop(i) {

        if (x != 0) {
            --x;
            return i;
        }
        if ((a[p] || 0) > 0) {
            var origin = n.pop();
            if (debug) log(i, 'Array['+p+'] is \''+a[p]+'\'');
            if (debug) log(i, 'looping back to '+(origin));
            i = origin - 1;
        }
        else {
            n.pop();
            if (debug) log(i, 'Array['+p+'] is \''+(a[p] || 0)+'\'');
        }

        return i;
        }

        function log(i, message) {
        console.log(op+' ('+i+'): '+program[i]+' | '+message);
        }
}
</script>

<style>
    .no-preview {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 5vw;
        color: #666;
    }

    body:before {
        content: '';
        display: block;
        height: 35px;
        position: absolute;
        left: 0px;
        top: 0px;
        right: 0px;
        z-index: 1;
        background: #1d1d1deb;
    }

    body:after {
        content: '';
        display: block;
        height: 5px;
        position: absolute;
        left: 0px;
        top: 35px;
        right: 0px;
        z-index: 1;
        background: linear-gradient(180deg, #1d1d1deb, transparent);
    }

    body {
        margin: 0px;
        /*height: calc(100vh - 40px);*/
        overflow: hidden;
        color: #ccc;
        font-family: sans-serif;
    }

    #container {
        height: 100%;
        width: 100%;
        overflow: hidden;
        /*padding: 30px;*/
        /*margin-bottom: 20px;*/
        /*padding-top: 40px;padding-bottom: 40px;*/
    }

    #container img {
        width: 100%;
        max-height: 400px;
        object-fit: cover;
        object-position: center;
        margin-left: -30px;
        background-color: transparent !important;
    }

    #container hr {
        border: 1px dotted #999;
        border-top: 0px;
        margin-left: -30px;
    }

    #container.markdown-body {
        color: #acb5be;
    }

    #container>*:last-child {
        margin-bottom: 200px !important;
    }

    #container.markdown-body * {
        border-color: #777 !important;
    }

    blockquote {
        margin: 0;
        border-left: 5px solid #7a7a7a;
        font-style: italic;
        padding: 1px 20px;
        text-align: left;
    }

    .selected:after {
        content: '';
        display: block;
        background: #e2961d;
        position: absolute;
        left: -100px;
        right: 0px;
        top: -10px;
        bottom: -10px;
        z-index: -1;
    }

    .selected {
        color: black;
        position: relative;
        /*font-size: 35px !important;*/
    }

    li.selected,
    ul.selected,
    h2.selected,
    h3.selected {
        margin-left: 0.5%;
        zoom: 2 !important;
    }

    #container.markdown-body input[type=checkbox] {
        visibility: hidden !important;
        position: relative !important;
        color: inherit !important;
    }

    #container.markdown-body input[type=checkbox]:before {
        visibility: visible !important;
        position: absolute !important;
        font-size: 24px !important;
        top: -12px !important;
        left: -3px !important;
        content: '☐' !important;
    }

    #container.markdown-body input[type=checkbox]:checked:before {
        content: '✓' !important;
        color: #8BC34A !important;
    }

    #container.markdown-body .selected input[type=checkbox]:checked:before {
        color: black !important;
    }

    #container.markdown-body .highlight pre,
    #container.markdown-body pre {
        background-color: #ffffff11;
    }
</style>
<style>
    body {
        margin: 40px;
    }

    .CodeMirror-gutter-filler,
    .CodeMirror-cursors,
    .CodeMirror-vscrollbar,
    .CodeMirror-hscrollbar,
    .klipse-snippet,
    .language-klipse,
    .CodeMirror-lines>div>.CodeMirror-measure {
        display: none !important;
    }

    .CodeMirror-code {
        display: block;
    }

    .CodeMirror-line {
        margin: 0;
    }

    code {
        color: #888;
    }

    h3 {
        margin-top: 3em;
        margin-bottom: 2em;
    }

    .language {
        background: #2d2d2d;
        padding: 0px 10px 20px 10px;
        margin: 15px 0px -8px 0px;
        overflow-x: hidden;
        overflow-y: auto;
        font-size: 0.9em;
        color: #ccc;
        display: block;
    }

    .language-input {
        height: 500px;
    }

    .language::-webkit-scrollbar {
        width: 5px;
    }

    .language::-webkit-scrollbar-track {
        background: transparent;
    }

    .language::-webkit-scrollbar-thumb {
        background: #888;
    }

    .language::-webkit-scrollbar-thumb:hover {
        background: #555;
    }

    .language-output span {
        width: 10px;
        height: 10px;
        display: inline-block;
        overflow: hidden;
    }

    pre {
        margin-top: -3em;
    }

    span.mark {
        color: #E91E63;
        background: #E91E63;
        border-radius: 50%;
    }

    span.blank {
        color: #222;
        background: #444;
        border: 1px solid #222;
        box-sizing: border-box;
    }
</style>

</html>