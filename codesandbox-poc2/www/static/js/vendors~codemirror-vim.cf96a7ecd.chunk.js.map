{"version":3,"sources":["webpack:///C:/repos/codesandbox-client/node_modules/codemirror/keymap/vim.js"],"names":["CodeMirror","defaultKeymap","keys","type","toKeys","context","action","motion","motionArgs","linewise","toJumplist","forward","wordEnd","bigWord","inclusive","explicitRepeat","toFirstChar","repeatOffset","isEdit","actionArgs","after","matchIndent","sameLine","operator","operatorArgs","indentRight","toLower","operatorMotionArgs","visualLine","shouldMoveCursor","insertAt","interlaceInsertRepeat","blockwise","replace","position","increase","backtrack","textObjectInner","searchArgs","querySrc","wholeWordOnly","defaultExCommandMap","name","shortName","possiblyAsync","excludeFromCommandHistory","Pos","Vim","detachVimMap","cm","next","this","keyMap","vim","rmClass","getWrapperElement","getOption","document","body","style","caretColor","marks","state","fatCursorMarks","i","length","clear","off","updateFatCursorMark","disableFatCursorMark","getInputField","attach","attachVimMap","setOption","onCursorActivity","getOnPasteFn","leaveVimMode","prev","addClass","on","enableFatCursorMark","signal","mode","maybeInitVimState","enterVimMode","ranges","listSelections","result","range","empty","anchor","ch","getLine","line","push","markText","className","widget","createElement","textContent","setBookmark","cmKey","key","vimKey","charAt","pieces","split","lastPiece","hasCharacter","piece","modifiers","specialKeys","isUpperCase","toLowerCase","join","cmKeyToVimKey","cmd","findKey","defineOption","val","Init","test","Enter","Backspace","Delete","Insert","onPasteFn","insertMode","setCursor","offsetCursor","getCursor","actions","enterInsertMode","numberRegex","wordCharTest","isWordChar","bigWordCharTest","makeKeyRange","start","size","String","fromCharCode","upperCaseAlphabet","lowerCaseAlphabet","numbers","validMarks","concat","validRegisters","isLine","firstLine","lastLine","isLowerCase","k","isWhiteSpaceString","isEndOfSentenceSymbol","indexOf","inArray","arr","options","defaultValue","aliases","callback","undefined","Error","value","cfg","option","scope","local","vimGlobalState","lastInsertModeKeyTimer","createCircularJumpList","pointer","head","tail","buffer","Array","cachedCursor","add","oldCur","newCur","curMark","useNextSlot","cursor","trashMark","markPos","find","cursorEqual","move","offset","mark","inc","createInsertModeChanges","c","changes","expectCursorActivityForChange","MacroModeState","latestRegister","isPlaying","isRecording","replaySearchQueries","onRecordingDone","lastInsertModeChanges","inputState","InputState","lastEditInputState","lastEditActionCommand","lastHPos","lastHSPos","lastMotion","fakeCursor","insertModeRepeat","visualMode","visualBlock","lastSelection","lastPastedText","sel","resetVimGlobalState","optionName","searchQuery","searchIsReversed","lastSubstituteReplacePart","jumpList","macroModeState","lastCharacterSearch","increment","selectedCharacter","registerController","RegisterController","searchHistoryController","HistoryController","exCommandHistoryController","prototype","exitMacroRecordMode","enterMacroRecordMode","registerName","register","getRegister","openDialog","bottom","vimApi","buildKeyMap","getRegisterController","resetVimGlobalState_","getVimGlobalState_","maybeInitVimState_","suppressErrorLogging","InsertModeKey","map","lhs","rhs","ctx","exCommandDispatcher","unmap","defineEx","prefix","func","exCommands","commandMap_","handleKey","origin","command","handleMacroRecording","clearInputState","pushText","logKey","handleEsc","exitVisualMode","exitInsertMode","keyBuffer","keysAreChars","match","commandDispatcher","matchCommand","slice","thisMatch","window","clearTimeout","setTimeout","selections","here","replaceRange","pop","handleKeyInsertMode","keysMatcher","exec","pushRepeatDigit","handleKeyNonInsertMode","operation","curOp","isVimOp","substring","index","doKeyToKey","processCommand","e","console","handleEx","input","defineMotion","fn","motions","defineAction","defineOperator","operators","mapCommand","args","extra","_mapCommand","defineRegister","registers","prefixRepeat","motionRepeat","reason","Register","text","insertModeChanges","searchQueries","unnamedRegister","historyBuffer","iterator","initialPrefix","n","getRepeat","repeat","parseInt","setText","pushInsertModeChanges","pushSearchQuery","query","toString","isValidRegister","shiftNumericRegisters_","nextMatch","up","dir","element","j","pushInput","splice","reset","bestMatch","matches","partial","full","commandMatch","commandMatches","character","lastChar","repeatOverride","processMotion","processOperator","processOperatorMotion","processAction","processSearch","processEx","copyArgs","evalInput","repeatIsExplicit","recordLastEdit","getSearchCursor","getSearchState","setReversed","promptPrefix","originalQuery","getQuery","originalScrollPos","getScrollInfo","handleQuery","shift","showPrompt","onClose","scrollTo","left","top","logSearchQuery","desc","searchPromptDesc","onKeyUp","close","parsedQuery","keyName","target","selectionEnd","selectionStart","Math","min","updateSearchQuery","scrollIntoView","findNext","clearSearchHighlight","onKeyDown","e_stop","focus","word","expandWordUnderCursor","isKeyword","end","ignoreCase","smartCase","showConfirm","onPromptClose","onPromptKeyDown","exArgs","selectValueOnOpen","newHead","newAnchor","origHead","copyCursor","clipCursorToContent","origAnchor","oldHead","oldAnchor","noRepeat","motionResult","recordJumpPosition","Infinity","updateCmSelection","updateMark","cursorIsBefore","lastSel","lineOffset","abs","chOffset","curStart","curEnd","cmSel","cursorMin","cursorMax","makeCmSelection","lineLength","tmp","_cm","expandSelectionToLine","selection","getRange","lines","clipToLine","setSelections","primary","operatorMoveTo","actionCommand","moveToTopLine","_head","getUserVisibleLines","findFirstNonWhiteSpaceCharacter","moveToMiddleLine","floor","moveToBottomLine","expandToLine","isReversed","highlightSearchMatches","goToMark","pos","getMarkPos","moveToOtherHighlightedEnd","jumpToMark","best","equal","between","cursorIsBetween","moveByCharacters","cur","moveByLines","endCh","moveByDisplayLines","moveByScroll","moveToColumn","moveToEol","first","last","moveToStartOfLine","charCoords","res","findPosV","hitSide","goalCoords","coordsChar","resCoords","moveByPage","moveByParagraph","findParagraph","moveBySentence","nextChar","idx","ln","stop","curr","last_valid","skip_empty_lines","reverse","curr_index","findSentence","scrollbox","clientHeight","defaultTextHeight","orig","dest","moveByWords","words","emptyLineIsWord","findWord","eodCh","from","to","shortCircuit","firstWord","lastWord","moveToWord","moveTillCharacter","moveToCharacter","recordLastCharacterSearch","moveToSymbol","symb","endLine","lineCount","curCh","lineText","nextCh","lastCh","reverseSymb","depth","curMoveThrough","symbolToMode","init","findSymbolModes","isComplete","lineLen","findSymbol","retval","clipPos","moveToFirstNonWhiteSpaceCharacter","moveToMatchedSymbol","symbol","getTokenTypeAt","findMatchingBracket","moveToLineOrEdgeOfDocument","lineNum","textObjectManipulation","bracketRegexp","openSym","scanForBracket","selectCompanionObject","'","len","chars","firstIndex","findBeginningAndEnd","expandSelection","repeatLastCharacterSearch","lastSearch","moveH","fillArray","times","change","finalHead","inVisualBlock","getSelection","replacement","replaceSelections","lastState","prevLineEnd","Number","MAX_VALUE","wasLastLine","commands","newlineAndIndent","indent","startLine","indentLine","changeCase","getSelections","swapped","toSwap","toUpperCase","yank","endPos","jumpListWalk","scroll","lineHeight","delta","newPos","cursorCoords","ceil","newBottom","scrollToCursor","height","y","replayMacro","executeMacroRegister","toggleOverwrite","overwrite","max","onChange","onKeyEventTargetKeyDown","selectForInsert","toggleVisualMode","subMode","reselectLastSelection","_actionArgs","updateLastSelection","anchorMark","headMark","joinLines","finalCh","curFinalPos","newLineAndEnterInsertMode","newlineAndIndentContinueComment","paste","tabSize","whitespaceLength","str","tabs","spaces","currentLine","chompedText","wasChomped","firstIndent","wspace","newIndent","quotient","curPosFinal","lastSelectionCurEnd","selectedArea","getCurrentSelectedAreaRange","block","width","setSelection","getLastSelectedAreaRange","getSelectedAreaRange","selectedText","emptyStrings","selectBlock","posFromIndex","indexFromPos","extendLineToColumn","undo","repeatFn","redo","setRegister","setMark","replaceTo","replaceWith","replaceWithStr","incrementNumberToken","numberStr","lineStr","re","baseStr","digits","base","zeroPadding","substr","repeatLastEdit","includeLineBreak","maxCh","ret","prop","hasOwnProperty","offsetLine","offsetCh","pressed","mapped","prefixLen","pressedPrefix","mappedPrefix","cur1","cur2","arguments","apply","call","cur3","cur1before2","cur2before3","trim","s","column","isClipped","primIndex","atAnchor","atHead","getIndex","wasClipped","baseCh","headCh","newDir","lineHead","updateFakeCursor","exclusive","headOffset","anchorOffset","right","moveHead","firstNonWS","search","_forward","noSymbol","getHead","wordStart","bracket","section","comment","found","method","preprocess","token","charTests","foundWord","charIdxInLine","markName","includeChar","lastIndexOf","isEmpty","isBoundary","any","startState","SearchState","searchState_","dialog","template","shortText","prompt","splitBySeparator","argString","separator","slashes","findUnescapedSeparators","tokens","escapeNextChar","setQuery","getOverlay","searchOverlay","setOverlay","overlay","reversed","getScrollbarAnnotate","annotate","setScrollbarAnnotate","charUnescapes","unescapes","parseQuery","RegExp","regexPart","forceIgnoreCase","out","specialComesNext","translateRegex","openNotification","duration","alert","raw","makePrompt","rawQuery","r1","r2","props","regexEqual","searchState","removeOverlay","source","matchSol","stream","sol","backUp","eol","skipToEnd","addOverlay","showMatchesOnScrollbar","scrollInfo","bottomY","history","doc","done","event","lastModTime","changeHistory","filter","el","ExCommandDispatcher","buildCommandMap_","opt_params","that","_processCommand","commandHistoryRegister","previousCommand","inputStream","StringStream","commandName","params","parseInput_","matchCommand_","parseCommandArgs_","toInput","eatWhile","eat","lineEnd","parseLineSpec_","numberMatch","parseLineSpecOffset_","offsetMatch","delim","argDelimiter","user","mapping","unshift","colorscheme","mapArgs","imap","nmap","vmap","set","setArgs","setCfg","expr","forceGet","optionIsBoolean","oldValue","message","setOptionReturn","setlocal","setglobal","regArgs","regInfo","sort","unique","number","pattern","err","eatSpace","opts","decimal","hex","octal","parseArgs","lineStart","radix","numPart","textPart","matchPart","a","b","compareFn","textOld","anum","bnum","global","splitBySlash","matchedLines","content","nextCommand","substitute","trailing","flagsPart","count","replacePart","confirm","output","peek","matched","matcher","unescapeRegexReplace","translateRegexReplace","startPos","searchCursor","exMode","lastPos","replaceAll","newText","_value","savedCallback","doReplace","write","save","nohlsearch","delmarks","sym","startMark","finishMark","charCodeAt","finish","insertModeChangeRegister","lastChange","selLength","logInsertModeChange","imc","repeatInsertModeChanges","changeObj","maybeReset","somethingSelected","handleExternalSelection","lookupKey","repeatForInsert","isAction","cachedInputState","repeatCommand","repeatInsert","changeObject","keyHandler","binding","getOffset","detach","fallthrough","mod"],"mappings":"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","file":"static/js/vendors~codemirror-vim.cf96a7ecd.chunk.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n/**\n * Supported keybindings:\n *   Too many to list. Refer to defaultKeyMap below.\n *\n * Supported Ex commands:\n *   Refer to defaultExCommandMap below.\n *\n * Registers: unnamed, -, a-z, A-Z, 0-9\n *   (Does not respect the special case for number registers when delete\n *    operator is made with these commands: %, (, ),  , /, ?, n, N, {, } )\n *   TODO: Implement the remaining registers.\n *\n * Marks: a-z, A-Z, and 0-9\n *   TODO: Implement the remaining special marks. They have more complex\n *       behavior.\n *\n * Events:\n *  'vim-mode-change' - raised on the editor anytime the current mode changes,\n *                      Event object: {mode: \"visual\", subMode: \"linewise\"}\n *\n * Code structure:\n *  1. Default keymap\n *  2. Variable declarations and short basic helpers\n *  3. Instance (External API) implementation\n *  4. Internal state tracking objects (input state, counter) implementation\n *     and instantiation\n *  5. Key handler (the main command dispatcher) implementation\n *  6. Motion, operator, and action implementations\n *  7. Helper functions for the key handler, motions, operators, and actions\n *  8. Set up Vim to work as a keymap for CodeMirror.\n *  9. Ex command implementations.\n */\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../lib/codemirror\"), require(\"../addon/search/searchcursor\"), require(\"../addon/dialog/dialog\"), require(\"../addon/edit/matchbrackets.js\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../lib/codemirror\", \"../addon/search/searchcursor\", \"../addon/dialog/dialog\", \"../addon/edit/matchbrackets\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  'use strict';\n\n  var defaultKeymap = [\n    // Key to key mapping. This goes first to make it possible to override\n    // existing mappings.\n    { keys: '<Left>', type: 'keyToKey', toKeys: 'h' },\n    { keys: '<Right>', type: 'keyToKey', toKeys: 'l' },\n    { keys: '<Up>', type: 'keyToKey', toKeys: 'k' },\n    { keys: '<Down>', type: 'keyToKey', toKeys: 'j' },\n    { keys: '<Space>', type: 'keyToKey', toKeys: 'l' },\n    { keys: '<BS>', type: 'keyToKey', toKeys: 'h', context: 'normal'},\n    { keys: '<C-Space>', type: 'keyToKey', toKeys: 'W' },\n    { keys: '<C-BS>', type: 'keyToKey', toKeys: 'B', context: 'normal' },\n    { keys: '<S-Space>', type: 'keyToKey', toKeys: 'w' },\n    { keys: '<S-BS>', type: 'keyToKey', toKeys: 'b', context: 'normal' },\n    { keys: '<C-n>', type: 'keyToKey', toKeys: 'j' },\n    { keys: '<C-p>', type: 'keyToKey', toKeys: 'k' },\n    { keys: '<C-[>', type: 'keyToKey', toKeys: '<Esc>' },\n    { keys: '<C-c>', type: 'keyToKey', toKeys: '<Esc>' },\n    { keys: '<C-[>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: '<C-c>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: 's', type: 'keyToKey', toKeys: 'cl', context: 'normal' },\n    { keys: 's', type: 'keyToKey', toKeys: 'c', context: 'visual'},\n    { keys: 'S', type: 'keyToKey', toKeys: 'cc', context: 'normal' },\n    { keys: 'S', type: 'keyToKey', toKeys: 'VdO', context: 'visual' },\n    { keys: '<Home>', type: 'keyToKey', toKeys: '0' },\n    { keys: '<End>', type: 'keyToKey', toKeys: '$' },\n    { keys: '<PageUp>', type: 'keyToKey', toKeys: '<C-b>' },\n    { keys: '<PageDown>', type: 'keyToKey', toKeys: '<C-f>' },\n    { keys: '<CR>', type: 'keyToKey', toKeys: 'j^', context: 'normal' },\n    { keys: '<Ins>', type: 'action', action: 'toggleOverwrite', context: 'insert' },\n    // Motions\n    { keys: 'H', type: 'motion', motion: 'moveToTopLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'M', type: 'motion', motion: 'moveToMiddleLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'L', type: 'motion', motion: 'moveToBottomLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'h', type: 'motion', motion: 'moveByCharacters', motionArgs: { forward: false }},\n    { keys: 'l', type: 'motion', motion: 'moveByCharacters', motionArgs: { forward: true }},\n    { keys: 'j', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, linewise: true }},\n    { keys: 'k', type: 'motion', motion: 'moveByLines', motionArgs: { forward: false, linewise: true }},\n    { keys: 'gj', type: 'motion', motion: 'moveByDisplayLines', motionArgs: { forward: true }},\n    { keys: 'gk', type: 'motion', motion: 'moveByDisplayLines', motionArgs: { forward: false }},\n    { keys: 'w', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: false }},\n    { keys: 'W', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: false, bigWord: true }},\n    { keys: 'e', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: true, inclusive: true }},\n    { keys: 'E', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: true, bigWord: true, inclusive: true }},\n    { keys: 'b', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false }},\n    { keys: 'B', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false, bigWord: true }},\n    { keys: 'ge', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: true, inclusive: true }},\n    { keys: 'gE', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: true, bigWord: true, inclusive: true }},\n    { keys: '{', type: 'motion', motion: 'moveByParagraph', motionArgs: { forward: false, toJumplist: true }},\n    { keys: '}', type: 'motion', motion: 'moveByParagraph', motionArgs: { forward: true, toJumplist: true }},\n    { keys: '(', type: 'motion', motion: 'moveBySentence', motionArgs: { forward: false }},\n    { keys: ')', type: 'motion', motion: 'moveBySentence', motionArgs: { forward: true }},\n    { keys: '<C-f>', type: 'motion', motion: 'moveByPage', motionArgs: { forward: true }},\n    { keys: '<C-b>', type: 'motion', motion: 'moveByPage', motionArgs: { forward: false }},\n    { keys: '<C-d>', type: 'motion', motion: 'moveByScroll', motionArgs: { forward: true, explicitRepeat: true }},\n    { keys: '<C-u>', type: 'motion', motion: 'moveByScroll', motionArgs: { forward: false, explicitRepeat: true }},\n    { keys: 'gg', type: 'motion', motion: 'moveToLineOrEdgeOfDocument', motionArgs: { forward: false, explicitRepeat: true, linewise: true, toJumplist: true }},\n    { keys: 'G', type: 'motion', motion: 'moveToLineOrEdgeOfDocument', motionArgs: { forward: true, explicitRepeat: true, linewise: true, toJumplist: true }},\n    { keys: '0', type: 'motion', motion: 'moveToStartOfLine' },\n    { keys: '^', type: 'motion', motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: '+', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, toFirstChar:true }},\n    { keys: '-', type: 'motion', motion: 'moveByLines', motionArgs: { forward: false, toFirstChar:true }},\n    { keys: '_', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, toFirstChar:true, repeatOffset:-1 }},\n    { keys: '$', type: 'motion', motion: 'moveToEol', motionArgs: { inclusive: true }},\n    { keys: '%', type: 'motion', motion: 'moveToMatchedSymbol', motionArgs: { inclusive: true, toJumplist: true }},\n    { keys: 'f<character>', type: 'motion', motion: 'moveToCharacter', motionArgs: { forward: true , inclusive: true }},\n    { keys: 'F<character>', type: 'motion', motion: 'moveToCharacter', motionArgs: { forward: false }},\n    { keys: 't<character>', type: 'motion', motion: 'moveTillCharacter', motionArgs: { forward: true, inclusive: true }},\n    { keys: 'T<character>', type: 'motion', motion: 'moveTillCharacter', motionArgs: { forward: false }},\n    { keys: ';', type: 'motion', motion: 'repeatLastCharacterSearch', motionArgs: { forward: true }},\n    { keys: ',', type: 'motion', motion: 'repeatLastCharacterSearch', motionArgs: { forward: false }},\n    { keys: '\\'<character>', type: 'motion', motion: 'goToMark', motionArgs: {toJumplist: true, linewise: true}},\n    { keys: '`<character>', type: 'motion', motion: 'goToMark', motionArgs: {toJumplist: true}},\n    { keys: ']`', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true } },\n    { keys: '[`', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false } },\n    { keys: ']\\'', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true, linewise: true } },\n    { keys: '[\\'', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false, linewise: true } },\n    // the next two aren't motions but must come before more general motion declarations\n    { keys: ']p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: true, isEdit: true, matchIndent: true}},\n    { keys: '[p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: false, isEdit: true, matchIndent: true}},\n    { keys: ']<character>', type: 'motion', motion: 'moveToSymbol', motionArgs: { forward: true, toJumplist: true}},\n    { keys: '[<character>', type: 'motion', motion: 'moveToSymbol', motionArgs: { forward: false, toJumplist: true}},\n    { keys: '|', type: 'motion', motion: 'moveToColumn'},\n    { keys: 'o', type: 'motion', motion: 'moveToOtherHighlightedEnd', context:'visual'},\n    { keys: 'O', type: 'motion', motion: 'moveToOtherHighlightedEnd', motionArgs: {sameLine: true}, context:'visual'},\n    // Operators\n    { keys: 'd', type: 'operator', operator: 'delete' },\n    { keys: 'y', type: 'operator', operator: 'yank' },\n    { keys: 'c', type: 'operator', operator: 'change' },\n    { keys: '>', type: 'operator', operator: 'indent', operatorArgs: { indentRight: true }},\n    { keys: '<', type: 'operator', operator: 'indent', operatorArgs: { indentRight: false }},\n    { keys: 'g~', type: 'operator', operator: 'changeCase' },\n    { keys: 'gu', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: true}, isEdit: true },\n    { keys: 'gU', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: false}, isEdit: true },\n    { keys: 'n', type: 'motion', motion: 'findNext', motionArgs: { forward: true, toJumplist: true }},\n    { keys: 'N', type: 'motion', motion: 'findNext', motionArgs: { forward: false, toJumplist: true }},\n    // Operator-Motion dual commands\n    { keys: 'x', type: 'operatorMotion', operator: 'delete', motion: 'moveByCharacters', motionArgs: { forward: true }, operatorMotionArgs: { visualLine: false }},\n    { keys: 'X', type: 'operatorMotion', operator: 'delete', motion: 'moveByCharacters', motionArgs: { forward: false }, operatorMotionArgs: { visualLine: true }},\n    { keys: 'D', type: 'operatorMotion', operator: 'delete', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal'},\n    { keys: 'D', type: 'operator', operator: 'delete', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: 'Y', type: 'operatorMotion', operator: 'yank', motion: 'expandToLine', motionArgs: { linewise: true }, context: 'normal'},\n    { keys: 'Y', type: 'operator', operator: 'yank', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: 'C', type: 'operatorMotion', operator: 'change', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal'},\n    { keys: 'C', type: 'operator', operator: 'change', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: '~', type: 'operatorMotion', operator: 'changeCase', motion: 'moveByCharacters', motionArgs: { forward: true }, operatorArgs: { shouldMoveCursor: true }, context: 'normal'},\n    { keys: '~', type: 'operator', operator: 'changeCase', context: 'visual'},\n    { keys: '<C-w>', type: 'operatorMotion', operator: 'delete', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false }, context: 'insert' },\n    // Actions\n    { keys: '<C-i>', type: 'action', action: 'jumpListWalk', actionArgs: { forward: true }},\n    { keys: '<C-o>', type: 'action', action: 'jumpListWalk', actionArgs: { forward: false }},\n    { keys: '<C-e>', type: 'action', action: 'scroll', actionArgs: { forward: true, linewise: true }},\n    { keys: '<C-y>', type: 'action', action: 'scroll', actionArgs: { forward: false, linewise: true }},\n    { keys: 'a', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'charAfter' }, context: 'normal' },\n    { keys: 'A', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'eol' }, context: 'normal' },\n    { keys: 'A', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'endOfSelectedArea' }, context: 'visual' },\n    { keys: 'i', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'inplace' }, context: 'normal' },\n    { keys: 'I', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'firstNonBlank'}, context: 'normal' },\n    { keys: 'I', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'startOfSelectedArea' }, context: 'visual' },\n    { keys: 'o', type: 'action', action: 'newLineAndEnterInsertMode', isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: true }, context: 'normal' },\n    { keys: 'O', type: 'action', action: 'newLineAndEnterInsertMode', isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: false }, context: 'normal' },\n    { keys: 'v', type: 'action', action: 'toggleVisualMode' },\n    { keys: 'V', type: 'action', action: 'toggleVisualMode', actionArgs: { linewise: true }},\n    { keys: '<C-v>', type: 'action', action: 'toggleVisualMode', actionArgs: { blockwise: true }},\n    { keys: '<C-q>', type: 'action', action: 'toggleVisualMode', actionArgs: { blockwise: true }},\n    { keys: 'gv', type: 'action', action: 'reselectLastSelection' },\n    { keys: 'J', type: 'action', action: 'joinLines', isEdit: true },\n    { keys: 'p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: true, isEdit: true }},\n    { keys: 'P', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: false, isEdit: true }},\n    { keys: 'r<character>', type: 'action', action: 'replace', isEdit: true },\n    { keys: '@<character>', type: 'action', action: 'replayMacro' },\n    { keys: 'q<character>', type: 'action', action: 'enterMacroRecordMode' },\n    // Handle Replace-mode as a special case of insert mode.\n    { keys: 'R', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { replace: true }},\n    { keys: 'u', type: 'action', action: 'undo', context: 'normal' },\n    { keys: 'u', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: true}, context: 'visual', isEdit: true },\n    { keys: 'U', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: false}, context: 'visual', isEdit: true },\n    { keys: '<C-r>', type: 'action', action: 'redo' },\n    { keys: 'm<character>', type: 'action', action: 'setMark' },\n    { keys: '\"<character>', type: 'action', action: 'setRegister' },\n    { keys: 'zz', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'center' }},\n    { keys: 'z.', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'center' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: 'zt', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'top' }},\n    { keys: 'z<CR>', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'top' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: 'z-', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'bottom' }},\n    { keys: 'zb', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'bottom' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: '.', type: 'action', action: 'repeatLastEdit' },\n    { keys: '<C-a>', type: 'action', action: 'incrementNumberToken', isEdit: true, actionArgs: {increase: true, backtrack: false}},\n    { keys: '<C-x>', type: 'action', action: 'incrementNumberToken', isEdit: true, actionArgs: {increase: false, backtrack: false}},\n    { keys: '<C-t>', type: 'action', action: 'indent', actionArgs: { indentRight: true }, context: 'insert' },\n    { keys: '<C-d>', type: 'action', action: 'indent', actionArgs: { indentRight: false }, context: 'insert' },\n    // Text object motions\n    { keys: 'a<character>', type: 'motion', motion: 'textObjectManipulation' },\n    { keys: 'i<character>', type: 'motion', motion: 'textObjectManipulation', motionArgs: { textObjectInner: true }},\n    // Search\n    { keys: '/', type: 'search', searchArgs: { forward: true, querySrc: 'prompt', toJumplist: true }},\n    { keys: '?', type: 'search', searchArgs: { forward: false, querySrc: 'prompt', toJumplist: true }},\n    { keys: '*', type: 'search', searchArgs: { forward: true, querySrc: 'wordUnderCursor', wholeWordOnly: true, toJumplist: true }},\n    { keys: '#', type: 'search', searchArgs: { forward: false, querySrc: 'wordUnderCursor', wholeWordOnly: true, toJumplist: true }},\n    { keys: 'g*', type: 'search', searchArgs: { forward: true, querySrc: 'wordUnderCursor', toJumplist: true }},\n    { keys: 'g#', type: 'search', searchArgs: { forward: false, querySrc: 'wordUnderCursor', toJumplist: true }},\n    // Ex command\n    { keys: ':', type: 'ex' }\n  ];\n\n  /**\n   * Ex commands\n   * Care must be taken when adding to the default Ex command map. For any\n   * pair of commands that have a shared prefix, at least one of their\n   * shortNames must not match the prefix of the other command.\n   */\n  var defaultExCommandMap = [\n    { name: 'colorscheme', shortName: 'colo' },\n    { name: 'map' },\n    { name: 'imap', shortName: 'im' },\n    { name: 'nmap', shortName: 'nm' },\n    { name: 'vmap', shortName: 'vm' },\n    { name: 'unmap' },\n    { name: 'write', shortName: 'w' },\n    { name: 'undo', shortName: 'u' },\n    { name: 'redo', shortName: 'red' },\n    { name: 'set', shortName: 'se' },\n    { name: 'set', shortName: 'se' },\n    { name: 'setlocal', shortName: 'setl' },\n    { name: 'setglobal', shortName: 'setg' },\n    { name: 'sort', shortName: 'sor' },\n    { name: 'substitute', shortName: 's', possiblyAsync: true },\n    { name: 'nohlsearch', shortName: 'noh' },\n    { name: 'yank', shortName: 'y' },\n    { name: 'delmarks', shortName: 'delm' },\n    { name: 'registers', shortName: 'reg', excludeFromCommandHistory: true },\n    { name: 'global', shortName: 'g' }\n  ];\n\n  var Pos = CodeMirror.Pos;\n\n  var Vim = function() {\n    function enterVimMode(cm) {\n      cm.setOption('disableInput', true);\n      cm.setOption('showCursorWhenSelecting', false);\n      CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n      cm.on('cursorActivity', onCursorActivity);\n      maybeInitVimState(cm);\n      CodeMirror.on(cm.getInputField(), 'paste', getOnPasteFn(cm));\n    }\n\n    function leaveVimMode(cm) {\n      cm.setOption('disableInput', false);\n      cm.off('cursorActivity', onCursorActivity);\n      CodeMirror.off(cm.getInputField(), 'paste', getOnPasteFn(cm));\n      cm.state.vim = null;\n    }\n\n    function detachVimMap(cm, next) {\n      if (this == CodeMirror.keyMap.vim) {\n        CodeMirror.rmClass(cm.getWrapperElement(), \"cm-fat-cursor\");\n        if (cm.getOption(\"inputStyle\") == \"contenteditable\" && document.body.style.caretColor != null) {\n          disableFatCursorMark(cm);\n          cm.getInputField().style.caretColor = \"\";\n        }\n      }\n\n      if (!next || next.attach != attachVimMap)\n        leaveVimMode(cm);\n    }\n    function attachVimMap(cm, prev) {\n      if (this == CodeMirror.keyMap.vim) {\n        CodeMirror.addClass(cm.getWrapperElement(), \"cm-fat-cursor\");\n        if (cm.getOption(\"inputStyle\") == \"contenteditable\" && document.body.style.caretColor != null) {\n          enableFatCursorMark(cm);\n          cm.getInputField().style.caretColor = \"transparent\";\n        }\n      }\n\n      if (!prev || prev.attach != attachVimMap)\n        enterVimMode(cm);\n    }\n\n    function fatCursorMarks(cm) {\n      var ranges = cm.listSelections(), result = []\n      for (var i = 0; i < ranges.length; i++) {\n        var range = ranges[i]\n        if (range.empty()) {\n          if (range.anchor.ch < cm.getLine(range.anchor.line).length) {\n            result.push(cm.markText(range.anchor, Pos(range.anchor.line, range.anchor.ch + 1),\n                                    {className: \"cm-fat-cursor-mark\"}))\n          } else {\n            var widget = document.createElement(\"span\")\n            widget.textContent = \"\\u00a0\"\n            widget.className = \"cm-fat-cursor-mark\"\n            result.push(cm.setBookmark(range.anchor, {widget: widget}))\n          }\n        }\n      }\n      return result\n    }\n\n    function updateFatCursorMark(cm) {\n      var marks = cm.state.fatCursorMarks\n      if (marks) for (var i = 0; i < marks.length; i++) marks[i].clear()\n      cm.state.fatCursorMarks = fatCursorMarks(cm)\n    }\n\n    function enableFatCursorMark(cm) {\n      cm.state.fatCursorMarks = fatCursorMarks(cm)\n      cm.on(\"cursorActivity\", updateFatCursorMark)\n    }\n\n    function disableFatCursorMark(cm) {\n      var marks = cm.state.fatCursorMarks\n      if (marks) for (var i = 0; i < marks.length; i++) marks[i].clear()\n      cm.state.fatCursorMarks = null\n      cm.off(\"cursorActivity\", updateFatCursorMark)\n    }\n\n    // Deprecated, simply setting the keymap works again.\n    CodeMirror.defineOption('vimMode', false, function(cm, val, prev) {\n      if (val && cm.getOption(\"keyMap\") != \"vim\")\n        cm.setOption(\"keyMap\", \"vim\");\n      else if (!val && prev != CodeMirror.Init && /^vim/.test(cm.getOption(\"keyMap\")))\n        cm.setOption(\"keyMap\", \"default\");\n    });\n\n    function cmKey(key, cm) {\n      if (!cm) { return undefined; }\n      if (this[key]) { return this[key]; }\n      var vimKey = cmKeyToVimKey(key);\n      if (!vimKey) {\n        return false;\n      }\n      var cmd = CodeMirror.Vim.findKey(cm, vimKey);\n      if (typeof cmd == 'function') {\n        CodeMirror.signal(cm, 'vim-keypress', vimKey);\n      }\n      return cmd;\n    }\n\n    var modifiers = {'Shift': 'S', 'Ctrl': 'C', 'Alt': 'A', 'Cmd': 'D', 'Mod': 'A'};\n    var specialKeys = {Enter:'CR',Backspace:'BS',Delete:'Del',Insert:'Ins'};\n    function cmKeyToVimKey(key) {\n      if (key.charAt(0) == '\\'') {\n        // Keypress character binding of format \"'a'\"\n        return key.charAt(1);\n      }\n      var pieces = key.split(/-(?!$)/);\n      var lastPiece = pieces[pieces.length - 1];\n      if (pieces.length == 1 && pieces[0].length == 1) {\n        // No-modifier bindings use literal character bindings above. Skip.\n        return false;\n      } else if (pieces.length == 2 && pieces[0] == 'Shift' && lastPiece.length == 1) {\n        // Ignore Shift+char bindings as they should be handled by literal character.\n        return false;\n      }\n      var hasCharacter = false;\n      for (var i = 0; i < pieces.length; i++) {\n        var piece = pieces[i];\n        if (piece in modifiers) { pieces[i] = modifiers[piece]; }\n        else { hasCharacter = true; }\n        if (piece in specialKeys) { pieces[i] = specialKeys[piece]; }\n      }\n      if (!hasCharacter) {\n        // Vim does not support modifier only keys.\n        return false;\n      }\n      // TODO: Current bindings expect the character to be lower case, but\n      // it looks like vim key notation uses upper case.\n      if (isUpperCase(lastPiece)) {\n        pieces[pieces.length - 1] = lastPiece.toLowerCase();\n      }\n      return '<' + pieces.join('-') + '>';\n    }\n\n    function getOnPasteFn(cm) {\n      var vim = cm.state.vim;\n      if (!vim.onPasteFn) {\n        vim.onPasteFn = function() {\n          if (!vim.insertMode) {\n            cm.setCursor(offsetCursor(cm.getCursor(), 0, 1));\n            actions.enterInsertMode(cm, {}, vim);\n          }\n        };\n      }\n      return vim.onPasteFn;\n    }\n\n    var numberRegex = /[\\d]/;\n    var wordCharTest = [CodeMirror.isWordChar, function(ch) {\n      return ch && !CodeMirror.isWordChar(ch) && !/\\s/.test(ch);\n    }], bigWordCharTest = [function(ch) {\n      return /\\S/.test(ch);\n    }];\n    function makeKeyRange(start, size) {\n      var keys = [];\n      for (var i = start; i < start + size; i++) {\n        keys.push(String.fromCharCode(i));\n      }\n      return keys;\n    }\n    var upperCaseAlphabet = makeKeyRange(65, 26);\n    var lowerCaseAlphabet = makeKeyRange(97, 26);\n    var numbers = makeKeyRange(48, 10);\n    var validMarks = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['<', '>']);\n    var validRegisters = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['-', '\"', '.', ':', '/']);\n\n    function isLine(cm, line) {\n      return line >= cm.firstLine() && line <= cm.lastLine();\n    }\n    function isLowerCase(k) {\n      return (/^[a-z]$/).test(k);\n    }\n    function isMatchableSymbol(k) {\n      return '()[]{}'.indexOf(k) != -1;\n    }\n    function isNumber(k) {\n      return numberRegex.test(k);\n    }\n    function isUpperCase(k) {\n      return (/^[A-Z]$/).test(k);\n    }\n    function isWhiteSpaceString(k) {\n      return (/^\\s*$/).test(k);\n    }\n    function isEndOfSentenceSymbol(k) {\n      return '.?!'.indexOf(k) != -1;\n    }\n    function inArray(val, arr) {\n      for (var i = 0; i < arr.length; i++) {\n        if (arr[i] == val) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    var options = {};\n    function defineOption(name, defaultValue, type, aliases, callback) {\n      if (defaultValue === undefined && !callback) {\n        throw Error('defaultValue is required unless callback is provided');\n      }\n      if (!type) { type = 'string'; }\n      options[name] = {\n        type: type,\n        defaultValue: defaultValue,\n        callback: callback\n      };\n      if (aliases) {\n        for (var i = 0; i < aliases.length; i++) {\n          options[aliases[i]] = options[name];\n        }\n      }\n      if (defaultValue) {\n        setOption(name, defaultValue);\n      }\n    }\n\n    function setOption(name, value, cm, cfg) {\n      var option = options[name];\n      cfg = cfg || {};\n      var scope = cfg.scope;\n      if (!option) {\n        return new Error('Unknown option: ' + name);\n      }\n      if (option.type == 'boolean') {\n        if (value && value !== true) {\n          return new Error('Invalid argument: ' + name + '=' + value);\n        } else if (value !== false) {\n          // Boolean options are set to true if value is not defined.\n          value = true;\n        }\n      }\n      if (option.callback) {\n        if (scope !== 'local') {\n          option.callback(value, undefined);\n        }\n        if (scope !== 'global' && cm) {\n          option.callback(value, cm);\n        }\n      } else {\n        if (scope !== 'local') {\n          option.value = option.type == 'boolean' ? !!value : value;\n        }\n        if (scope !== 'global' && cm) {\n          cm.state.vim.options[name] = {value: value};\n        }\n      }\n    }\n\n    function getOption(name, cm, cfg) {\n      var option = options[name];\n      cfg = cfg || {};\n      var scope = cfg.scope;\n      if (!option) {\n        return new Error('Unknown option: ' + name);\n      }\n      if (option.callback) {\n        var local = cm && option.callback(undefined, cm);\n        if (scope !== 'global' && local !== undefined) {\n          return local;\n        }\n        if (scope !== 'local') {\n          return option.callback();\n        }\n        return;\n      } else {\n        var local = (scope !== 'global') && (cm && cm.state.vim.options[name]);\n        return (local || (scope !== 'local') && option || {}).value;\n      }\n    }\n\n    defineOption('filetype', undefined, 'string', ['ft'], function(name, cm) {\n      // Option is local. Do nothing for global.\n      if (cm === undefined) {\n        return;\n      }\n      // The 'filetype' option proxies to the CodeMirror 'mode' option.\n      if (name === undefined) {\n        var mode = cm.getOption('mode');\n        return mode == 'null' ? '' : mode;\n      } else {\n        var mode = name == '' ? 'null' : name;\n        cm.setOption('mode', mode);\n      }\n    });\n\n    var createCircularJumpList = function() {\n      var size = 100;\n      var pointer = -1;\n      var head = 0;\n      var tail = 0;\n      var buffer = new Array(size);\n      function add(cm, oldCur, newCur) {\n        var current = pointer % size;\n        var curMark = buffer[current];\n        function useNextSlot(cursor) {\n          var next = ++pointer % size;\n          var trashMark = buffer[next];\n          if (trashMark) {\n            trashMark.clear();\n          }\n          buffer[next] = cm.setBookmark(cursor);\n        }\n        if (curMark) {\n          var markPos = curMark.find();\n          // avoid recording redundant cursor position\n          if (markPos && !cursorEqual(markPos, oldCur)) {\n            useNextSlot(oldCur);\n          }\n        } else {\n          useNextSlot(oldCur);\n        }\n        useNextSlot(newCur);\n        head = pointer;\n        tail = pointer - size + 1;\n        if (tail < 0) {\n          tail = 0;\n        }\n      }\n      function move(cm, offset) {\n        pointer += offset;\n        if (pointer > head) {\n          pointer = head;\n        } else if (pointer < tail) {\n          pointer = tail;\n        }\n        var mark = buffer[(size + pointer) % size];\n        // skip marks that are temporarily removed from text buffer\n        if (mark && !mark.find()) {\n          var inc = offset > 0 ? 1 : -1;\n          var newCur;\n          var oldCur = cm.getCursor();\n          do {\n            pointer += inc;\n            mark = buffer[(size + pointer) % size];\n            // skip marks that are the same as current position\n            if (mark &&\n                (newCur = mark.find()) &&\n                !cursorEqual(oldCur, newCur)) {\n              break;\n            }\n          } while (pointer < head && pointer > tail);\n        }\n        return mark;\n      }\n      return {\n        cachedCursor: undefined, //used for # and * jumps\n        add: add,\n        move: move\n      };\n    };\n\n    // Returns an object to track the changes associated insert mode.  It\n    // clones the object that is passed in, or creates an empty object one if\n    // none is provided.\n    var createInsertModeChanges = function(c) {\n      if (c) {\n        // Copy construction\n        return {\n          changes: c.changes,\n          expectCursorActivityForChange: c.expectCursorActivityForChange\n        };\n      }\n      return {\n        // Change list\n        changes: [],\n        // Set to true on change, false on cursorActivity.\n        expectCursorActivityForChange: false\n      };\n    };\n\n    function MacroModeState() {\n      this.latestRegister = undefined;\n      this.isPlaying = false;\n      this.isRecording = false;\n      this.replaySearchQueries = [];\n      this.onRecordingDone = undefined;\n      this.lastInsertModeChanges = createInsertModeChanges();\n    }\n    MacroModeState.prototype = {\n      exitMacroRecordMode: function() {\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.onRecordingDone) {\n          macroModeState.onRecordingDone(); // close dialog\n        }\n        macroModeState.onRecordingDone = undefined;\n        macroModeState.isRecording = false;\n      },\n      enterMacroRecordMode: function(cm, registerName) {\n        var register =\n            vimGlobalState.registerController.getRegister(registerName);\n        if (register) {\n          register.clear();\n          this.latestRegister = registerName;\n          if (cm.openDialog) {\n            this.onRecordingDone = cm.openDialog(\n                '(recording)['+registerName+']', null, {bottom:true});\n          }\n          this.isRecording = true;\n        }\n      }\n    };\n\n    function maybeInitVimState(cm) {\n      if (!cm.state.vim) {\n        // Store instance state in the CodeMirror object.\n        cm.state.vim = {\n          inputState: new InputState(),\n          // Vim's input state that triggered the last edit, used to repeat\n          // motions and operators with '.'.\n          lastEditInputState: undefined,\n          // Vim's action command before the last edit, used to repeat actions\n          // with '.' and insert mode repeat.\n          lastEditActionCommand: undefined,\n          // When using jk for navigation, if you move from a longer line to a\n          // shorter line, the cursor may clip to the end of the shorter line.\n          // If j is pressed again and cursor goes to the next line, the\n          // cursor should go back to its horizontal position on the longer\n          // line if it can. This is to keep track of the horizontal position.\n          lastHPos: -1,\n          // Doing the same with screen-position for gj/gk\n          lastHSPos: -1,\n          // The last motion command run. Cleared if a non-motion command gets\n          // executed in between.\n          lastMotion: null,\n          marks: {},\n          // Mark for rendering fake cursor for visual mode.\n          fakeCursor: null,\n          insertMode: false,\n          // Repeat count for changes made in insert mode, triggered by key\n          // sequences like 3,i. Only exists when insertMode is true.\n          insertModeRepeat: undefined,\n          visualMode: false,\n          // If we are in visual line mode. No effect if visualMode is false.\n          visualLine: false,\n          visualBlock: false,\n          lastSelection: null,\n          lastPastedText: null,\n          sel: {},\n          // Buffer-local/window-local values of vim options.\n          options: {}\n        };\n      }\n      return cm.state.vim;\n    }\n    var vimGlobalState;\n    function resetVimGlobalState() {\n      vimGlobalState = {\n        // The current search query.\n        searchQuery: null,\n        // Whether we are searching backwards.\n        searchIsReversed: false,\n        // Replace part of the last substituted pattern\n        lastSubstituteReplacePart: undefined,\n        jumpList: createCircularJumpList(),\n        macroModeState: new MacroModeState,\n        // Recording latest f, t, F or T motion command.\n        lastCharacterSearch: {increment:0, forward:true, selectedCharacter:''},\n        registerController: new RegisterController({}),\n        // search history buffer\n        searchHistoryController: new HistoryController(),\n        // ex Command history buffer\n        exCommandHistoryController : new HistoryController()\n      };\n      for (var optionName in options) {\n        var option = options[optionName];\n        option.value = option.defaultValue;\n      }\n    }\n\n    var lastInsertModeKeyTimer;\n    var vimApi= {\n      buildKeyMap: function() {\n        // TODO: Convert keymap into dictionary format for fast lookup.\n      },\n      // Testing hook, though it might be useful to expose the register\n      // controller anyways.\n      getRegisterController: function() {\n        return vimGlobalState.registerController;\n      },\n      // Testing hook.\n      resetVimGlobalState_: resetVimGlobalState,\n\n      // Testing hook.\n      getVimGlobalState_: function() {\n        return vimGlobalState;\n      },\n\n      // Testing hook.\n      maybeInitVimState_: maybeInitVimState,\n\n      suppressErrorLogging: false,\n\n      InsertModeKey: InsertModeKey,\n      map: function(lhs, rhs, ctx) {\n        // Add user defined key bindings.\n        exCommandDispatcher.map(lhs, rhs, ctx);\n      },\n      unmap: function(lhs, ctx) {\n        exCommandDispatcher.unmap(lhs, ctx);\n      },\n      // TODO: Expose setOption and getOption as instance methods. Need to decide how to namespace\n      // them, or somehow make them work with the existing CodeMirror setOption/getOption API.\n      setOption: setOption,\n      getOption: getOption,\n      defineOption: defineOption,\n      defineEx: function(name, prefix, func){\n        if (!prefix) {\n          prefix = name;\n        } else if (name.indexOf(prefix) !== 0) {\n          throw new Error('(Vim.defineEx) \"'+prefix+'\" is not a prefix of \"'+name+'\", command not registered');\n        }\n        exCommands[name]=func;\n        exCommandDispatcher.commandMap_[prefix]={name:name, shortName:prefix, type:'api'};\n      },\n      handleKey: function (cm, key, origin) {\n        var command = this.findKey(cm, key, origin);\n        if (typeof command === 'function') {\n          return command();\n        }\n      },\n      /**\n       * This is the outermost function called by CodeMirror, after keys have\n       * been mapped to their Vim equivalents.\n       *\n       * Finds a command based on the key (and cached keys if there is a\n       * multi-key sequence). Returns `undefined` if no key is matched, a noop\n       * function if a partial match is found (multi-key), and a function to\n       * execute the bound command if a a key is matched. The function always\n       * returns true.\n       */\n      findKey: function(cm, key, origin) {\n        var vim = maybeInitVimState(cm);\n        function handleMacroRecording() {\n          var macroModeState = vimGlobalState.macroModeState;\n          if (macroModeState.isRecording) {\n            if (key == 'q') {\n              macroModeState.exitMacroRecordMode();\n              clearInputState(cm);\n              return true;\n            }\n            if (origin != 'mapping') {\n              logKey(macroModeState, key);\n            }\n          }\n        }\n        function handleEsc() {\n          if (key == '<Esc>') {\n            // Clear input state and get back to normal mode.\n            clearInputState(cm);\n            if (vim.visualMode) {\n              exitVisualMode(cm);\n            } else if (vim.insertMode) {\n              exitInsertMode(cm);\n            }\n            return true;\n          }\n        }\n        function doKeyToKey(keys) {\n          // TODO: prevent infinite recursion.\n          var match;\n          while (keys) {\n            // Pull off one command key, which is either a single character\n            // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.\n            match = (/<\\w+-.+?>|<\\w+>|./).exec(keys);\n            key = match[0];\n            keys = keys.substring(match.index + key.length);\n            CodeMirror.Vim.handleKey(cm, key, 'mapping');\n          }\n        }\n\n        function handleKeyInsertMode() {\n          if (handleEsc()) { return true; }\n          var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;\n          var keysAreChars = key.length == 1;\n          var match = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\n          // Need to check all key substrings in insert mode.\n          while (keys.length > 1 && match.type != 'full') {\n            var keys = vim.inputState.keyBuffer = keys.slice(1);\n            var thisMatch = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\n            if (thisMatch.type != 'none') { match = thisMatch; }\n          }\n          if (match.type == 'none') { clearInputState(cm); return false; }\n          else if (match.type == 'partial') {\n            if (lastInsertModeKeyTimer) { window.clearTimeout(lastInsertModeKeyTimer); }\n            lastInsertModeKeyTimer = window.setTimeout(\n              function() { if (vim.insertMode && vim.inputState.keyBuffer) { clearInputState(cm); } },\n              getOption('insertModeEscKeysTimeout'));\n            return !keysAreChars;\n          }\n\n          if (lastInsertModeKeyTimer) { window.clearTimeout(lastInsertModeKeyTimer); }\n          if (keysAreChars) {\n            var selections = cm.listSelections();\n            for (var i = 0; i < selections.length; i++) {\n              var here = selections[i].head;\n              cm.replaceRange('', offsetCursor(here, 0, -(keys.length - 1)), here, '+input');\n            }\n            vimGlobalState.macroModeState.lastInsertModeChanges.changes.pop();\n          }\n          clearInputState(cm);\n          return match.command;\n        }\n\n        function handleKeyNonInsertMode() {\n          if (handleMacroRecording() || handleEsc()) { return true; }\n\n          var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;\n          if (/^[1-9]\\d*$/.test(keys)) { return true; }\n\n          var keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n          if (!keysMatcher) { clearInputState(cm); return false; }\n          var context = vim.visualMode ? 'visual' :\n                                         'normal';\n          var match = commandDispatcher.matchCommand(keysMatcher[2] || keysMatcher[1], defaultKeymap, vim.inputState, context);\n          if (match.type == 'none') { clearInputState(cm); return false; }\n          else if (match.type == 'partial') { return true; }\n\n          vim.inputState.keyBuffer = '';\n          var keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n          if (keysMatcher[1] && keysMatcher[1] != '0') {\n            vim.inputState.pushRepeatDigit(keysMatcher[1]);\n          }\n          return match.command;\n        }\n\n        var command;\n        if (vim.insertMode) { command = handleKeyInsertMode(); }\n        else { command = handleKeyNonInsertMode(); }\n        if (command === false) {\n          return !vim.insertMode && key.length === 1 ? function() { return true; } : undefined;\n        } else if (command === true) {\n          // TODO: Look into using CodeMirror's multi-key handling.\n          // Return no-op since we are caching the key. Counts as handled, but\n          // don't want act on it just yet.\n          return function() { return true; };\n        } else {\n          return function() {\n            return cm.operation(function() {\n              cm.curOp.isVimOp = true;\n              try {\n                if (command.type == 'keyToKey') {\n                  doKeyToKey(command.toKeys);\n                } else {\n                  commandDispatcher.processCommand(cm, vim, command);\n                }\n              } catch (e) {\n                // clear VIM state in case it's in a bad state.\n                cm.state.vim = undefined;\n                maybeInitVimState(cm);\n                if (!CodeMirror.Vim.suppressErrorLogging) {\n                  console['log'](e);\n                }\n                throw e;\n              }\n              return true;\n            });\n          };\n        }\n      },\n      handleEx: function(cm, input) {\n        exCommandDispatcher.processCommand(cm, input);\n      },\n\n      defineMotion: defineMotion,\n      defineAction: defineAction,\n      defineOperator: defineOperator,\n      mapCommand: mapCommand,\n      _mapCommand: _mapCommand,\n\n      defineRegister: defineRegister,\n\n      exitVisualMode: exitVisualMode,\n      exitInsertMode: exitInsertMode\n    };\n\n    // Represents the current input state.\n    function InputState() {\n      this.prefixRepeat = [];\n      this.motionRepeat = [];\n\n      this.operator = null;\n      this.operatorArgs = null;\n      this.motion = null;\n      this.motionArgs = null;\n      this.keyBuffer = []; // For matching multi-key commands.\n      this.registerName = null; // Defaults to the unnamed register.\n    }\n    InputState.prototype.pushRepeatDigit = function(n) {\n      if (!this.operator) {\n        this.prefixRepeat = this.prefixRepeat.concat(n);\n      } else {\n        this.motionRepeat = this.motionRepeat.concat(n);\n      }\n    };\n    InputState.prototype.getRepeat = function() {\n      var repeat = 0;\n      if (this.prefixRepeat.length > 0 || this.motionRepeat.length > 0) {\n        repeat = 1;\n        if (this.prefixRepeat.length > 0) {\n          repeat *= parseInt(this.prefixRepeat.join(''), 10);\n        }\n        if (this.motionRepeat.length > 0) {\n          repeat *= parseInt(this.motionRepeat.join(''), 10);\n        }\n      }\n      return repeat;\n    };\n\n    function clearInputState(cm, reason) {\n      cm.state.vim.inputState = new InputState();\n      CodeMirror.signal(cm, 'vim-command-done', reason);\n    }\n\n    /*\n     * Register stores information about copy and paste registers.  Besides\n     * text, a register must store whether it is linewise (i.e., when it is\n     * pasted, should it insert itself into a new line, or should the text be\n     * inserted at the cursor position.)\n     */\n    function Register(text, linewise, blockwise) {\n      this.clear();\n      this.keyBuffer = [text || ''];\n      this.insertModeChanges = [];\n      this.searchQueries = [];\n      this.linewise = !!linewise;\n      this.blockwise = !!blockwise;\n    }\n    Register.prototype = {\n      setText: function(text, linewise, blockwise) {\n        this.keyBuffer = [text || ''];\n        this.linewise = !!linewise;\n        this.blockwise = !!blockwise;\n      },\n      pushText: function(text, linewise) {\n        // if this register has ever been set to linewise, use linewise.\n        if (linewise) {\n          if (!this.linewise) {\n            this.keyBuffer.push('\\n');\n          }\n          this.linewise = true;\n        }\n        this.keyBuffer.push(text);\n      },\n      pushInsertModeChanges: function(changes) {\n        this.insertModeChanges.push(createInsertModeChanges(changes));\n      },\n      pushSearchQuery: function(query) {\n        this.searchQueries.push(query);\n      },\n      clear: function() {\n        this.keyBuffer = [];\n        this.insertModeChanges = [];\n        this.searchQueries = [];\n        this.linewise = false;\n      },\n      toString: function() {\n        return this.keyBuffer.join('');\n      }\n    };\n\n    /**\n     * Defines an external register.\n     *\n     * The name should be a single character that will be used to reference the register.\n     * The register should support setText, pushText, clear, and toString(). See Register\n     * for a reference implementation.\n     */\n    function defineRegister(name, register) {\n      var registers = vimGlobalState.registerController.registers;\n      if (!name || name.length != 1) {\n        throw Error('Register name must be 1 character');\n      }\n      if (registers[name]) {\n        throw Error('Register already defined ' + name);\n      }\n      registers[name] = register;\n      validRegisters.push(name);\n    }\n\n    /*\n     * vim registers allow you to keep many independent copy and paste buffers.\n     * See http://usevim.com/2012/04/13/registers/ for an introduction.\n     *\n     * RegisterController keeps the state of all the registers.  An initial\n     * state may be passed in.  The unnamed register '\"' will always be\n     * overridden.\n     */\n    function RegisterController(registers) {\n      this.registers = registers;\n      this.unnamedRegister = registers['\"'] = new Register();\n      registers['.'] = new Register();\n      registers[':'] = new Register();\n      registers['/'] = new Register();\n    }\n    RegisterController.prototype = {\n      pushText: function(registerName, operator, text, linewise, blockwise) {\n        if (linewise && text.charAt(text.length - 1) !== '\\n'){\n          text += '\\n';\n        }\n        // Lowercase and uppercase registers refer to the same register.\n        // Uppercase just means append.\n        var register = this.isValidRegister(registerName) ?\n            this.getRegister(registerName) : null;\n        // if no register/an invalid register was specified, things go to the\n        // default registers\n        if (!register) {\n          switch (operator) {\n            case 'yank':\n              // The 0 register contains the text from the most recent yank.\n              this.registers['0'] = new Register(text, linewise, blockwise);\n              break;\n            case 'delete':\n            case 'change':\n              if (text.indexOf('\\n') == -1) {\n                // Delete less than 1 line. Update the small delete register.\n                this.registers['-'] = new Register(text, linewise);\n              } else {\n                // Shift down the contents of the numbered registers and put the\n                // deleted text into register 1.\n                this.shiftNumericRegisters_();\n                this.registers['1'] = new Register(text, linewise);\n              }\n              break;\n          }\n          // Make sure the unnamed register is set to what just happened\n          this.unnamedRegister.setText(text, linewise, blockwise);\n          return;\n        }\n\n        // If we've gotten to this point, we've actually specified a register\n        var append = isUpperCase(registerName);\n        if (append) {\n          register.pushText(text, linewise);\n        } else {\n          register.setText(text, linewise, blockwise);\n        }\n        // The unnamed register always has the same value as the last used\n        // register.\n        this.unnamedRegister.setText(register.toString(), linewise);\n      },\n      // Gets the register named @name.  If one of @name doesn't already exist,\n      // create it.  If @name is invalid, return the unnamedRegister.\n      getRegister: function(name) {\n        if (!this.isValidRegister(name)) {\n          return this.unnamedRegister;\n        }\n        name = name.toLowerCase();\n        if (!this.registers[name]) {\n          this.registers[name] = new Register();\n        }\n        return this.registers[name];\n      },\n      isValidRegister: function(name) {\n        return name && inArray(name, validRegisters);\n      },\n      shiftNumericRegisters_: function() {\n        for (var i = 9; i >= 2; i--) {\n          this.registers[i] = this.getRegister('' + (i - 1));\n        }\n      }\n    };\n    function HistoryController() {\n        this.historyBuffer = [];\n        this.iterator = 0;\n        this.initialPrefix = null;\n    }\n    HistoryController.prototype = {\n      // the input argument here acts a user entered prefix for a small time\n      // until we start autocompletion in which case it is the autocompleted.\n      nextMatch: function (input, up) {\n        var historyBuffer = this.historyBuffer;\n        var dir = up ? -1 : 1;\n        if (this.initialPrefix === null) this.initialPrefix = input;\n        for (var i = this.iterator + dir; up ? i >= 0 : i < historyBuffer.length; i+= dir) {\n          var element = historyBuffer[i];\n          for (var j = 0; j <= element.length; j++) {\n            if (this.initialPrefix == element.substring(0, j)) {\n              this.iterator = i;\n              return element;\n            }\n          }\n        }\n        // should return the user input in case we reach the end of buffer.\n        if (i >= historyBuffer.length) {\n          this.iterator = historyBuffer.length;\n          return this.initialPrefix;\n        }\n        // return the last autocompleted query or exCommand as it is.\n        if (i < 0 ) return input;\n      },\n      pushInput: function(input) {\n        var index = this.historyBuffer.indexOf(input);\n        if (index > -1) this.historyBuffer.splice(index, 1);\n        if (input.length) this.historyBuffer.push(input);\n      },\n      reset: function() {\n        this.initialPrefix = null;\n        this.iterator = this.historyBuffer.length;\n      }\n    };\n    var commandDispatcher = {\n      matchCommand: function(keys, keyMap, inputState, context) {\n        var matches = commandMatches(keys, keyMap, context, inputState);\n        if (!matches.full && !matches.partial) {\n          return {type: 'none'};\n        } else if (!matches.full && matches.partial) {\n          return {type: 'partial'};\n        }\n\n        var bestMatch;\n        for (var i = 0; i < matches.full.length; i++) {\n          var match = matches.full[i];\n          if (!bestMatch) {\n            bestMatch = match;\n          }\n        }\n        if (bestMatch.keys.slice(-11) == '<character>') {\n          var character = lastChar(keys);\n          if (!character) return {type: 'none'};\n          inputState.selectedCharacter = character;\n        }\n        return {type: 'full', command: bestMatch};\n      },\n      processCommand: function(cm, vim, command) {\n        vim.inputState.repeatOverride = command.repeatOverride;\n        switch (command.type) {\n          case 'motion':\n            this.processMotion(cm, vim, command);\n            break;\n          case 'operator':\n            this.processOperator(cm, vim, command);\n            break;\n          case 'operatorMotion':\n            this.processOperatorMotion(cm, vim, command);\n            break;\n          case 'action':\n            this.processAction(cm, vim, command);\n            break;\n          case 'search':\n            this.processSearch(cm, vim, command);\n            break;\n          case 'ex':\n          case 'keyToEx':\n            this.processEx(cm, vim, command);\n            break;\n          default:\n            break;\n        }\n      },\n      processMotion: function(cm, vim, command) {\n        vim.inputState.motion = command.motion;\n        vim.inputState.motionArgs = copyArgs(command.motionArgs);\n        this.evalInput(cm, vim);\n      },\n      processOperator: function(cm, vim, command) {\n        var inputState = vim.inputState;\n        if (inputState.operator) {\n          if (inputState.operator == command.operator) {\n            // Typing an operator twice like 'dd' makes the operator operate\n            // linewise\n            inputState.motion = 'expandToLine';\n            inputState.motionArgs = { linewise: true };\n            this.evalInput(cm, vim);\n            return;\n          } else {\n            // 2 different operators in a row doesn't make sense.\n            clearInputState(cm);\n          }\n        }\n        inputState.operator = command.operator;\n        inputState.operatorArgs = copyArgs(command.operatorArgs);\n        if (vim.visualMode) {\n          // Operating on a selection in visual mode. We don't need a motion.\n          this.evalInput(cm, vim);\n        }\n      },\n      processOperatorMotion: function(cm, vim, command) {\n        var visualMode = vim.visualMode;\n        var operatorMotionArgs = copyArgs(command.operatorMotionArgs);\n        if (operatorMotionArgs) {\n          // Operator motions may have special behavior in visual mode.\n          if (visualMode && operatorMotionArgs.visualLine) {\n            vim.visualLine = true;\n          }\n        }\n        this.processOperator(cm, vim, command);\n        if (!visualMode) {\n          this.processMotion(cm, vim, command);\n        }\n      },\n      processAction: function(cm, vim, command) {\n        var inputState = vim.inputState;\n        var repeat = inputState.getRepeat();\n        var repeatIsExplicit = !!repeat;\n        var actionArgs = copyArgs(command.actionArgs) || {};\n        if (inputState.selectedCharacter) {\n          actionArgs.selectedCharacter = inputState.selectedCharacter;\n        }\n        // Actions may or may not have motions and operators. Do these first.\n        if (command.operator) {\n          this.processOperator(cm, vim, command);\n        }\n        if (command.motion) {\n          this.processMotion(cm, vim, command);\n        }\n        if (command.motion || command.operator) {\n          this.evalInput(cm, vim);\n        }\n        actionArgs.repeat = repeat || 1;\n        actionArgs.repeatIsExplicit = repeatIsExplicit;\n        actionArgs.registerName = inputState.registerName;\n        clearInputState(cm);\n        vim.lastMotion = null;\n        if (command.isEdit) {\n          this.recordLastEdit(vim, inputState, command);\n        }\n        actions[command.action](cm, actionArgs, vim);\n      },\n      processSearch: function(cm, vim, command) {\n        if (!cm.getSearchCursor) {\n          // Search depends on SearchCursor.\n          return;\n        }\n        var forward = command.searchArgs.forward;\n        var wholeWordOnly = command.searchArgs.wholeWordOnly;\n        getSearchState(cm).setReversed(!forward);\n        var promptPrefix = (forward) ? '/' : '?';\n        var originalQuery = getSearchState(cm).getQuery();\n        var originalScrollPos = cm.getScrollInfo();\n        function handleQuery(query, ignoreCase, smartCase) {\n          vimGlobalState.searchHistoryController.pushInput(query);\n          vimGlobalState.searchHistoryController.reset();\n          try {\n            updateSearchQuery(cm, query, ignoreCase, smartCase);\n          } catch (e) {\n            showConfirm(cm, 'Invalid regex: ' + query);\n            clearInputState(cm);\n            return;\n          }\n          commandDispatcher.processMotion(cm, vim, {\n            type: 'motion',\n            motion: 'findNext',\n            motionArgs: { forward: true, toJumplist: command.searchArgs.toJumplist }\n          });\n        }\n        function onPromptClose(query) {\n          cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n          handleQuery(query, true /** ignoreCase */, true /** smartCase */);\n          var macroModeState = vimGlobalState.macroModeState;\n          if (macroModeState.isRecording) {\n            logSearchQuery(macroModeState, query);\n          }\n        }\n        function onPromptKeyUp(e, query, close) {\n          var keyName = CodeMirror.keyName(e), up, offset;\n          if (keyName == 'Up' || keyName == 'Down') {\n            up = keyName == 'Up' ? true : false;\n            offset = e.target ? e.target.selectionEnd : 0;\n            query = vimGlobalState.searchHistoryController.nextMatch(query, up) || '';\n            close(query);\n            if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n          } else {\n            if ( keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift')\n              vimGlobalState.searchHistoryController.reset();\n          }\n          var parsedQuery;\n          try {\n            parsedQuery = updateSearchQuery(cm, query,\n                true /** ignoreCase */, true /** smartCase */);\n          } catch (e) {\n            // Swallow bad regexes for incremental search.\n          }\n          if (parsedQuery) {\n            cm.scrollIntoView(findNext(cm, !forward, parsedQuery), 30);\n          } else {\n            clearSearchHighlight(cm);\n            cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n          }\n        }\n        function onPromptKeyDown(e, query, close) {\n          var keyName = CodeMirror.keyName(e);\n          if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' ||\n              (keyName == 'Backspace' && query == '')) {\n            vimGlobalState.searchHistoryController.pushInput(query);\n            vimGlobalState.searchHistoryController.reset();\n            updateSearchQuery(cm, originalQuery);\n            clearSearchHighlight(cm);\n            cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n            CodeMirror.e_stop(e);\n            clearInputState(cm);\n            close();\n            cm.focus();\n          } else if (keyName == 'Up' || keyName == 'Down') {\n            CodeMirror.e_stop(e);\n          } else if (keyName == 'Ctrl-U') {\n            // Ctrl-U clears input.\n            CodeMirror.e_stop(e);\n            close('');\n          }\n        }\n        switch (command.searchArgs.querySrc) {\n          case 'prompt':\n            var macroModeState = vimGlobalState.macroModeState;\n            if (macroModeState.isPlaying) {\n              var query = macroModeState.replaySearchQueries.shift();\n              handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n            } else {\n              showPrompt(cm, {\n                  onClose: onPromptClose,\n                  prefix: promptPrefix,\n                  desc: searchPromptDesc,\n                  onKeyUp: onPromptKeyUp,\n                  onKeyDown: onPromptKeyDown\n              });\n            }\n            break;\n          case 'wordUnderCursor':\n            var word = expandWordUnderCursor(cm, false /** inclusive */,\n                true /** forward */, false /** bigWord */,\n                true /** noSymbol */);\n            var isKeyword = true;\n            if (!word) {\n              word = expandWordUnderCursor(cm, false /** inclusive */,\n                  true /** forward */, false /** bigWord */,\n                  false /** noSymbol */);\n              isKeyword = false;\n            }\n            if (!word) {\n              return;\n            }\n            var query = cm.getLine(word.start.line).substring(word.start.ch,\n                word.end.ch);\n            if (isKeyword && wholeWordOnly) {\n                query = '\\\\b' + query + '\\\\b';\n            } else {\n              query = escapeRegex(query);\n            }\n\n            // cachedCursor is used to save the old position of the cursor\n            // when * or # causes vim to seek for the nearest word and shift\n            // the cursor before entering the motion.\n            vimGlobalState.jumpList.cachedCursor = cm.getCursor();\n            cm.setCursor(word.start);\n\n            handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n            break;\n        }\n      },\n      processEx: function(cm, vim, command) {\n        function onPromptClose(input) {\n          // Give the prompt some time to close so that if processCommand shows\n          // an error, the elements don't overlap.\n          vimGlobalState.exCommandHistoryController.pushInput(input);\n          vimGlobalState.exCommandHistoryController.reset();\n          exCommandDispatcher.processCommand(cm, input);\n        }\n        function onPromptKeyDown(e, input, close) {\n          var keyName = CodeMirror.keyName(e), up, offset;\n          if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' ||\n              (keyName == 'Backspace' && input == '')) {\n            vimGlobalState.exCommandHistoryController.pushInput(input);\n            vimGlobalState.exCommandHistoryController.reset();\n            CodeMirror.e_stop(e);\n            clearInputState(cm);\n            close();\n            cm.focus();\n          }\n          if (keyName == 'Up' || keyName == 'Down') {\n            CodeMirror.e_stop(e);\n            up = keyName == 'Up' ? true : false;\n            offset = e.target ? e.target.selectionEnd : 0;\n            input = vimGlobalState.exCommandHistoryController.nextMatch(input, up) || '';\n            close(input);\n            if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n          } else if (keyName == 'Ctrl-U') {\n            // Ctrl-U clears input.\n            CodeMirror.e_stop(e);\n            close('');\n          } else {\n            if ( keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift')\n              vimGlobalState.exCommandHistoryController.reset();\n          }\n        }\n        if (command.type == 'keyToEx') {\n          // Handle user defined Ex to Ex mappings\n          exCommandDispatcher.processCommand(cm, command.exArgs.input);\n        } else {\n          if (vim.visualMode) {\n            showPrompt(cm, { onClose: onPromptClose, prefix: ':', value: '\\'<,\\'>',\n                onKeyDown: onPromptKeyDown, selectValueOnOpen: false});\n          } else {\n            showPrompt(cm, { onClose: onPromptClose, prefix: ':',\n                onKeyDown: onPromptKeyDown});\n          }\n        }\n      },\n      evalInput: function(cm, vim) {\n        // If the motion command is set, execute both the operator and motion.\n        // Otherwise return.\n        var inputState = vim.inputState;\n        var motion = inputState.motion;\n        var motionArgs = inputState.motionArgs || {};\n        var operator = inputState.operator;\n        var operatorArgs = inputState.operatorArgs || {};\n        var registerName = inputState.registerName;\n        var sel = vim.sel;\n        // TODO: Make sure cm and vim selections are identical outside visual mode.\n        var origHead = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.head): cm.getCursor('head'));\n        var origAnchor = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.anchor) : cm.getCursor('anchor'));\n        var oldHead = copyCursor(origHead);\n        var oldAnchor = copyCursor(origAnchor);\n        var newHead, newAnchor;\n        var repeat;\n        if (operator) {\n          this.recordLastEdit(vim, inputState);\n        }\n        if (inputState.repeatOverride !== undefined) {\n          // If repeatOverride is specified, that takes precedence over the\n          // input state's repeat. Used by Ex mode and can be user defined.\n          repeat = inputState.repeatOverride;\n        } else {\n          repeat = inputState.getRepeat();\n        }\n        if (repeat > 0 && motionArgs.explicitRepeat) {\n          motionArgs.repeatIsExplicit = true;\n        } else if (motionArgs.noRepeat ||\n            (!motionArgs.explicitRepeat && repeat === 0)) {\n          repeat = 1;\n          motionArgs.repeatIsExplicit = false;\n        }\n        if (inputState.selectedCharacter) {\n          // If there is a character input, stick it in all of the arg arrays.\n          motionArgs.selectedCharacter = operatorArgs.selectedCharacter =\n              inputState.selectedCharacter;\n        }\n        motionArgs.repeat = repeat;\n        clearInputState(cm);\n        if (motion) {\n          var motionResult = motions[motion](cm, origHead, motionArgs, vim);\n          vim.lastMotion = motions[motion];\n          if (!motionResult) {\n            return;\n          }\n          if (motionArgs.toJumplist) {\n            var jumpList = vimGlobalState.jumpList;\n            // if the current motion is # or *, use cachedCursor\n            var cachedCursor = jumpList.cachedCursor;\n            if (cachedCursor) {\n              recordJumpPosition(cm, cachedCursor, motionResult);\n              delete jumpList.cachedCursor;\n            } else {\n              recordJumpPosition(cm, origHead, motionResult);\n            }\n          }\n          if (motionResult instanceof Array) {\n            newAnchor = motionResult[0];\n            newHead = motionResult[1];\n          } else {\n            newHead = motionResult;\n          }\n          // TODO: Handle null returns from motion commands better.\n          if (!newHead) {\n            newHead = copyCursor(origHead);\n          }\n          if (vim.visualMode) {\n            if (!(vim.visualBlock && newHead.ch === Infinity)) {\n              newHead = clipCursorToContent(cm, newHead, vim.visualBlock);\n            }\n            if (newAnchor) {\n              newAnchor = clipCursorToContent(cm, newAnchor, true);\n            }\n            newAnchor = newAnchor || oldAnchor;\n            sel.anchor = newAnchor;\n            sel.head = newHead;\n            updateCmSelection(cm);\n            updateMark(cm, vim, '<',\n                cursorIsBefore(newAnchor, newHead) ? newAnchor\n                    : newHead);\n            updateMark(cm, vim, '>',\n                cursorIsBefore(newAnchor, newHead) ? newHead\n                    : newAnchor);\n          } else if (!operator) {\n            newHead = clipCursorToContent(cm, newHead);\n            cm.setCursor(newHead.line, newHead.ch);\n          }\n        }\n        if (operator) {\n          if (operatorArgs.lastSel) {\n            // Replaying a visual mode operation\n            newAnchor = oldAnchor;\n            var lastSel = operatorArgs.lastSel;\n            var lineOffset = Math.abs(lastSel.head.line - lastSel.anchor.line);\n            var chOffset = Math.abs(lastSel.head.ch - lastSel.anchor.ch);\n            if (lastSel.visualLine) {\n              // Linewise Visual mode: The same number of lines.\n              newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n            } else if (lastSel.visualBlock) {\n              // Blockwise Visual mode: The same number of lines and columns.\n              newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch + chOffset);\n            } else if (lastSel.head.line == lastSel.anchor.line) {\n              // Normal Visual mode within one line: The same number of characters.\n              newHead = Pos(oldAnchor.line, oldAnchor.ch + chOffset);\n            } else {\n              // Normal Visual mode with several lines: The same number of lines, in the\n              // last line the same number of characters as in the last line the last time.\n              newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n            }\n            vim.visualMode = true;\n            vim.visualLine = lastSel.visualLine;\n            vim.visualBlock = lastSel.visualBlock;\n            sel = vim.sel = {\n              anchor: newAnchor,\n              head: newHead\n            };\n            updateCmSelection(cm);\n          } else if (vim.visualMode) {\n            operatorArgs.lastSel = {\n              anchor: copyCursor(sel.anchor),\n              head: copyCursor(sel.head),\n              visualBlock: vim.visualBlock,\n              visualLine: vim.visualLine\n            };\n          }\n          var curStart, curEnd, linewise, mode;\n          var cmSel;\n          if (vim.visualMode) {\n            // Init visual op\n            curStart = cursorMin(sel.head, sel.anchor);\n            curEnd = cursorMax(sel.head, sel.anchor);\n            linewise = vim.visualLine || operatorArgs.linewise;\n            mode = vim.visualBlock ? 'block' :\n                   linewise ? 'line' :\n                   'char';\n            cmSel = makeCmSelection(cm, {\n              anchor: curStart,\n              head: curEnd\n            }, mode);\n            if (linewise) {\n              var ranges = cmSel.ranges;\n              if (mode == 'block') {\n                // Linewise operators in visual block mode extend to end of line\n                for (var i = 0; i < ranges.length; i++) {\n                  ranges[i].head.ch = lineLength(cm, ranges[i].head.line);\n                }\n              } else if (mode == 'line') {\n                ranges[0].head = Pos(ranges[0].head.line + 1, 0);\n              }\n            }\n          } else {\n            // Init motion op\n            curStart = copyCursor(newAnchor || oldAnchor);\n            curEnd = copyCursor(newHead || oldHead);\n            if (cursorIsBefore(curEnd, curStart)) {\n              var tmp = curStart;\n              curStart = curEnd;\n              curEnd = tmp;\n            }\n            linewise = motionArgs.linewise || operatorArgs.linewise;\n            if (linewise) {\n              // Expand selection to entire line.\n              expandSelectionToLine(cm, curStart, curEnd);\n            } else if (motionArgs.forward) {\n              // Clip to trailing newlines only if the motion goes forward.\n              clipToLine(cm, curStart, curEnd);\n            }\n            mode = 'char';\n            var exclusive = !motionArgs.inclusive || linewise;\n            cmSel = makeCmSelection(cm, {\n              anchor: curStart,\n              head: curEnd\n            }, mode, exclusive);\n          }\n          cm.setSelections(cmSel.ranges, cmSel.primary);\n          vim.lastMotion = null;\n          operatorArgs.repeat = repeat; // For indent in visual mode.\n          operatorArgs.registerName = registerName;\n          // Keep track of linewise as it affects how paste and change behave.\n          operatorArgs.linewise = linewise;\n          var operatorMoveTo = operators[operator](\n            cm, operatorArgs, cmSel.ranges, oldAnchor, newHead);\n          if (vim.visualMode) {\n            exitVisualMode(cm, operatorMoveTo != null);\n          }\n          if (operatorMoveTo) {\n            cm.setCursor(operatorMoveTo);\n          }\n        }\n      },\n      recordLastEdit: function(vim, inputState, actionCommand) {\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isPlaying) { return; }\n        vim.lastEditInputState = inputState;\n        vim.lastEditActionCommand = actionCommand;\n        macroModeState.lastInsertModeChanges.changes = [];\n        macroModeState.lastInsertModeChanges.expectCursorActivityForChange = false;\n      }\n    };\n\n    /**\n     * typedef {Object{line:number,ch:number}} Cursor An object containing the\n     *     position of the cursor.\n     */\n    // All of the functions below return Cursor objects.\n    var motions = {\n      moveToTopLine: function(cm, _head, motionArgs) {\n        var line = getUserVisibleLines(cm).top + motionArgs.repeat -1;\n        return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      moveToMiddleLine: function(cm) {\n        var range = getUserVisibleLines(cm);\n        var line = Math.floor((range.top + range.bottom) * 0.5);\n        return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      moveToBottomLine: function(cm, _head, motionArgs) {\n        var line = getUserVisibleLines(cm).bottom - motionArgs.repeat +1;\n        return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      expandToLine: function(_cm, head, motionArgs) {\n        // Expands forward to end of line, and then to next line if repeat is\n        // >1. Does not handle backward motion!\n        var cur = head;\n        return Pos(cur.line + motionArgs.repeat - 1, Infinity);\n      },\n      findNext: function(cm, _head, motionArgs) {\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n        if (!query) {\n          return;\n        }\n        var prev = !motionArgs.forward;\n        // If search is initiated with ? instead of /, negate direction.\n        prev = (state.isReversed()) ? !prev : prev;\n        highlightSearchMatches(cm, query);\n        return findNext(cm, prev/** prev */, query, motionArgs.repeat);\n      },\n      goToMark: function(cm, _head, motionArgs, vim) {\n        var pos = getMarkPos(cm, vim, motionArgs.selectedCharacter);\n        if (pos) {\n          return motionArgs.linewise ? { line: pos.line, ch: findFirstNonWhiteSpaceCharacter(cm.getLine(pos.line)) } : pos;\n        }\n        return null;\n      },\n      moveToOtherHighlightedEnd: function(cm, _head, motionArgs, vim) {\n        if (vim.visualBlock && motionArgs.sameLine) {\n          var sel = vim.sel;\n          return [\n            clipCursorToContent(cm, Pos(sel.anchor.line, sel.head.ch)),\n            clipCursorToContent(cm, Pos(sel.head.line, sel.anchor.ch))\n          ];\n        } else {\n          return ([vim.sel.head, vim.sel.anchor]);\n        }\n      },\n      jumpToMark: function(cm, head, motionArgs, vim) {\n        var best = head;\n        for (var i = 0; i < motionArgs.repeat; i++) {\n          var cursor = best;\n          for (var key in vim.marks) {\n            if (!isLowerCase(key)) {\n              continue;\n            }\n            var mark = vim.marks[key].find();\n            var isWrongDirection = (motionArgs.forward) ?\n              cursorIsBefore(mark, cursor) : cursorIsBefore(cursor, mark);\n\n            if (isWrongDirection) {\n              continue;\n            }\n            if (motionArgs.linewise && (mark.line == cursor.line)) {\n              continue;\n            }\n\n            var equal = cursorEqual(cursor, best);\n            var between = (motionArgs.forward) ?\n              cursorIsBetween(cursor, mark, best) :\n              cursorIsBetween(best, mark, cursor);\n\n            if (equal || between) {\n              best = mark;\n            }\n          }\n        }\n\n        if (motionArgs.linewise) {\n          // Vim places the cursor on the first non-whitespace character of\n          // the line if there is one, else it places the cursor at the end\n          // of the line, regardless of whether a mark was found.\n          best = Pos(best.line, findFirstNonWhiteSpaceCharacter(cm.getLine(best.line)));\n        }\n        return best;\n      },\n      moveByCharacters: function(_cm, head, motionArgs) {\n        var cur = head;\n        var repeat = motionArgs.repeat;\n        var ch = motionArgs.forward ? cur.ch + repeat : cur.ch - repeat;\n        return Pos(cur.line, ch);\n      },\n      moveByLines: function(cm, head, motionArgs, vim) {\n        var cur = head;\n        var endCh = cur.ch;\n        // Depending what our last motion was, we may want to do different\n        // things. If our last motion was moving vertically, we want to\n        // preserve the HPos from our last horizontal move.  If our last motion\n        // was going to the end of a line, moving vertically we should go to\n        // the end of the line, etc.\n        switch (vim.lastMotion) {\n          case this.moveByLines:\n          case this.moveByDisplayLines:\n          case this.moveByScroll:\n          case this.moveToColumn:\n          case this.moveToEol:\n            endCh = vim.lastHPos;\n            break;\n          default:\n            vim.lastHPos = endCh;\n        }\n        var repeat = motionArgs.repeat+(motionArgs.repeatOffset||0);\n        var line = motionArgs.forward ? cur.line + repeat : cur.line - repeat;\n        var first = cm.firstLine();\n        var last = cm.lastLine();\n        // Vim go to line begin or line end when cursor at first/last line and\n        // move to previous/next line is triggered.\n        if (line < first && cur.line == first){\n          return this.moveToStartOfLine(cm, head, motionArgs, vim);\n        }else if (line > last && cur.line == last){\n            return this.moveToEol(cm, head, motionArgs, vim);\n        }\n        if (motionArgs.toFirstChar){\n          endCh=findFirstNonWhiteSpaceCharacter(cm.getLine(line));\n          vim.lastHPos = endCh;\n        }\n        vim.lastHSPos = cm.charCoords(Pos(line, endCh),'div').left;\n        return Pos(line, endCh);\n      },\n      moveByDisplayLines: function(cm, head, motionArgs, vim) {\n        var cur = head;\n        switch (vim.lastMotion) {\n          case this.moveByDisplayLines:\n          case this.moveByScroll:\n          case this.moveByLines:\n          case this.moveToColumn:\n          case this.moveToEol:\n            break;\n          default:\n            vim.lastHSPos = cm.charCoords(cur,'div').left;\n        }\n        var repeat = motionArgs.repeat;\n        var res=cm.findPosV(cur,(motionArgs.forward ? repeat : -repeat),'line',vim.lastHSPos);\n        if (res.hitSide) {\n          if (motionArgs.forward) {\n            var lastCharCoords = cm.charCoords(res, 'div');\n            var goalCoords = { top: lastCharCoords.top + 8, left: vim.lastHSPos };\n            var res = cm.coordsChar(goalCoords, 'div');\n          } else {\n            var resCoords = cm.charCoords(Pos(cm.firstLine(), 0), 'div');\n            resCoords.left = vim.lastHSPos;\n            res = cm.coordsChar(resCoords, 'div');\n          }\n        }\n        vim.lastHPos = res.ch;\n        return res;\n      },\n      moveByPage: function(cm, head, motionArgs) {\n        // CodeMirror only exposes functions that move the cursor page down, so\n        // doing this bad hack to move the cursor and move it back. evalInput\n        // will move the cursor to where it should be in the end.\n        var curStart = head;\n        var repeat = motionArgs.repeat;\n        return cm.findPosV(curStart, (motionArgs.forward ? repeat : -repeat), 'page');\n      },\n      moveByParagraph: function(cm, head, motionArgs) {\n        var dir = motionArgs.forward ? 1 : -1;\n        return findParagraph(cm, head, motionArgs.repeat, dir);\n      },\n      moveBySentence: function(cm, head, motionArgs) {\n        var dir = motionArgs.forward ? 1 : -1;\n        return findSentence(cm, head, motionArgs.repeat, dir);\n      },\n      moveByScroll: function(cm, head, motionArgs, vim) {\n        var scrollbox = cm.getScrollInfo();\n        var curEnd = null;\n        var repeat = motionArgs.repeat;\n        if (!repeat) {\n          repeat = scrollbox.clientHeight / (2 * cm.defaultTextHeight());\n        }\n        var orig = cm.charCoords(head, 'local');\n        motionArgs.repeat = repeat;\n        var curEnd = motions.moveByDisplayLines(cm, head, motionArgs, vim);\n        if (!curEnd) {\n          return null;\n        }\n        var dest = cm.charCoords(curEnd, 'local');\n        cm.scrollTo(null, scrollbox.top + dest.top - orig.top);\n        return curEnd;\n      },\n      moveByWords: function(cm, head, motionArgs) {\n        return moveToWord(cm, head, motionArgs.repeat, !!motionArgs.forward,\n            !!motionArgs.wordEnd, !!motionArgs.bigWord);\n      },\n      moveTillCharacter: function(cm, _head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        var curEnd = moveToCharacter(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter);\n        var increment = motionArgs.forward ? -1 : 1;\n        recordLastCharacterSearch(increment, motionArgs);\n        if (!curEnd) return null;\n        curEnd.ch += increment;\n        return curEnd;\n      },\n      moveToCharacter: function(cm, head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        recordLastCharacterSearch(0, motionArgs);\n        return moveToCharacter(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter) || head;\n      },\n      moveToSymbol: function(cm, head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        return findSymbol(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter) || head;\n      },\n      moveToColumn: function(cm, head, motionArgs, vim) {\n        var repeat = motionArgs.repeat;\n        // repeat is equivalent to which column we want to move to!\n        vim.lastHPos = repeat - 1;\n        vim.lastHSPos = cm.charCoords(head,'div').left;\n        return moveToColumn(cm, repeat);\n      },\n      moveToEol: function(cm, head, motionArgs, vim) {\n        var cur = head;\n        vim.lastHPos = Infinity;\n        var retval= Pos(cur.line + motionArgs.repeat - 1, Infinity);\n        var end=cm.clipPos(retval);\n        end.ch--;\n        vim.lastHSPos = cm.charCoords(end,'div').left;\n        return retval;\n      },\n      moveToFirstNonWhiteSpaceCharacter: function(cm, head) {\n        // Go to the start of the line where the text begins, or the end for\n        // whitespace-only lines\n        var cursor = head;\n        return Pos(cursor.line,\n                   findFirstNonWhiteSpaceCharacter(cm.getLine(cursor.line)));\n      },\n      moveToMatchedSymbol: function(cm, head) {\n        var cursor = head;\n        var line = cursor.line;\n        var ch = cursor.ch;\n        var lineText = cm.getLine(line);\n        var symbol;\n        for (; ch < lineText.length; ch++) {\n          symbol = lineText.charAt(ch);\n          if (symbol && isMatchableSymbol(symbol)) {\n            var style = cm.getTokenTypeAt(Pos(line, ch + 1));\n            if (style !== \"string\" && style !== \"comment\") {\n              break;\n            }\n          }\n        }\n        if (ch < lineText.length) {\n          var matched = cm.findMatchingBracket(Pos(line, ch));\n          return matched.to;\n        } else {\n          return cursor;\n        }\n      },\n      moveToStartOfLine: function(_cm, head) {\n        return Pos(head.line, 0);\n      },\n      moveToLineOrEdgeOfDocument: function(cm, _head, motionArgs) {\n        var lineNum = motionArgs.forward ? cm.lastLine() : cm.firstLine();\n        if (motionArgs.repeatIsExplicit) {\n          lineNum = motionArgs.repeat - cm.getOption('firstLineNumber');\n        }\n        return Pos(lineNum,\n                   findFirstNonWhiteSpaceCharacter(cm.getLine(lineNum)));\n      },\n      textObjectManipulation: function(cm, head, motionArgs, vim) {\n        // TODO: lots of possible exceptions that can be thrown here. Try da(\n        //     outside of a () block.\n\n        // TODO: adding <> >< to this map doesn't work, presumably because\n        // they're operators\n        var mirroredPairs = {'(': ')', ')': '(',\n                             '{': '}', '}': '{',\n                             '[': ']', ']': '['};\n        var selfPaired = {'\\'': true, '\"': true};\n\n        var character = motionArgs.selectedCharacter;\n        // 'b' refers to  '()' block.\n        // 'B' refers to  '{}' block.\n        if (character == 'b') {\n          character = '(';\n        } else if (character == 'B') {\n          character = '{';\n        }\n\n        // Inclusive is the difference between a and i\n        // TODO: Instead of using the additional text object map to perform text\n        //     object operations, merge the map into the defaultKeyMap and use\n        //     motionArgs to define behavior. Define separate entries for 'aw',\n        //     'iw', 'a[', 'i[', etc.\n        var inclusive = !motionArgs.textObjectInner;\n\n        var tmp;\n        if (mirroredPairs[character]) {\n          tmp = selectCompanionObject(cm, head, character, inclusive);\n        } else if (selfPaired[character]) {\n          tmp = findBeginningAndEnd(cm, head, character, inclusive);\n        } else if (character === 'W') {\n          tmp = expandWordUnderCursor(cm, inclusive, true /** forward */,\n                                                     true /** bigWord */);\n        } else if (character === 'w') {\n          tmp = expandWordUnderCursor(cm, inclusive, true /** forward */,\n                                                     false /** bigWord */);\n        } else if (character === 'p') {\n          tmp = findParagraph(cm, head, motionArgs.repeat, 0, inclusive);\n          motionArgs.linewise = true;\n          if (vim.visualMode) {\n            if (!vim.visualLine) { vim.visualLine = true; }\n          } else {\n            var operatorArgs = vim.inputState.operatorArgs;\n            if (operatorArgs) { operatorArgs.linewise = true; }\n            tmp.end.line--;\n          }\n        } else {\n          // No text object defined for this, don't move.\n          return null;\n        }\n\n        if (!cm.state.vim.visualMode) {\n          return [tmp.start, tmp.end];\n        } else {\n          return expandSelection(cm, tmp.start, tmp.end);\n        }\n      },\n\n      repeatLastCharacterSearch: function(cm, head, motionArgs) {\n        var lastSearch = vimGlobalState.lastCharacterSearch;\n        var repeat = motionArgs.repeat;\n        var forward = motionArgs.forward === lastSearch.forward;\n        var increment = (lastSearch.increment ? 1 : 0) * (forward ? -1 : 1);\n        cm.moveH(-increment, 'char');\n        motionArgs.inclusive = forward ? true : false;\n        var curEnd = moveToCharacter(cm, repeat, forward, lastSearch.selectedCharacter);\n        if (!curEnd) {\n          cm.moveH(increment, 'char');\n          return head;\n        }\n        curEnd.ch += increment;\n        return curEnd;\n      }\n    };\n\n    function defineMotion(name, fn) {\n      motions[name] = fn;\n    }\n\n    function fillArray(val, times) {\n      var arr = [];\n      for (var i = 0; i < times; i++) {\n        arr.push(val);\n      }\n      return arr;\n    }\n    /**\n     * An operator acts on a text selection. It receives the list of selections\n     * as input. The corresponding CodeMirror selection is guaranteed to\n    * match the input selection.\n     */\n    var operators = {\n      change: function(cm, args, ranges) {\n        var finalHead, text;\n        var vim = cm.state.vim;\n        vimGlobalState.macroModeState.lastInsertModeChanges.inVisualBlock = vim.visualBlock;\n        if (!vim.visualMode) {\n          var anchor = ranges[0].anchor,\n              head = ranges[0].head;\n          text = cm.getRange(anchor, head);\n          var lastState = vim.lastEditInputState || {};\n          if (lastState.motion == \"moveByWords\" && !isWhiteSpaceString(text)) {\n            // Exclude trailing whitespace if the range is not all whitespace.\n            var match = (/\\s+$/).exec(text);\n            if (match && lastState.motionArgs && lastState.motionArgs.forward) {\n              head = offsetCursor(head, 0, - match[0].length);\n              text = text.slice(0, - match[0].length);\n            }\n          }\n          var prevLineEnd = new Pos(anchor.line - 1, Number.MAX_VALUE);\n          var wasLastLine = cm.firstLine() == cm.lastLine();\n          if (head.line > cm.lastLine() && args.linewise && !wasLastLine) {\n            cm.replaceRange('', prevLineEnd, head);\n          } else {\n            cm.replaceRange('', anchor, head);\n          }\n          if (args.linewise) {\n            // Push the next line back down, if there is a next line.\n            if (!wasLastLine) {\n              cm.setCursor(prevLineEnd);\n              CodeMirror.commands.newlineAndIndent(cm);\n            }\n            // make sure cursor ends up at the end of the line.\n            anchor.ch = Number.MAX_VALUE;\n          }\n          finalHead = anchor;\n        } else {\n          text = cm.getSelection();\n          var replacement = fillArray('', ranges.length);\n          cm.replaceSelections(replacement);\n          finalHead = cursorMin(ranges[0].head, ranges[0].anchor);\n        }\n        vimGlobalState.registerController.pushText(\n            args.registerName, 'change', text,\n            args.linewise, ranges.length > 1);\n        actions.enterInsertMode(cm, {head: finalHead}, cm.state.vim);\n      },\n      // delete is a javascript keyword.\n      'delete': function(cm, args, ranges) {\n        var finalHead, text;\n        var vim = cm.state.vim;\n        if (!vim.visualBlock) {\n          var anchor = ranges[0].anchor,\n              head = ranges[0].head;\n          if (args.linewise &&\n              head.line != cm.firstLine() &&\n              anchor.line == cm.lastLine() &&\n              anchor.line == head.line - 1) {\n            // Special case for dd on last line (and first line).\n            if (anchor.line == cm.firstLine()) {\n              anchor.ch = 0;\n            } else {\n              anchor = Pos(anchor.line - 1, lineLength(cm, anchor.line - 1));\n            }\n          }\n          text = cm.getRange(anchor, head);\n          cm.replaceRange('', anchor, head);\n          finalHead = anchor;\n          if (args.linewise) {\n            finalHead = motions.moveToFirstNonWhiteSpaceCharacter(cm, anchor);\n          }\n        } else {\n          text = cm.getSelection();\n          var replacement = fillArray('', ranges.length);\n          cm.replaceSelections(replacement);\n          finalHead = ranges[0].anchor;\n        }\n        vimGlobalState.registerController.pushText(\n            args.registerName, 'delete', text,\n            args.linewise, vim.visualBlock);\n        var includeLineBreak = vim.insertMode\n        return clipCursorToContent(cm, finalHead, includeLineBreak);\n      },\n      indent: function(cm, args, ranges) {\n        var vim = cm.state.vim;\n        var startLine = ranges[0].anchor.line;\n        var endLine = vim.visualBlock ?\n          ranges[ranges.length - 1].anchor.line :\n          ranges[0].head.line;\n        // In visual mode, n> shifts the selection right n times, instead of\n        // shifting n lines right once.\n        var repeat = (vim.visualMode) ? args.repeat : 1;\n        if (args.linewise) {\n          // The only way to delete a newline is to delete until the start of\n          // the next line, so in linewise mode evalInput will include the next\n          // line. We don't want this in indent, so we go back a line.\n          endLine--;\n        }\n        for (var i = startLine; i <= endLine; i++) {\n          for (var j = 0; j < repeat; j++) {\n            cm.indentLine(i, args.indentRight);\n          }\n        }\n        return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n      },\n      changeCase: function(cm, args, ranges, oldAnchor, newHead) {\n        var selections = cm.getSelections();\n        var swapped = [];\n        var toLower = args.toLower;\n        for (var j = 0; j < selections.length; j++) {\n          var toSwap = selections[j];\n          var text = '';\n          if (toLower === true) {\n            text = toSwap.toLowerCase();\n          } else if (toLower === false) {\n            text = toSwap.toUpperCase();\n          } else {\n            for (var i = 0; i < toSwap.length; i++) {\n              var character = toSwap.charAt(i);\n              text += isUpperCase(character) ? character.toLowerCase() :\n                  character.toUpperCase();\n            }\n          }\n          swapped.push(text);\n        }\n        cm.replaceSelections(swapped);\n        if (args.shouldMoveCursor){\n          return newHead;\n        } else if (!cm.state.vim.visualMode && args.linewise && ranges[0].anchor.line + 1 == ranges[0].head.line) {\n          return motions.moveToFirstNonWhiteSpaceCharacter(cm, oldAnchor);\n        } else if (args.linewise){\n          return oldAnchor;\n        } else {\n          return cursorMin(ranges[0].anchor, ranges[0].head);\n        }\n      },\n      yank: function(cm, args, ranges, oldAnchor) {\n        var vim = cm.state.vim;\n        var text = cm.getSelection();\n        var endPos = vim.visualMode\n          ? cursorMin(vim.sel.anchor, vim.sel.head, ranges[0].head, ranges[0].anchor)\n          : oldAnchor;\n        vimGlobalState.registerController.pushText(\n            args.registerName, 'yank',\n            text, args.linewise, vim.visualBlock);\n        return endPos;\n      }\n    };\n\n    function defineOperator(name, fn) {\n      operators[name] = fn;\n    }\n\n    var actions = {\n      jumpListWalk: function(cm, actionArgs, vim) {\n        if (vim.visualMode) {\n          return;\n        }\n        var repeat = actionArgs.repeat;\n        var forward = actionArgs.forward;\n        var jumpList = vimGlobalState.jumpList;\n\n        var mark = jumpList.move(cm, forward ? repeat : -repeat);\n        var markPos = mark ? mark.find() : undefined;\n        markPos = markPos ? markPos : cm.getCursor();\n        cm.setCursor(markPos);\n      },\n      scroll: function(cm, actionArgs, vim) {\n        if (vim.visualMode) {\n          return;\n        }\n        var repeat = actionArgs.repeat || 1;\n        var lineHeight = cm.defaultTextHeight();\n        var top = cm.getScrollInfo().top;\n        var delta = lineHeight * repeat;\n        var newPos = actionArgs.forward ? top + delta : top - delta;\n        var cursor = copyCursor(cm.getCursor());\n        var cursorCoords = cm.charCoords(cursor, 'local');\n        if (actionArgs.forward) {\n          if (newPos > cursorCoords.top) {\n             cursor.line += (newPos - cursorCoords.top) / lineHeight;\n             cursor.line = Math.ceil(cursor.line);\n             cm.setCursor(cursor);\n             cursorCoords = cm.charCoords(cursor, 'local');\n             cm.scrollTo(null, cursorCoords.top);\n          } else {\n             // Cursor stays within bounds.  Just reposition the scroll window.\n             cm.scrollTo(null, newPos);\n          }\n        } else {\n          var newBottom = newPos + cm.getScrollInfo().clientHeight;\n          if (newBottom < cursorCoords.bottom) {\n             cursor.line -= (cursorCoords.bottom - newBottom) / lineHeight;\n             cursor.line = Math.floor(cursor.line);\n             cm.setCursor(cursor);\n             cursorCoords = cm.charCoords(cursor, 'local');\n             cm.scrollTo(\n                 null, cursorCoords.bottom - cm.getScrollInfo().clientHeight);\n          } else {\n             // Cursor stays within bounds.  Just reposition the scroll window.\n             cm.scrollTo(null, newPos);\n          }\n        }\n      },\n      scrollToCursor: function(cm, actionArgs) {\n        var lineNum = cm.getCursor().line;\n        var charCoords = cm.charCoords(Pos(lineNum, 0), 'local');\n        var height = cm.getScrollInfo().clientHeight;\n        var y = charCoords.top;\n        var lineHeight = charCoords.bottom - y;\n        switch (actionArgs.position) {\n          case 'center': y = y - (height / 2) + lineHeight;\n            break;\n          case 'bottom': y = y - height + lineHeight;\n            break;\n        }\n        cm.scrollTo(null, y);\n      },\n      replayMacro: function(cm, actionArgs, vim) {\n        var registerName = actionArgs.selectedCharacter;\n        var repeat = actionArgs.repeat;\n        var macroModeState = vimGlobalState.macroModeState;\n        if (registerName == '@') {\n          registerName = macroModeState.latestRegister;\n        }\n        while(repeat--){\n          executeMacroRegister(cm, vim, macroModeState, registerName);\n        }\n      },\n      enterMacroRecordMode: function(cm, actionArgs) {\n        var macroModeState = vimGlobalState.macroModeState;\n        var registerName = actionArgs.selectedCharacter;\n        if (vimGlobalState.registerController.isValidRegister(registerName)) {\n          macroModeState.enterMacroRecordMode(cm, registerName);\n        }\n      },\n      toggleOverwrite: function(cm) {\n        if (!cm.state.overwrite) {\n          cm.toggleOverwrite(true);\n          cm.setOption('keyMap', 'vim-replace');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"replace\"});\n        } else {\n          cm.toggleOverwrite(false);\n          cm.setOption('keyMap', 'vim-insert');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"insert\"});\n        }\n      },\n      enterInsertMode: function(cm, actionArgs, vim) {\n        if (cm.getOption('readOnly')) { return; }\n        vim.insertMode = true;\n        vim.insertModeRepeat = actionArgs && actionArgs.repeat || 1;\n        var insertAt = (actionArgs) ? actionArgs.insertAt : null;\n        var sel = vim.sel;\n        var head = actionArgs.head || cm.getCursor('head');\n        var height = cm.listSelections().length;\n        if (insertAt == 'eol') {\n          head = Pos(head.line, lineLength(cm, head.line));\n        } else if (insertAt == 'charAfter') {\n          head = offsetCursor(head, 0, 1);\n        } else if (insertAt == 'firstNonBlank') {\n          head = motions.moveToFirstNonWhiteSpaceCharacter(cm, head);\n        } else if (insertAt == 'startOfSelectedArea') {\n          if (!vim.visualBlock) {\n            if (sel.head.line < sel.anchor.line) {\n              head = sel.head;\n            } else {\n              head = Pos(sel.anchor.line, 0);\n            }\n          } else {\n            head = Pos(\n                Math.min(sel.head.line, sel.anchor.line),\n                Math.min(sel.head.ch, sel.anchor.ch));\n            height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n          }\n        } else if (insertAt == 'endOfSelectedArea') {\n          if (!vim.visualBlock) {\n            if (sel.head.line >= sel.anchor.line) {\n              head = offsetCursor(sel.head, 0, 1);\n            } else {\n              head = Pos(sel.anchor.line, 0);\n            }\n          } else {\n            head = Pos(\n                Math.min(sel.head.line, sel.anchor.line),\n                Math.max(sel.head.ch + 1, sel.anchor.ch));\n            height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n          }\n        } else if (insertAt == 'inplace') {\n          if (vim.visualMode){\n            return;\n          }\n        }\n        cm.setOption('disableInput', false);\n        if (actionArgs && actionArgs.replace) {\n          // Handle Replace-mode as a special case of insert mode.\n          cm.toggleOverwrite(true);\n          cm.setOption('keyMap', 'vim-replace');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"replace\"});\n        } else {\n          cm.toggleOverwrite(false);\n          cm.setOption('keyMap', 'vim-insert');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"insert\"});\n        }\n        if (!vimGlobalState.macroModeState.isPlaying) {\n          // Only record if not replaying.\n          cm.on('change', onChange);\n          CodeMirror.on(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n        }\n        if (vim.visualMode) {\n          exitVisualMode(cm);\n        }\n        selectForInsert(cm, head, height);\n      },\n      toggleVisualMode: function(cm, actionArgs, vim) {\n        var repeat = actionArgs.repeat;\n        var anchor = cm.getCursor();\n        var head;\n        // TODO: The repeat should actually select number of characters/lines\n        //     equal to the repeat times the size of the previous visual\n        //     operation.\n        if (!vim.visualMode) {\n          // Entering visual mode\n          vim.visualMode = true;\n          vim.visualLine = !!actionArgs.linewise;\n          vim.visualBlock = !!actionArgs.blockwise;\n          head = clipCursorToContent(\n              cm, Pos(anchor.line, anchor.ch + repeat - 1),\n              true /** includeLineBreak */);\n          vim.sel = {\n            anchor: anchor,\n            head: head\n          };\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"});\n          updateCmSelection(cm);\n          updateMark(cm, vim, '<', cursorMin(anchor, head));\n          updateMark(cm, vim, '>', cursorMax(anchor, head));\n        } else if (vim.visualLine ^ actionArgs.linewise ||\n            vim.visualBlock ^ actionArgs.blockwise) {\n          // Toggling between modes\n          vim.visualLine = !!actionArgs.linewise;\n          vim.visualBlock = !!actionArgs.blockwise;\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"});\n          updateCmSelection(cm);\n        } else {\n          exitVisualMode(cm);\n        }\n      },\n      reselectLastSelection: function(cm, _actionArgs, vim) {\n        var lastSelection = vim.lastSelection;\n        if (vim.visualMode) {\n          updateLastSelection(cm, vim);\n        }\n        if (lastSelection) {\n          var anchor = lastSelection.anchorMark.find();\n          var head = lastSelection.headMark.find();\n          if (!anchor || !head) {\n            // If the marks have been destroyed due to edits, do nothing.\n            return;\n          }\n          vim.sel = {\n            anchor: anchor,\n            head: head\n          };\n          vim.visualMode = true;\n          vim.visualLine = lastSelection.visualLine;\n          vim.visualBlock = lastSelection.visualBlock;\n          updateCmSelection(cm);\n          updateMark(cm, vim, '<', cursorMin(anchor, head));\n          updateMark(cm, vim, '>', cursorMax(anchor, head));\n          CodeMirror.signal(cm, 'vim-mode-change', {\n            mode: 'visual',\n            subMode: vim.visualLine ? 'linewise' :\n                     vim.visualBlock ? 'blockwise' : ''});\n        }\n      },\n      joinLines: function(cm, actionArgs, vim) {\n        var curStart, curEnd;\n        if (vim.visualMode) {\n          curStart = cm.getCursor('anchor');\n          curEnd = cm.getCursor('head');\n          if (cursorIsBefore(curEnd, curStart)) {\n            var tmp = curEnd;\n            curEnd = curStart;\n            curStart = tmp;\n          }\n          curEnd.ch = lineLength(cm, curEnd.line) - 1;\n        } else {\n          // Repeat is the number of lines to join. Minimum 2 lines.\n          var repeat = Math.max(actionArgs.repeat, 2);\n          curStart = cm.getCursor();\n          curEnd = clipCursorToContent(cm, Pos(curStart.line + repeat - 1,\n                                               Infinity));\n        }\n        var finalCh = 0;\n        for (var i = curStart.line; i < curEnd.line; i++) {\n          finalCh = lineLength(cm, curStart.line);\n          var tmp = Pos(curStart.line + 1,\n                        lineLength(cm, curStart.line + 1));\n          var text = cm.getRange(curStart, tmp);\n          text = text.replace(/\\n\\s*/g, ' ');\n          cm.replaceRange(text, curStart, tmp);\n        }\n        var curFinalPos = Pos(curStart.line, finalCh);\n        if (vim.visualMode) {\n          exitVisualMode(cm, false);\n        }\n        cm.setCursor(curFinalPos);\n      },\n      newLineAndEnterInsertMode: function(cm, actionArgs, vim) {\n        vim.insertMode = true;\n        var insertAt = copyCursor(cm.getCursor());\n        if (insertAt.line === cm.firstLine() && !actionArgs.after) {\n          // Special case for inserting newline before start of document.\n          cm.replaceRange('\\n', Pos(cm.firstLine(), 0));\n          cm.setCursor(cm.firstLine(), 0);\n        } else {\n          insertAt.line = (actionArgs.after) ? insertAt.line :\n              insertAt.line - 1;\n          insertAt.ch = lineLength(cm, insertAt.line);\n          cm.setCursor(insertAt);\n          var newlineFn = CodeMirror.commands.newlineAndIndentContinueComment ||\n              CodeMirror.commands.newlineAndIndent;\n          newlineFn(cm);\n        }\n        this.enterInsertMode(cm, { repeat: actionArgs.repeat }, vim);\n      },\n      paste: function(cm, actionArgs, vim) {\n        var cur = copyCursor(cm.getCursor());\n        var register = vimGlobalState.registerController.getRegister(\n            actionArgs.registerName);\n        var text = register.toString();\n        if (!text) {\n          return;\n        }\n        if (actionArgs.matchIndent) {\n          var tabSize = cm.getOption(\"tabSize\");\n          // length that considers tabs and tabSize\n          var whitespaceLength = function(str) {\n            var tabs = (str.split(\"\\t\").length - 1);\n            var spaces = (str.split(\" \").length - 1);\n            return tabs * tabSize + spaces * 1;\n          };\n          var currentLine = cm.getLine(cm.getCursor().line);\n          var indent = whitespaceLength(currentLine.match(/^\\s*/)[0]);\n          // chomp last newline b/c don't want it to match /^\\s*/gm\n          var chompedText = text.replace(/\\n$/, '');\n          var wasChomped = text !== chompedText;\n          var firstIndent = whitespaceLength(text.match(/^\\s*/)[0]);\n          var text = chompedText.replace(/^\\s*/gm, function(wspace) {\n            var newIndent = indent + (whitespaceLength(wspace) - firstIndent);\n            if (newIndent < 0) {\n              return \"\";\n            }\n            else if (cm.getOption(\"indentWithTabs\")) {\n              var quotient = Math.floor(newIndent / tabSize);\n              return Array(quotient + 1).join('\\t');\n            }\n            else {\n              return Array(newIndent + 1).join(' ');\n            }\n          });\n          text += wasChomped ? \"\\n\" : \"\";\n        }\n        if (actionArgs.repeat > 1) {\n          var text = Array(actionArgs.repeat + 1).join(text);\n        }\n        var linewise = register.linewise;\n        var blockwise = register.blockwise;\n        if (linewise) {\n          if(vim.visualMode) {\n            text = vim.visualLine ? text.slice(0, -1) : '\\n' + text.slice(0, text.length - 1) + '\\n';\n          } else if (actionArgs.after) {\n            // Move the newline at the end to the start instead, and paste just\n            // before the newline character of the line we are on right now.\n            text = '\\n' + text.slice(0, text.length - 1);\n            cur.ch = lineLength(cm, cur.line);\n          } else {\n            cur.ch = 0;\n          }\n        } else {\n          if (blockwise) {\n            text = text.split('\\n');\n            for (var i = 0; i < text.length; i++) {\n              text[i] = (text[i] == '') ? ' ' : text[i];\n            }\n          }\n          cur.ch += actionArgs.after ? 1 : 0;\n        }\n        var curPosFinal;\n        var idx;\n        if (vim.visualMode) {\n          //  save the pasted text for reselection if the need arises\n          vim.lastPastedText = text;\n          var lastSelectionCurEnd;\n          var selectedArea = getSelectedAreaRange(cm, vim);\n          var selectionStart = selectedArea[0];\n          var selectionEnd = selectedArea[1];\n          var selectedText = cm.getSelection();\n          var selections = cm.listSelections();\n          var emptyStrings = new Array(selections.length).join('1').split('1');\n          // save the curEnd marker before it get cleared due to cm.replaceRange.\n          if (vim.lastSelection) {\n            lastSelectionCurEnd = vim.lastSelection.headMark.find();\n          }\n          // push the previously selected text to unnamed register\n          vimGlobalState.registerController.unnamedRegister.setText(selectedText);\n          if (blockwise) {\n            // first delete the selected text\n            cm.replaceSelections(emptyStrings);\n            // Set new selections as per the block length of the yanked text\n            selectionEnd = Pos(selectionStart.line + text.length-1, selectionStart.ch);\n            cm.setCursor(selectionStart);\n            selectBlock(cm, selectionEnd);\n            cm.replaceSelections(text);\n            curPosFinal = selectionStart;\n          } else if (vim.visualBlock) {\n            cm.replaceSelections(emptyStrings);\n            cm.setCursor(selectionStart);\n            cm.replaceRange(text, selectionStart, selectionStart);\n            curPosFinal = selectionStart;\n          } else {\n            cm.replaceRange(text, selectionStart, selectionEnd);\n            curPosFinal = cm.posFromIndex(cm.indexFromPos(selectionStart) + text.length - 1);\n          }\n          // restore the the curEnd marker\n          if(lastSelectionCurEnd) {\n            vim.lastSelection.headMark = cm.setBookmark(lastSelectionCurEnd);\n          }\n          if (linewise) {\n            curPosFinal.ch=0;\n          }\n        } else {\n          if (blockwise) {\n            cm.setCursor(cur);\n            for (var i = 0; i < text.length; i++) {\n              var line = cur.line+i;\n              if (line > cm.lastLine()) {\n                cm.replaceRange('\\n',  Pos(line, 0));\n              }\n              var lastCh = lineLength(cm, line);\n              if (lastCh < cur.ch) {\n                extendLineToColumn(cm, line, cur.ch);\n              }\n            }\n            cm.setCursor(cur);\n            selectBlock(cm, Pos(cur.line + text.length-1, cur.ch));\n            cm.replaceSelections(text);\n            curPosFinal = cur;\n          } else {\n            cm.replaceRange(text, cur);\n            // Now fine tune the cursor to where we want it.\n            if (linewise && actionArgs.after) {\n              curPosFinal = Pos(\n              cur.line + 1,\n              findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line + 1)));\n            } else if (linewise && !actionArgs.after) {\n              curPosFinal = Pos(\n                cur.line,\n                findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line)));\n            } else if (!linewise && actionArgs.after) {\n              idx = cm.indexFromPos(cur);\n              curPosFinal = cm.posFromIndex(idx + text.length - 1);\n            } else {\n              idx = cm.indexFromPos(cur);\n              curPosFinal = cm.posFromIndex(idx + text.length);\n            }\n          }\n        }\n        if (vim.visualMode) {\n          exitVisualMode(cm, false);\n        }\n        cm.setCursor(curPosFinal);\n      },\n      undo: function(cm, actionArgs) {\n        cm.operation(function() {\n          repeatFn(cm, CodeMirror.commands.undo, actionArgs.repeat)();\n          cm.setCursor(cm.getCursor('anchor'));\n        });\n      },\n      redo: function(cm, actionArgs) {\n        repeatFn(cm, CodeMirror.commands.redo, actionArgs.repeat)();\n      },\n      setRegister: function(_cm, actionArgs, vim) {\n        vim.inputState.registerName = actionArgs.selectedCharacter;\n      },\n      setMark: function(cm, actionArgs, vim) {\n        var markName = actionArgs.selectedCharacter;\n        updateMark(cm, vim, markName, cm.getCursor());\n      },\n      replace: function(cm, actionArgs, vim) {\n        var replaceWith = actionArgs.selectedCharacter;\n        var curStart = cm.getCursor();\n        var replaceTo;\n        var curEnd;\n        var selections = cm.listSelections();\n        if (vim.visualMode) {\n          curStart = cm.getCursor('start');\n          curEnd = cm.getCursor('end');\n        } else {\n          var line = cm.getLine(curStart.line);\n          replaceTo = curStart.ch + actionArgs.repeat;\n          if (replaceTo > line.length) {\n            replaceTo=line.length;\n          }\n          curEnd = Pos(curStart.line, replaceTo);\n        }\n        if (replaceWith=='\\n') {\n          if (!vim.visualMode) cm.replaceRange('', curStart, curEnd);\n          // special case, where vim help says to replace by just one line-break\n          (CodeMirror.commands.newlineAndIndentContinueComment || CodeMirror.commands.newlineAndIndent)(cm);\n        } else {\n          var replaceWithStr = cm.getRange(curStart, curEnd);\n          //replace all characters in range by selected, but keep linebreaks\n          replaceWithStr = replaceWithStr.replace(/[^\\n]/g, replaceWith);\n          if (vim.visualBlock) {\n            // Tabs are split in visua block before replacing\n            var spaces = new Array(cm.getOption(\"tabSize\")+1).join(' ');\n            replaceWithStr = cm.getSelection();\n            replaceWithStr = replaceWithStr.replace(/\\t/g, spaces).replace(/[^\\n]/g, replaceWith).split('\\n');\n            cm.replaceSelections(replaceWithStr);\n          } else {\n            cm.replaceRange(replaceWithStr, curStart, curEnd);\n          }\n          if (vim.visualMode) {\n            curStart = cursorIsBefore(selections[0].anchor, selections[0].head) ?\n                         selections[0].anchor : selections[0].head;\n            cm.setCursor(curStart);\n            exitVisualMode(cm, false);\n          } else {\n            cm.setCursor(offsetCursor(curEnd, 0, -1));\n          }\n        }\n      },\n      incrementNumberToken: function(cm, actionArgs) {\n        var cur = cm.getCursor();\n        var lineStr = cm.getLine(cur.line);\n        var re = /(-?)(?:(0x)([\\da-f]+)|(0b|0|)(\\d+))/gi;\n        var match;\n        var start;\n        var end;\n        var numberStr;\n        while ((match = re.exec(lineStr)) !== null) {\n          start = match.index;\n          end = start + match[0].length;\n          if (cur.ch < end)break;\n        }\n        if (!actionArgs.backtrack && (end <= cur.ch))return;\n        if (match) {\n          var baseStr = match[2] || match[4]\n          var digits = match[3] || match[5]\n          var increment = actionArgs.increase ? 1 : -1;\n          var base = {'0b': 2, '0': 8, '': 10, '0x': 16}[baseStr.toLowerCase()];\n          var number = parseInt(match[1] + digits, base) + (increment * actionArgs.repeat);\n          numberStr = number.toString(base);\n          var zeroPadding = baseStr ? new Array(digits.length - numberStr.length + 1 + match[1].length).join('0') : ''\n          if (numberStr.charAt(0) === '-') {\n            numberStr = '-' + baseStr + zeroPadding + numberStr.substr(1);\n          } else {\n            numberStr = baseStr + zeroPadding + numberStr;\n          }\n          var from = Pos(cur.line, start);\n          var to = Pos(cur.line, end);\n          cm.replaceRange(numberStr, from, to);\n        } else {\n          return;\n        }\n        cm.setCursor(Pos(cur.line, start + numberStr.length - 1));\n      },\n      repeatLastEdit: function(cm, actionArgs, vim) {\n        var lastEditInputState = vim.lastEditInputState;\n        if (!lastEditInputState) { return; }\n        var repeat = actionArgs.repeat;\n        if (repeat && actionArgs.repeatIsExplicit) {\n          vim.lastEditInputState.repeatOverride = repeat;\n        } else {\n          repeat = vim.lastEditInputState.repeatOverride || repeat;\n        }\n        repeatLastEdit(cm, vim, repeat, false /** repeatForInsert */);\n      },\n      indent: function(cm, actionArgs) {\n        cm.indentLine(cm.getCursor().line, actionArgs.indentRight);\n      },\n      exitInsertMode: exitInsertMode\n    };\n\n    function defineAction(name, fn) {\n      actions[name] = fn;\n    }\n\n    /*\n     * Below are miscellaneous utility functions used by vim.js\n     */\n\n    /**\n     * Clips cursor to ensure that line is within the buffer's range\n     * If includeLineBreak is true, then allow cur.ch == lineLength.\n     */\n    function clipCursorToContent(cm, cur, includeLineBreak) {\n      var line = Math.min(Math.max(cm.firstLine(), cur.line), cm.lastLine() );\n      var maxCh = lineLength(cm, line) - 1;\n      maxCh = (includeLineBreak) ? maxCh + 1 : maxCh;\n      var ch = Math.min(Math.max(0, cur.ch), maxCh);\n      return Pos(line, ch);\n    }\n    function copyArgs(args) {\n      var ret = {};\n      for (var prop in args) {\n        if (args.hasOwnProperty(prop)) {\n          ret[prop] = args[prop];\n        }\n      }\n      return ret;\n    }\n    function offsetCursor(cur, offsetLine, offsetCh) {\n      if (typeof offsetLine === 'object') {\n        offsetCh = offsetLine.ch;\n        offsetLine = offsetLine.line;\n      }\n      return Pos(cur.line + offsetLine, cur.ch + offsetCh);\n    }\n    function getOffset(anchor, head) {\n      return {\n        line: head.line - anchor.line,\n        ch: head.line - anchor.line\n      };\n    }\n    function commandMatches(keys, keyMap, context, inputState) {\n      // Partial matches are not applied. They inform the key handler\n      // that the current key sequence is a subsequence of a valid key\n      // sequence, so that the key buffer is not cleared.\n      var match, partial = [], full = [];\n      for (var i = 0; i < keyMap.length; i++) {\n        var command = keyMap[i];\n        if (context == 'insert' && command.context != 'insert' ||\n            command.context && command.context != context ||\n            inputState.operator && command.type == 'action' ||\n            !(match = commandMatch(keys, command.keys))) { continue; }\n        if (match == 'partial') { partial.push(command); }\n        if (match == 'full') { full.push(command); }\n      }\n      return {\n        partial: partial.length && partial,\n        full: full.length && full\n      };\n    }\n    function commandMatch(pressed, mapped) {\n      if (mapped.slice(-11) == '<character>') {\n        // Last character matches anything.\n        var prefixLen = mapped.length - 11;\n        var pressedPrefix = pressed.slice(0, prefixLen);\n        var mappedPrefix = mapped.slice(0, prefixLen);\n        return pressedPrefix == mappedPrefix && pressed.length > prefixLen ? 'full' :\n               mappedPrefix.indexOf(pressedPrefix) == 0 ? 'partial' : false;\n      } else {\n        return pressed == mapped ? 'full' :\n               mapped.indexOf(pressed) == 0 ? 'partial' : false;\n      }\n    }\n    function lastChar(keys) {\n      var match = /^.*(<[^>]+>)$/.exec(keys);\n      var selectedCharacter = match ? match[1] : keys.slice(-1);\n      if (selectedCharacter.length > 1){\n        switch(selectedCharacter){\n          case '<CR>':\n            selectedCharacter='\\n';\n            break;\n          case '<Space>':\n            selectedCharacter=' ';\n            break;\n          default:\n            selectedCharacter='';\n            break;\n        }\n      }\n      return selectedCharacter;\n    }\n    function repeatFn(cm, fn, repeat) {\n      return function() {\n        for (var i = 0; i < repeat; i++) {\n          fn(cm);\n        }\n      };\n    }\n    function copyCursor(cur) {\n      return Pos(cur.line, cur.ch);\n    }\n    function cursorEqual(cur1, cur2) {\n      return cur1.ch == cur2.ch && cur1.line == cur2.line;\n    }\n    function cursorIsBefore(cur1, cur2) {\n      if (cur1.line < cur2.line) {\n        return true;\n      }\n      if (cur1.line == cur2.line && cur1.ch < cur2.ch) {\n        return true;\n      }\n      return false;\n    }\n    function cursorMin(cur1, cur2) {\n      if (arguments.length > 2) {\n        cur2 = cursorMin.apply(undefined, Array.prototype.slice.call(arguments, 1));\n      }\n      return cursorIsBefore(cur1, cur2) ? cur1 : cur2;\n    }\n    function cursorMax(cur1, cur2) {\n      if (arguments.length > 2) {\n        cur2 = cursorMax.apply(undefined, Array.prototype.slice.call(arguments, 1));\n      }\n      return cursorIsBefore(cur1, cur2) ? cur2 : cur1;\n    }\n    function cursorIsBetween(cur1, cur2, cur3) {\n      // returns true if cur2 is between cur1 and cur3.\n      var cur1before2 = cursorIsBefore(cur1, cur2);\n      var cur2before3 = cursorIsBefore(cur2, cur3);\n      return cur1before2 && cur2before3;\n    }\n    function lineLength(cm, lineNum) {\n      return cm.getLine(lineNum).length;\n    }\n    function trim(s) {\n      if (s.trim) {\n        return s.trim();\n      }\n      return s.replace(/^\\s+|\\s+$/g, '');\n    }\n    function escapeRegex(s) {\n      return s.replace(/([.?*+$\\[\\]\\/\\\\(){}|\\-])/g, '\\\\$1');\n    }\n    function extendLineToColumn(cm, lineNum, column) {\n      var endCh = lineLength(cm, lineNum);\n      var spaces = new Array(column-endCh+1).join(' ');\n      cm.setCursor(Pos(lineNum, endCh));\n      cm.replaceRange(spaces, cm.getCursor());\n    }\n    // This functions selects a rectangular block\n    // of text with selectionEnd as any of its corner\n    // Height of block:\n    // Difference in selectionEnd.line and first/last selection.line\n    // Width of the block:\n    // Distance between selectionEnd.ch and any(first considered here) selection.ch\n    function selectBlock(cm, selectionEnd) {\n      var selections = [], ranges = cm.listSelections();\n      var head = copyCursor(cm.clipPos(selectionEnd));\n      var isClipped = !cursorEqual(selectionEnd, head);\n      var curHead = cm.getCursor('head');\n      var primIndex = getIndex(ranges, curHead);\n      var wasClipped = cursorEqual(ranges[primIndex].head, ranges[primIndex].anchor);\n      var max = ranges.length - 1;\n      var index = max - primIndex > primIndex ? max : 0;\n      var base = ranges[index].anchor;\n\n      var firstLine = Math.min(base.line, head.line);\n      var lastLine = Math.max(base.line, head.line);\n      var baseCh = base.ch, headCh = head.ch;\n\n      var dir = ranges[index].head.ch - baseCh;\n      var newDir = headCh - baseCh;\n      if (dir > 0 && newDir <= 0) {\n        baseCh++;\n        if (!isClipped) { headCh--; }\n      } else if (dir < 0 && newDir >= 0) {\n        baseCh--;\n        if (!wasClipped) { headCh++; }\n      } else if (dir < 0 && newDir == -1) {\n        baseCh--;\n        headCh++;\n      }\n      for (var line = firstLine; line <= lastLine; line++) {\n        var range = {anchor: new Pos(line, baseCh), head: new Pos(line, headCh)};\n        selections.push(range);\n      }\n      cm.setSelections(selections);\n      selectionEnd.ch = headCh;\n      base.ch = baseCh;\n      return base;\n    }\n    function selectForInsert(cm, head, height) {\n      var sel = [];\n      for (var i = 0; i < height; i++) {\n        var lineHead = offsetCursor(head, i, 0);\n        sel.push({anchor: lineHead, head: lineHead});\n      }\n      cm.setSelections(sel, 0);\n    }\n    // getIndex returns the index of the cursor in the selections.\n    function getIndex(ranges, cursor, end) {\n      for (var i = 0; i < ranges.length; i++) {\n        var atAnchor = end != 'head' && cursorEqual(ranges[i].anchor, cursor);\n        var atHead = end != 'anchor' && cursorEqual(ranges[i].head, cursor);\n        if (atAnchor || atHead) {\n          return i;\n        }\n      }\n      return -1;\n    }\n    function getSelectedAreaRange(cm, vim) {\n      var lastSelection = vim.lastSelection;\n      var getCurrentSelectedAreaRange = function() {\n        var selections = cm.listSelections();\n        var start =  selections[0];\n        var end = selections[selections.length-1];\n        var selectionStart = cursorIsBefore(start.anchor, start.head) ? start.anchor : start.head;\n        var selectionEnd = cursorIsBefore(end.anchor, end.head) ? end.head : end.anchor;\n        return [selectionStart, selectionEnd];\n      };\n      var getLastSelectedAreaRange = function() {\n        var selectionStart = cm.getCursor();\n        var selectionEnd = cm.getCursor();\n        var block = lastSelection.visualBlock;\n        if (block) {\n          var width = block.width;\n          var height = block.height;\n          selectionEnd = Pos(selectionStart.line + height, selectionStart.ch + width);\n          var selections = [];\n          // selectBlock creates a 'proper' rectangular block.\n          // We do not want that in all cases, so we manually set selections.\n          for (var i = selectionStart.line; i < selectionEnd.line; i++) {\n            var anchor = Pos(i, selectionStart.ch);\n            var head = Pos(i, selectionEnd.ch);\n            var range = {anchor: anchor, head: head};\n            selections.push(range);\n          }\n          cm.setSelections(selections);\n        } else {\n          var start = lastSelection.anchorMark.find();\n          var end = lastSelection.headMark.find();\n          var line = end.line - start.line;\n          var ch = end.ch - start.ch;\n          selectionEnd = {line: selectionEnd.line + line, ch: line ? selectionEnd.ch : ch + selectionEnd.ch};\n          if (lastSelection.visualLine) {\n            selectionStart = Pos(selectionStart.line, 0);\n            selectionEnd = Pos(selectionEnd.line, lineLength(cm, selectionEnd.line));\n          }\n          cm.setSelection(selectionStart, selectionEnd);\n        }\n        return [selectionStart, selectionEnd];\n      };\n      if (!vim.visualMode) {\n      // In case of replaying the action.\n        return getLastSelectedAreaRange();\n      } else {\n        return getCurrentSelectedAreaRange();\n      }\n    }\n    // Updates the previous selection with the current selection's values. This\n    // should only be called in visual mode.\n    function updateLastSelection(cm, vim) {\n      var anchor = vim.sel.anchor;\n      var head = vim.sel.head;\n      // To accommodate the effect of lastPastedText in the last selection\n      if (vim.lastPastedText) {\n        head = cm.posFromIndex(cm.indexFromPos(anchor) + vim.lastPastedText.length);\n        vim.lastPastedText = null;\n      }\n      vim.lastSelection = {'anchorMark': cm.setBookmark(anchor),\n                           'headMark': cm.setBookmark(head),\n                           'anchor': copyCursor(anchor),\n                           'head': copyCursor(head),\n                           'visualMode': vim.visualMode,\n                           'visualLine': vim.visualLine,\n                           'visualBlock': vim.visualBlock};\n    }\n    function expandSelection(cm, start, end) {\n      var sel = cm.state.vim.sel;\n      var head = sel.head;\n      var anchor = sel.anchor;\n      var tmp;\n      if (cursorIsBefore(end, start)) {\n        tmp = end;\n        end = start;\n        start = tmp;\n      }\n      if (cursorIsBefore(head, anchor)) {\n        head = cursorMin(start, head);\n        anchor = cursorMax(anchor, end);\n      } else {\n        anchor = cursorMin(start, anchor);\n        head = cursorMax(head, end);\n        head = offsetCursor(head, 0, -1);\n        if (head.ch == -1 && head.line != cm.firstLine()) {\n          head = Pos(head.line - 1, lineLength(cm, head.line - 1));\n        }\n      }\n      return [anchor, head];\n    }\n    /**\n     * Updates the CodeMirror selection to match the provided vim selection.\n     * If no arguments are given, it uses the current vim selection state.\n     */\n    function updateCmSelection(cm, sel, mode) {\n      var vim = cm.state.vim;\n      sel = sel || vim.sel;\n      var mode = mode ||\n        vim.visualLine ? 'line' : vim.visualBlock ? 'block' : 'char';\n      var cmSel = makeCmSelection(cm, sel, mode);\n      cm.setSelections(cmSel.ranges, cmSel.primary);\n      updateFakeCursor(cm);\n    }\n    function makeCmSelection(cm, sel, mode, exclusive) {\n      var head = copyCursor(sel.head);\n      var anchor = copyCursor(sel.anchor);\n      if (mode == 'char') {\n        var headOffset = !exclusive && !cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n        var anchorOffset = cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n        head = offsetCursor(sel.head, 0, headOffset);\n        anchor = offsetCursor(sel.anchor, 0, anchorOffset);\n        return {\n          ranges: [{anchor: anchor, head: head}],\n          primary: 0\n        };\n      } else if (mode == 'line') {\n        if (!cursorIsBefore(sel.head, sel.anchor)) {\n          anchor.ch = 0;\n\n          var lastLine = cm.lastLine();\n          if (head.line > lastLine) {\n            head.line = lastLine;\n          }\n          head.ch = lineLength(cm, head.line);\n        } else {\n          head.ch = 0;\n          anchor.ch = lineLength(cm, anchor.line);\n        }\n        return {\n          ranges: [{anchor: anchor, head: head}],\n          primary: 0\n        };\n      } else if (mode == 'block') {\n        var top = Math.min(anchor.line, head.line),\n            left = Math.min(anchor.ch, head.ch),\n            bottom = Math.max(anchor.line, head.line),\n            right = Math.max(anchor.ch, head.ch) + 1;\n        var height = bottom - top + 1;\n        var primary = head.line == top ? 0 : height - 1;\n        var ranges = [];\n        for (var i = 0; i < height; i++) {\n          ranges.push({\n            anchor: Pos(top + i, left),\n            head: Pos(top + i, right)\n          });\n        }\n        return {\n          ranges: ranges,\n          primary: primary\n        };\n      }\n    }\n    function getHead(cm) {\n      var cur = cm.getCursor('head');\n      if (cm.getSelection().length == 1) {\n        // Small corner case when only 1 character is selected. The \"real\"\n        // head is the left of head and anchor.\n        cur = cursorMin(cur, cm.getCursor('anchor'));\n      }\n      return cur;\n    }\n\n    /**\n     * If moveHead is set to false, the CodeMirror selection will not be\n     * touched. The caller assumes the responsibility of putting the cursor\n    * in the right place.\n     */\n    function exitVisualMode(cm, moveHead) {\n      var vim = cm.state.vim;\n      if (moveHead !== false) {\n        cm.setCursor(clipCursorToContent(cm, vim.sel.head));\n      }\n      updateLastSelection(cm, vim);\n      vim.visualMode = false;\n      vim.visualLine = false;\n      vim.visualBlock = false;\n      CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n      if (vim.fakeCursor) {\n        vim.fakeCursor.clear();\n      }\n    }\n\n    // Remove any trailing newlines from the selection. For\n    // example, with the caret at the start of the last word on the line,\n    // 'dw' should word, but not the newline, while 'w' should advance the\n    // caret to the first character of the next line.\n    function clipToLine(cm, curStart, curEnd) {\n      var selection = cm.getRange(curStart, curEnd);\n      // Only clip if the selection ends with trailing newline + whitespace\n      if (/\\n\\s*$/.test(selection)) {\n        var lines = selection.split('\\n');\n        // We know this is all whitespace.\n        lines.pop();\n\n        // Cases:\n        // 1. Last word is an empty line - do not clip the trailing '\\n'\n        // 2. Last word is not an empty line - clip the trailing '\\n'\n        var line;\n        // Find the line containing the last word, and clip all whitespace up\n        // to it.\n        for (var line = lines.pop(); lines.length > 0 && line && isWhiteSpaceString(line); line = lines.pop()) {\n          curEnd.line--;\n          curEnd.ch = 0;\n        }\n        // If the last word is not an empty line, clip an additional newline\n        if (line) {\n          curEnd.line--;\n          curEnd.ch = lineLength(cm, curEnd.line);\n        } else {\n          curEnd.ch = 0;\n        }\n      }\n    }\n\n    // Expand the selection to line ends.\n    function expandSelectionToLine(_cm, curStart, curEnd) {\n      curStart.ch = 0;\n      curEnd.ch = 0;\n      curEnd.line++;\n    }\n\n    function findFirstNonWhiteSpaceCharacter(text) {\n      if (!text) {\n        return 0;\n      }\n      var firstNonWS = text.search(/\\S/);\n      return firstNonWS == -1 ? text.length : firstNonWS;\n    }\n\n    function expandWordUnderCursor(cm, inclusive, _forward, bigWord, noSymbol) {\n      var cur = getHead(cm);\n      var line = cm.getLine(cur.line);\n      var idx = cur.ch;\n\n      // Seek to first word or non-whitespace character, depending on if\n      // noSymbol is true.\n      var test = noSymbol ? wordCharTest[0] : bigWordCharTest [0];\n      while (!test(line.charAt(idx))) {\n        idx++;\n        if (idx >= line.length) { return null; }\n      }\n\n      if (bigWord) {\n        test = bigWordCharTest[0];\n      } else {\n        test = wordCharTest[0];\n        if (!test(line.charAt(idx))) {\n          test = wordCharTest[1];\n        }\n      }\n\n      var end = idx, start = idx;\n      while (test(line.charAt(end)) && end < line.length) { end++; }\n      while (test(line.charAt(start)) && start >= 0) { start--; }\n      start++;\n\n      if (inclusive) {\n        // If present, include all whitespace after word.\n        // Otherwise, include all whitespace before word, except indentation.\n        var wordEnd = end;\n        while (/\\s/.test(line.charAt(end)) && end < line.length) { end++; }\n        if (wordEnd == end) {\n          var wordStart = start;\n          while (/\\s/.test(line.charAt(start - 1)) && start > 0) { start--; }\n          if (!start) { start = wordStart; }\n        }\n      }\n      return { start: Pos(cur.line, start), end: Pos(cur.line, end) };\n    }\n\n    function recordJumpPosition(cm, oldCur, newCur) {\n      if (!cursorEqual(oldCur, newCur)) {\n        vimGlobalState.jumpList.add(cm, oldCur, newCur);\n      }\n    }\n\n    function recordLastCharacterSearch(increment, args) {\n        vimGlobalState.lastCharacterSearch.increment = increment;\n        vimGlobalState.lastCharacterSearch.forward = args.forward;\n        vimGlobalState.lastCharacterSearch.selectedCharacter = args.selectedCharacter;\n    }\n\n    var symbolToMode = {\n        '(': 'bracket', ')': 'bracket', '{': 'bracket', '}': 'bracket',\n        '[': 'section', ']': 'section',\n        '*': 'comment', '/': 'comment',\n        'm': 'method', 'M': 'method',\n        '#': 'preprocess'\n    };\n    var findSymbolModes = {\n      bracket: {\n        isComplete: function(state) {\n          if (state.nextCh === state.symb) {\n            state.depth++;\n            if (state.depth >= 1)return true;\n          } else if (state.nextCh === state.reverseSymb) {\n            state.depth--;\n          }\n          return false;\n        }\n      },\n      section: {\n        init: function(state) {\n          state.curMoveThrough = true;\n          state.symb = (state.forward ? ']' : '[') === state.symb ? '{' : '}';\n        },\n        isComplete: function(state) {\n          return state.index === 0 && state.nextCh === state.symb;\n        }\n      },\n      comment: {\n        isComplete: function(state) {\n          var found = state.lastCh === '*' && state.nextCh === '/';\n          state.lastCh = state.nextCh;\n          return found;\n        }\n      },\n      // TODO: The original Vim implementation only operates on level 1 and 2.\n      // The current implementation doesn't check for code block level and\n      // therefore it operates on any levels.\n      method: {\n        init: function(state) {\n          state.symb = (state.symb === 'm' ? '{' : '}');\n          state.reverseSymb = state.symb === '{' ? '}' : '{';\n        },\n        isComplete: function(state) {\n          if (state.nextCh === state.symb)return true;\n          return false;\n        }\n      },\n      preprocess: {\n        init: function(state) {\n          state.index = 0;\n        },\n        isComplete: function(state) {\n          if (state.nextCh === '#') {\n            var token = state.lineText.match(/#(\\w+)/)[1];\n            if (token === 'endif') {\n              if (state.forward && state.depth === 0) {\n                return true;\n              }\n              state.depth++;\n            } else if (token === 'if') {\n              if (!state.forward && state.depth === 0) {\n                return true;\n              }\n              state.depth--;\n            }\n            if (token === 'else' && state.depth === 0)return true;\n          }\n          return false;\n        }\n      }\n    };\n    function findSymbol(cm, repeat, forward, symb) {\n      var cur = copyCursor(cm.getCursor());\n      var increment = forward ? 1 : -1;\n      var endLine = forward ? cm.lineCount() : -1;\n      var curCh = cur.ch;\n      var line = cur.line;\n      var lineText = cm.getLine(line);\n      var state = {\n        lineText: lineText,\n        nextCh: lineText.charAt(curCh),\n        lastCh: null,\n        index: curCh,\n        symb: symb,\n        reverseSymb: (forward ?  { ')': '(', '}': '{' } : { '(': ')', '{': '}' })[symb],\n        forward: forward,\n        depth: 0,\n        curMoveThrough: false\n      };\n      var mode = symbolToMode[symb];\n      if (!mode)return cur;\n      var init = findSymbolModes[mode].init;\n      var isComplete = findSymbolModes[mode].isComplete;\n      if (init) { init(state); }\n      while (line !== endLine && repeat) {\n        state.index += increment;\n        state.nextCh = state.lineText.charAt(state.index);\n        if (!state.nextCh) {\n          line += increment;\n          state.lineText = cm.getLine(line) || '';\n          if (increment > 0) {\n            state.index = 0;\n          } else {\n            var lineLen = state.lineText.length;\n            state.index = (lineLen > 0) ? (lineLen-1) : 0;\n          }\n          state.nextCh = state.lineText.charAt(state.index);\n        }\n        if (isComplete(state)) {\n          cur.line = line;\n          cur.ch = state.index;\n          repeat--;\n        }\n      }\n      if (state.nextCh || state.curMoveThrough) {\n        return Pos(line, state.index);\n      }\n      return cur;\n    }\n\n    /*\n     * Returns the boundaries of the next word. If the cursor in the middle of\n     * the word, then returns the boundaries of the current word, starting at\n     * the cursor. If the cursor is at the start/end of a word, and we are going\n     * forward/backward, respectively, find the boundaries of the next word.\n     *\n     * @param {CodeMirror} cm CodeMirror object.\n     * @param {Cursor} cur The cursor position.\n     * @param {boolean} forward True to search forward. False to search\n     *     backward.\n     * @param {boolean} bigWord True if punctuation count as part of the word.\n     *     False if only [a-zA-Z0-9] characters count as part of the word.\n     * @param {boolean} emptyLineIsWord True if empty lines should be treated\n     *     as words.\n     * @return {Object{from:number, to:number, line: number}} The boundaries of\n     *     the word, or null if there are no more words.\n     */\n    function findWord(cm, cur, forward, bigWord, emptyLineIsWord) {\n      var lineNum = cur.line;\n      var pos = cur.ch;\n      var line = cm.getLine(lineNum);\n      var dir = forward ? 1 : -1;\n      var charTests = bigWord ? bigWordCharTest: wordCharTest;\n\n      if (emptyLineIsWord && line == '') {\n        lineNum += dir;\n        line = cm.getLine(lineNum);\n        if (!isLine(cm, lineNum)) {\n          return null;\n        }\n        pos = (forward) ? 0 : line.length;\n      }\n\n      while (true) {\n        if (emptyLineIsWord && line == '') {\n          return { from: 0, to: 0, line: lineNum };\n        }\n        var stop = (dir > 0) ? line.length : -1;\n        var wordStart = stop, wordEnd = stop;\n        // Find bounds of next word.\n        while (pos != stop) {\n          var foundWord = false;\n          for (var i = 0; i < charTests.length && !foundWord; ++i) {\n            if (charTests[i](line.charAt(pos))) {\n              wordStart = pos;\n              // Advance to end of word.\n              while (pos != stop && charTests[i](line.charAt(pos))) {\n                pos += dir;\n              }\n              wordEnd = pos;\n              foundWord = wordStart != wordEnd;\n              if (wordStart == cur.ch && lineNum == cur.line &&\n                  wordEnd == wordStart + dir) {\n                // We started at the end of a word. Find the next one.\n                continue;\n              } else {\n                return {\n                  from: Math.min(wordStart, wordEnd + 1),\n                  to: Math.max(wordStart, wordEnd),\n                  line: lineNum };\n              }\n            }\n          }\n          if (!foundWord) {\n            pos += dir;\n          }\n        }\n        // Advance to next/prev line.\n        lineNum += dir;\n        if (!isLine(cm, lineNum)) {\n          return null;\n        }\n        line = cm.getLine(lineNum);\n        pos = (dir > 0) ? 0 : line.length;\n      }\n    }\n\n    /**\n     * @param {CodeMirror} cm CodeMirror object.\n     * @param {Pos} cur The position to start from.\n     * @param {int} repeat Number of words to move past.\n     * @param {boolean} forward True to search forward. False to search\n     *     backward.\n     * @param {boolean} wordEnd True to move to end of word. False to move to\n     *     beginning of word.\n     * @param {boolean} bigWord True if punctuation count as part of the word.\n     *     False if only alphabet characters count as part of the word.\n     * @return {Cursor} The position the cursor should move to.\n     */\n    function moveToWord(cm, cur, repeat, forward, wordEnd, bigWord) {\n      var curStart = copyCursor(cur);\n      var words = [];\n      if (forward && !wordEnd || !forward && wordEnd) {\n        repeat++;\n      }\n      // For 'e', empty lines are not considered words, go figure.\n      var emptyLineIsWord = !(forward && wordEnd);\n      for (var i = 0; i < repeat; i++) {\n        var word = findWord(cm, cur, forward, bigWord, emptyLineIsWord);\n        if (!word) {\n          var eodCh = lineLength(cm, cm.lastLine());\n          words.push(forward\n              ? {line: cm.lastLine(), from: eodCh, to: eodCh}\n              : {line: 0, from: 0, to: 0});\n          break;\n        }\n        words.push(word);\n        cur = Pos(word.line, forward ? (word.to - 1) : word.from);\n      }\n      var shortCircuit = words.length != repeat;\n      var firstWord = words[0];\n      var lastWord = words.pop();\n      if (forward && !wordEnd) {\n        // w\n        if (!shortCircuit && (firstWord.from != curStart.ch || firstWord.line != curStart.line)) {\n          // We did not start in the middle of a word. Discard the extra word at the end.\n          lastWord = words.pop();\n        }\n        return Pos(lastWord.line, lastWord.from);\n      } else if (forward && wordEnd) {\n        return Pos(lastWord.line, lastWord.to - 1);\n      } else if (!forward && wordEnd) {\n        // ge\n        if (!shortCircuit && (firstWord.to != curStart.ch || firstWord.line != curStart.line)) {\n          // We did not start in the middle of a word. Discard the extra word at the end.\n          lastWord = words.pop();\n        }\n        return Pos(lastWord.line, lastWord.to);\n      } else {\n        // b\n        return Pos(lastWord.line, lastWord.from);\n      }\n    }\n\n    function moveToCharacter(cm, repeat, forward, character) {\n      var cur = cm.getCursor();\n      var start = cur.ch;\n      var idx;\n      for (var i = 0; i < repeat; i ++) {\n        var line = cm.getLine(cur.line);\n        idx = charIdxInLine(start, line, character, forward, true);\n        if (idx == -1) {\n          return null;\n        }\n        start = idx;\n      }\n      return Pos(cm.getCursor().line, idx);\n    }\n\n    function moveToColumn(cm, repeat) {\n      // repeat is always >= 1, so repeat - 1 always corresponds\n      // to the column we want to go to.\n      var line = cm.getCursor().line;\n      return clipCursorToContent(cm, Pos(line, repeat - 1));\n    }\n\n    function updateMark(cm, vim, markName, pos) {\n      if (!inArray(markName, validMarks)) {\n        return;\n      }\n      if (vim.marks[markName]) {\n        vim.marks[markName].clear();\n      }\n      vim.marks[markName] = cm.setBookmark(pos);\n    }\n\n    function charIdxInLine(start, line, character, forward, includeChar) {\n      // Search for char in line.\n      // motion_options: {forward, includeChar}\n      // If includeChar = true, include it too.\n      // If forward = true, search forward, else search backwards.\n      // If char is not found on this line, do nothing\n      var idx;\n      if (forward) {\n        idx = line.indexOf(character, start + 1);\n        if (idx != -1 && !includeChar) {\n          idx -= 1;\n        }\n      } else {\n        idx = line.lastIndexOf(character, start - 1);\n        if (idx != -1 && !includeChar) {\n          idx += 1;\n        }\n      }\n      return idx;\n    }\n\n    function findParagraph(cm, head, repeat, dir, inclusive) {\n      var line = head.line;\n      var min = cm.firstLine();\n      var max = cm.lastLine();\n      var start, end, i = line;\n      function isEmpty(i) { return !cm.getLine(i); }\n      function isBoundary(i, dir, any) {\n        if (any) { return isEmpty(i) != isEmpty(i + dir); }\n        return !isEmpty(i) && isEmpty(i + dir);\n      }\n      if (dir) {\n        while (min <= i && i <= max && repeat > 0) {\n          if (isBoundary(i, dir)) { repeat--; }\n          i += dir;\n        }\n        return new Pos(i, 0);\n      }\n\n      var vim = cm.state.vim;\n      if (vim.visualLine && isBoundary(line, 1, true)) {\n        var anchor = vim.sel.anchor;\n        if (isBoundary(anchor.line, -1, true)) {\n          if (!inclusive || anchor.line != line) {\n            line += 1;\n          }\n        }\n      }\n      var startState = isEmpty(line);\n      for (i = line; i <= max && repeat; i++) {\n        if (isBoundary(i, 1, true)) {\n          if (!inclusive || isEmpty(i) != startState) {\n            repeat--;\n          }\n        }\n      }\n      end = new Pos(i, 0);\n      // select boundary before paragraph for the last one\n      if (i > max && !startState) { startState = true; }\n      else { inclusive = false; }\n      for (i = line; i > min; i--) {\n        if (!inclusive || isEmpty(i) == startState || i == line) {\n          if (isBoundary(i, -1, true)) { break; }\n        }\n      }\n      start = new Pos(i, 0);\n      return { start: start, end: end };\n    }\n\n    function findSentence(cm, cur, repeat, dir) {\n\n      /*\n        Takes an index object\n        {\n          line: the line string,\n          ln: line number,\n          pos: index in line,\n          dir: direction of traversal (-1 or 1)\n        }\n        and modifies the line, ln, and pos members to represent the\n        next valid position or sets them to null if there are\n        no more valid positions.\n       */\n      function nextChar(cm, idx) {\n        if (idx.pos + idx.dir < 0 || idx.pos + idx.dir >= idx.line.length) {\n          idx.ln += idx.dir;\n          if (!isLine(cm, idx.ln)) {\n            idx.line = null;\n            idx.ln = null;\n            idx.pos = null;\n            return;\n          }\n          idx.line = cm.getLine(idx.ln);\n          idx.pos = (idx.dir > 0) ? 0 : idx.line.length - 1;\n        }\n        else {\n          idx.pos += idx.dir;\n        }\n      }\n\n      /*\n        Performs one iteration of traversal in forward direction\n        Returns an index object of the new location\n       */\n      function forward(cm, ln, pos, dir) {\n        var line = cm.getLine(ln);\n        var stop = (line === \"\");\n\n        var curr = {\n          line: line,\n          ln: ln,\n          pos: pos,\n          dir: dir,\n        }\n\n        var last_valid = {\n          ln: curr.ln,\n          pos: curr.pos,\n        }\n\n        var skip_empty_lines = (curr.line === \"\");\n\n        // Move one step to skip character we start on\n        nextChar(cm, curr);\n\n        while (curr.line !== null) {\n          last_valid.ln = curr.ln;\n          last_valid.pos = curr.pos;\n\n          if (curr.line === \"\" && !skip_empty_lines) {\n            return { ln: curr.ln, pos: curr.pos, };\n          }\n          else if (stop && curr.line !== \"\" && !isWhiteSpaceString(curr.line[curr.pos])) {\n            return { ln: curr.ln, pos: curr.pos, };\n          }\n          else if (isEndOfSentenceSymbol(curr.line[curr.pos])\n            && !stop\n            && (curr.pos === curr.line.length - 1\n              || isWhiteSpaceString(curr.line[curr.pos + 1]))) {\n            stop = true;\n          }\n\n          nextChar(cm, curr);\n        }\n\n        /*\n          Set the position to the last non whitespace character on the last\n          valid line in the case that we reach the end of the document.\n        */\n        var line = cm.getLine(last_valid.ln);\n        last_valid.pos = 0;\n        for(var i = line.length - 1; i >= 0; --i) {\n          if (!isWhiteSpaceString(line[i])) {\n            last_valid.pos = i;\n            break;\n          }\n        }\n\n        return last_valid;\n\n      }\n\n      /*\n        Performs one iteration of traversal in reverse direction\n        Returns an index object of the new location\n       */\n      function reverse(cm, ln, pos, dir) {\n        var line = cm.getLine(ln);\n\n        var curr = {\n          line: line,\n          ln: ln,\n          pos: pos,\n          dir: dir,\n        }\n\n        var last_valid = {\n          ln: curr.ln,\n          pos: null,\n        };\n\n        var skip_empty_lines = (curr.line === \"\");\n\n        // Move one step to skip character we start on\n        nextChar(cm, curr);\n\n        while (curr.line !== null) {\n\n          if (curr.line === \"\" && !skip_empty_lines) {\n            if (last_valid.pos !== null) {\n              return last_valid;\n            }\n            else {\n              return { ln: curr.ln, pos: curr.pos };\n            }\n          }\n          else if (isEndOfSentenceSymbol(curr.line[curr.pos])\n              && last_valid.pos !== null\n              && !(curr.ln === last_valid.ln && curr.pos + 1 === last_valid.pos)) {\n            return last_valid;\n          }\n          else if (curr.line !== \"\" && !isWhiteSpaceString(curr.line[curr.pos])) {\n            skip_empty_lines = false;\n            last_valid = { ln: curr.ln, pos: curr.pos }\n          }\n\n          nextChar(cm, curr);\n        }\n\n        /*\n          Set the position to the first non whitespace character on the last\n          valid line in the case that we reach the beginning of the document.\n        */\n        var line = cm.getLine(last_valid.ln);\n        last_valid.pos = 0;\n        for(var i = 0; i < line.length; ++i) {\n          if (!isWhiteSpaceString(line[i])) {\n            last_valid.pos = i;\n            break;\n          }\n        }\n        return last_valid;\n      }\n\n      var curr_index = {\n        ln: cur.line,\n        pos: cur.ch,\n      };\n\n      while (repeat > 0) {\n        if (dir < 0) {\n          curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);\n        }\n        else {\n          curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);\n        }\n        repeat--;\n      }\n\n      return Pos(curr_index.ln, curr_index.pos);\n    }\n\n    // TODO: perhaps this finagling of start and end positions belonds\n    // in codemirror/replaceRange?\n    function selectCompanionObject(cm, head, symb, inclusive) {\n      var cur = head, start, end;\n\n      var bracketRegexp = ({\n        '(': /[()]/, ')': /[()]/,\n        '[': /[[\\]]/, ']': /[[\\]]/,\n        '{': /[{}]/, '}': /[{}]/})[symb];\n      var openSym = ({\n        '(': '(', ')': '(',\n        '[': '[', ']': '[',\n        '{': '{', '}': '{'})[symb];\n      var curChar = cm.getLine(cur.line).charAt(cur.ch);\n      // Due to the behavior of scanForBracket, we need to add an offset if the\n      // cursor is on a matching open bracket.\n      var offset = curChar === openSym ? 1 : 0;\n\n      start = cm.scanForBracket(Pos(cur.line, cur.ch + offset), -1, undefined, {'bracketRegex': bracketRegexp});\n      end = cm.scanForBracket(Pos(cur.line, cur.ch + offset), 1, undefined, {'bracketRegex': bracketRegexp});\n\n      if (!start || !end) {\n        return { start: cur, end: cur };\n      }\n\n      start = start.pos;\n      end = end.pos;\n\n      if ((start.line == end.line && start.ch > end.ch)\n          || (start.line > end.line)) {\n        var tmp = start;\n        start = end;\n        end = tmp;\n      }\n\n      if (inclusive) {\n        end.ch += 1;\n      } else {\n        start.ch += 1;\n      }\n\n      return { start: start, end: end };\n    }\n\n    // Takes in a symbol and a cursor and tries to simulate text objects that\n    // have identical opening and closing symbols\n    // TODO support across multiple lines\n    function findBeginningAndEnd(cm, head, symb, inclusive) {\n      var cur = copyCursor(head);\n      var line = cm.getLine(cur.line);\n      var chars = line.split('');\n      var start, end, i, len;\n      var firstIndex = chars.indexOf(symb);\n\n      // the decision tree is to always look backwards for the beginning first,\n      // but if the cursor is in front of the first instance of the symb,\n      // then move the cursor forward\n      if (cur.ch < firstIndex) {\n        cur.ch = firstIndex;\n        // Why is this line even here???\n        // cm.setCursor(cur.line, firstIndex+1);\n      }\n      // otherwise if the cursor is currently on the closing symbol\n      else if (firstIndex < cur.ch && chars[cur.ch] == symb) {\n        end = cur.ch; // assign end to the current cursor\n        --cur.ch; // make sure to look backwards\n      }\n\n      // if we're currently on the symbol, we've got a start\n      if (chars[cur.ch] == symb && !end) {\n        start = cur.ch + 1; // assign start to ahead of the cursor\n      } else {\n        // go backwards to find the start\n        for (i = cur.ch; i > -1 && !start; i--) {\n          if (chars[i] == symb) {\n            start = i + 1;\n          }\n        }\n      }\n\n      // look forwards for the end symbol\n      if (start && !end) {\n        for (i = start, len = chars.length; i < len && !end; i++) {\n          if (chars[i] == symb) {\n            end = i;\n          }\n        }\n      }\n\n      // nothing found\n      if (!start || !end) {\n        return { start: cur, end: cur };\n      }\n\n      // include the symbols\n      if (inclusive) {\n        --start; ++end;\n      }\n\n      return {\n        start: Pos(cur.line, start),\n        end: Pos(cur.line, end)\n      };\n    }\n\n    // Search functions\n    defineOption('pcre', true, 'boolean');\n    function SearchState() {}\n    SearchState.prototype = {\n      getQuery: function() {\n        return vimGlobalState.query;\n      },\n      setQuery: function(query) {\n        vimGlobalState.query = query;\n      },\n      getOverlay: function() {\n        return this.searchOverlay;\n      },\n      setOverlay: function(overlay) {\n        this.searchOverlay = overlay;\n      },\n      isReversed: function() {\n        return vimGlobalState.isReversed;\n      },\n      setReversed: function(reversed) {\n        vimGlobalState.isReversed = reversed;\n      },\n      getScrollbarAnnotate: function() {\n        return this.annotate;\n      },\n      setScrollbarAnnotate: function(annotate) {\n        this.annotate = annotate;\n      }\n    };\n    function getSearchState(cm) {\n      var vim = cm.state.vim;\n      return vim.searchState_ || (vim.searchState_ = new SearchState());\n    }\n    function dialog(cm, template, shortText, onClose, options) {\n      if (cm.openDialog) {\n        cm.openDialog(template, onClose, { bottom: true, value: options.value,\n            onKeyDown: options.onKeyDown, onKeyUp: options.onKeyUp,\n            selectValueOnOpen: false});\n      }\n      else {\n        onClose(prompt(shortText, ''));\n      }\n    }\n    function splitBySlash(argString) {\n      return splitBySeparator(argString, '/');\n    }\n\n    function findUnescapedSlashes(argString) {\n      return findUnescapedSeparators(argString, '/');\n    }\n\n    function splitBySeparator(argString, separator) {\n      var slashes = findUnescapedSeparators(argString, separator) || [];\n      if (!slashes.length) return [];\n      var tokens = [];\n      // in case of strings like foo/bar\n      if (slashes[0] !== 0) return;\n      for (var i = 0; i < slashes.length; i++) {\n        if (typeof slashes[i] == 'number')\n          tokens.push(argString.substring(slashes[i] + 1, slashes[i+1]));\n      }\n      return tokens;\n    }\n\n    function findUnescapedSeparators(str, separator) {\n      if (!separator)\n        separator = '/';\n\n      var escapeNextChar = false;\n      var slashes = [];\n      for (var i = 0; i < str.length; i++) {\n        var c = str.charAt(i);\n        if (!escapeNextChar && c == separator) {\n          slashes.push(i);\n        }\n        escapeNextChar = !escapeNextChar && (c == '\\\\');\n      }\n      return slashes;\n    }\n\n    // Translates a search string from ex (vim) syntax into javascript form.\n    function translateRegex(str) {\n      // When these match, add a '\\' if unescaped or remove one if escaped.\n      var specials = '|(){';\n      // Remove, but never add, a '\\' for these.\n      var unescape = '}';\n      var escapeNextChar = false;\n      var out = [];\n      for (var i = -1; i < str.length; i++) {\n        var c = str.charAt(i) || '';\n        var n = str.charAt(i+1) || '';\n        var specialComesNext = (n && specials.indexOf(n) != -1);\n        if (escapeNextChar) {\n          if (c !== '\\\\' || !specialComesNext) {\n            out.push(c);\n          }\n          escapeNextChar = false;\n        } else {\n          if (c === '\\\\') {\n            escapeNextChar = true;\n            // Treat the unescape list as special for removing, but not adding '\\'.\n            if (n && unescape.indexOf(n) != -1) {\n              specialComesNext = true;\n            }\n            // Not passing this test means removing a '\\'.\n            if (!specialComesNext || n === '\\\\') {\n              out.push(c);\n            }\n          } else {\n            out.push(c);\n            if (specialComesNext && n !== '\\\\') {\n              out.push('\\\\');\n            }\n          }\n        }\n      }\n      return out.join('');\n    }\n\n    // Translates the replace part of a search and replace from ex (vim) syntax into\n    // javascript form.  Similar to translateRegex, but additionally fixes back references\n    // (translates '\\[0..9]' to '$[0..9]') and follows different rules for escaping '$'.\n    var charUnescapes = {'\\\\n': '\\n', '\\\\r': '\\r', '\\\\t': '\\t'};\n    function translateRegexReplace(str) {\n      var escapeNextChar = false;\n      var out = [];\n      for (var i = -1; i < str.length; i++) {\n        var c = str.charAt(i) || '';\n        var n = str.charAt(i+1) || '';\n        if (charUnescapes[c + n]) {\n          out.push(charUnescapes[c+n]);\n          i++;\n        } else if (escapeNextChar) {\n          // At any point in the loop, escapeNextChar is true if the previous\n          // character was a '\\' and was not escaped.\n          out.push(c);\n          escapeNextChar = false;\n        } else {\n          if (c === '\\\\') {\n            escapeNextChar = true;\n            if ((isNumber(n) || n === '$')) {\n              out.push('$');\n            } else if (n !== '/' && n !== '\\\\') {\n              out.push('\\\\');\n            }\n          } else {\n            if (c === '$') {\n              out.push('$');\n            }\n            out.push(c);\n            if (n === '/') {\n              out.push('\\\\');\n            }\n          }\n        }\n      }\n      return out.join('');\n    }\n\n    // Unescape \\ and / in the replace part, for PCRE mode.\n    var unescapes = {'\\\\/': '/', '\\\\\\\\': '\\\\', '\\\\n': '\\n', '\\\\r': '\\r', '\\\\t': '\\t'};\n    function unescapeRegexReplace(str) {\n      var stream = new CodeMirror.StringStream(str);\n      var output = [];\n      while (!stream.eol()) {\n        // Search for \\.\n        while (stream.peek() && stream.peek() != '\\\\') {\n          output.push(stream.next());\n        }\n        var matched = false;\n        for (var matcher in unescapes) {\n          if (stream.match(matcher, true)) {\n            matched = true;\n            output.push(unescapes[matcher]);\n            break;\n          }\n        }\n        if (!matched) {\n          // Don't change anything\n          output.push(stream.next());\n        }\n      }\n      return output.join('');\n    }\n\n    /**\n     * Extract the regular expression from the query and return a Regexp object.\n     * Returns null if the query is blank.\n     * If ignoreCase is passed in, the Regexp object will have the 'i' flag set.\n     * If smartCase is passed in, and the query contains upper case letters,\n     *   then ignoreCase is overridden, and the 'i' flag will not be set.\n     * If the query contains the /i in the flag part of the regular expression,\n     *   then both ignoreCase and smartCase are ignored, and 'i' will be passed\n     *   through to the Regex object.\n     */\n    function parseQuery(query, ignoreCase, smartCase) {\n      // First update the last search register\n      var lastSearchRegister = vimGlobalState.registerController.getRegister('/');\n      lastSearchRegister.setText(query);\n      // Check if the query is already a regex.\n      if (query instanceof RegExp) { return query; }\n      // First try to extract regex + flags from the input. If no flags found,\n      // extract just the regex. IE does not accept flags directly defined in\n      // the regex string in the form /regex/flags\n      var slashes = findUnescapedSlashes(query);\n      var regexPart;\n      var forceIgnoreCase;\n      if (!slashes.length) {\n        // Query looks like 'regexp'\n        regexPart = query;\n      } else {\n        // Query looks like 'regexp/...'\n        regexPart = query.substring(0, slashes[0]);\n        var flagsPart = query.substring(slashes[0]);\n        forceIgnoreCase = (flagsPart.indexOf('i') != -1);\n      }\n      if (!regexPart) {\n        return null;\n      }\n      if (!getOption('pcre')) {\n        regexPart = translateRegex(regexPart);\n      }\n      if (smartCase) {\n        ignoreCase = (/^[^A-Z]*$/).test(regexPart);\n      }\n      var regexp = new RegExp(regexPart,\n          (ignoreCase || forceIgnoreCase) ? 'i' : undefined);\n      return regexp;\n    }\n    function showConfirm(cm, text) {\n      if (cm.openNotification) {\n        cm.openNotification('<span style=\"color: red\">' + text + '</span>',\n                            {bottom: true, duration: 5000});\n      } else {\n        alert(text);\n      }\n    }\n    function makePrompt(prefix, desc) {\n      var raw = '<span style=\"font-family: monospace; white-space: pre\">' +\n          (prefix || \"\") + '<input type=\"text\"></span>';\n      if (desc)\n        raw += ' <span style=\"color: #888\">' + desc + '</span>';\n      return raw;\n    }\n    var searchPromptDesc = '(Javascript regexp)';\n    function showPrompt(cm, options) {\n      var shortText = (options.prefix || '') + ' ' + (options.desc || '');\n      var prompt = makePrompt(options.prefix, options.desc);\n      dialog(cm, prompt, shortText, options.onClose, options);\n    }\n    function regexEqual(r1, r2) {\n      if (r1 instanceof RegExp && r2 instanceof RegExp) {\n          var props = ['global', 'multiline', 'ignoreCase', 'source'];\n          for (var i = 0; i < props.length; i++) {\n              var prop = props[i];\n              if (r1[prop] !== r2[prop]) {\n                  return false;\n              }\n          }\n          return true;\n      }\n      return false;\n    }\n    // Returns true if the query is valid.\n    function updateSearchQuery(cm, rawQuery, ignoreCase, smartCase) {\n      if (!rawQuery) {\n        return;\n      }\n      var state = getSearchState(cm);\n      var query = parseQuery(rawQuery, !!ignoreCase, !!smartCase);\n      if (!query) {\n        return;\n      }\n      highlightSearchMatches(cm, query);\n      if (regexEqual(query, state.getQuery())) {\n        return query;\n      }\n      state.setQuery(query);\n      return query;\n    }\n    function searchOverlay(query) {\n      if (query.source.charAt(0) == '^') {\n        var matchSol = true;\n      }\n      return {\n        token: function(stream) {\n          if (matchSol && !stream.sol()) {\n            stream.skipToEnd();\n            return;\n          }\n          var match = stream.match(query, false);\n          if (match) {\n            if (match[0].length == 0) {\n              // Matched empty string, skip to next.\n              stream.next();\n              return 'searching';\n            }\n            if (!stream.sol()) {\n              // Backtrack 1 to match \\b\n              stream.backUp(1);\n              if (!query.exec(stream.next() + match[0])) {\n                stream.next();\n                return null;\n              }\n            }\n            stream.match(query);\n            return 'searching';\n          }\n          while (!stream.eol()) {\n            stream.next();\n            if (stream.match(query, false)) break;\n          }\n        },\n        query: query\n      };\n    }\n    function highlightSearchMatches(cm, query) {\n      var searchState = getSearchState(cm);\n      var overlay = searchState.getOverlay();\n      if (!overlay || query != overlay.query) {\n        if (overlay) {\n          cm.removeOverlay(overlay);\n        }\n        overlay = searchOverlay(query);\n        cm.addOverlay(overlay);\n        if (cm.showMatchesOnScrollbar) {\n          if (searchState.getScrollbarAnnotate()) {\n            searchState.getScrollbarAnnotate().clear();\n          }\n          searchState.setScrollbarAnnotate(cm.showMatchesOnScrollbar(query));\n        }\n        searchState.setOverlay(overlay);\n      }\n    }\n    function findNext(cm, prev, query, repeat) {\n      if (repeat === undefined) { repeat = 1; }\n      return cm.operation(function() {\n        var pos = cm.getCursor();\n        var cursor = cm.getSearchCursor(query, pos);\n        for (var i = 0; i < repeat; i++) {\n          var found = cursor.find(prev);\n          if (i == 0 && found && cursorEqual(cursor.from(), pos)) { found = cursor.find(prev); }\n          if (!found) {\n            // SearchCursor may have returned null because it hit EOF, wrap\n            // around and try again.\n            cursor = cm.getSearchCursor(query,\n                (prev) ? Pos(cm.lastLine()) : Pos(cm.firstLine(), 0) );\n            if (!cursor.find(prev)) {\n              return;\n            }\n          }\n        }\n        return cursor.from();\n      });\n    }\n    function clearSearchHighlight(cm) {\n      var state = getSearchState(cm);\n      cm.removeOverlay(getSearchState(cm).getOverlay());\n      state.setOverlay(null);\n      if (state.getScrollbarAnnotate()) {\n        state.getScrollbarAnnotate().clear();\n        state.setScrollbarAnnotate(null);\n      }\n    }\n    /**\n     * Check if pos is in the specified range, INCLUSIVE.\n     * Range can be specified with 1 or 2 arguments.\n     * If the first range argument is an array, treat it as an array of line\n     * numbers. Match pos against any of the lines.\n     * If the first range argument is a number,\n     *   if there is only 1 range argument, check if pos has the same line\n     *       number\n     *   if there are 2 range arguments, then check if pos is in between the two\n     *       range arguments.\n     */\n    function isInRange(pos, start, end) {\n      if (typeof pos != 'number') {\n        // Assume it is a cursor position. Get the line number.\n        pos = pos.line;\n      }\n      if (start instanceof Array) {\n        return inArray(pos, start);\n      } else {\n        if (end) {\n          return (pos >= start && pos <= end);\n        } else {\n          return pos == start;\n        }\n      }\n    }\n    function getUserVisibleLines(cm) {\n      var scrollInfo = cm.getScrollInfo();\n      var occludeToleranceTop = 6;\n      var occludeToleranceBottom = 10;\n      var from = cm.coordsChar({left:0, top: occludeToleranceTop + scrollInfo.top}, 'local');\n      var bottomY = scrollInfo.clientHeight - occludeToleranceBottom + scrollInfo.top;\n      var to = cm.coordsChar({left:0, top: bottomY}, 'local');\n      return {top: from.line, bottom: to.line};\n    }\n\n    function getMarkPos(cm, vim, markName) {\n      if (markName == '\\'') {\n        var history = cm.doc.history.done;\n        var event = history[history.length - 2];\n        return event && event.ranges && event.ranges[0].head;\n      } else if (markName == '.') {\n        if (cm.doc.history.lastModTime == 0) {\n          return  // If no changes, bail out; don't bother to copy or reverse history array.\n        } else {\n          var changeHistory = cm.doc.history.done.filter(function(el){ if (el.changes !== undefined) { return el } });\n          changeHistory.reverse();\n          var lastEditPos = changeHistory[0].changes[0].to;\n        }\n        return lastEditPos;\n      }\n\n      var mark = vim.marks[markName];\n      return mark && mark.find();\n    }\n\n    var ExCommandDispatcher = function() {\n      this.buildCommandMap_();\n    };\n    ExCommandDispatcher.prototype = {\n      processCommand: function(cm, input, opt_params) {\n        var that = this;\n        cm.operation(function () {\n          cm.curOp.isVimOp = true;\n          that._processCommand(cm, input, opt_params);\n        });\n      },\n      _processCommand: function(cm, input, opt_params) {\n        var vim = cm.state.vim;\n        var commandHistoryRegister = vimGlobalState.registerController.getRegister(':');\n        var previousCommand = commandHistoryRegister.toString();\n        if (vim.visualMode) {\n          exitVisualMode(cm);\n        }\n        var inputStream = new CodeMirror.StringStream(input);\n        // update \": with the latest command whether valid or invalid\n        commandHistoryRegister.setText(input);\n        var params = opt_params || {};\n        params.input = input;\n        try {\n          this.parseInput_(cm, inputStream, params);\n        } catch(e) {\n          showConfirm(cm, e);\n          throw e;\n        }\n        var command;\n        var commandName;\n        if (!params.commandName) {\n          // If only a line range is defined, move to the line.\n          if (params.line !== undefined) {\n            commandName = 'move';\n          }\n        } else {\n          command = this.matchCommand_(params.commandName);\n          if (command) {\n            commandName = command.name;\n            if (command.excludeFromCommandHistory) {\n              commandHistoryRegister.setText(previousCommand);\n            }\n            this.parseCommandArgs_(inputStream, params, command);\n            if (command.type == 'exToKey') {\n              // Handle Ex to Key mapping.\n              for (var i = 0; i < command.toKeys.length; i++) {\n                CodeMirror.Vim.handleKey(cm, command.toKeys[i], 'mapping');\n              }\n              return;\n            } else if (command.type == 'exToEx') {\n              // Handle Ex to Ex mapping.\n              this.processCommand(cm, command.toInput);\n              return;\n            }\n          }\n        }\n        if (!commandName) {\n          showConfirm(cm, 'Not an editor command \":' + input + '\"');\n          return;\n        }\n        try {\n          exCommands[commandName](cm, params);\n          // Possibly asynchronous commands (e.g. substitute, which might have a\n          // user confirmation), are responsible for calling the callback when\n          // done. All others have it taken care of for them here.\n          if ((!command || !command.possiblyAsync) && params.callback) {\n            params.callback();\n          }\n        } catch(e) {\n          showConfirm(cm, e);\n          throw e;\n        }\n      },\n      parseInput_: function(cm, inputStream, result) {\n        inputStream.eatWhile(':');\n        // Parse range.\n        if (inputStream.eat('%')) {\n          result.line = cm.firstLine();\n          result.lineEnd = cm.lastLine();\n        } else {\n          result.line = this.parseLineSpec_(cm, inputStream);\n          if (result.line !== undefined && inputStream.eat(',')) {\n            result.lineEnd = this.parseLineSpec_(cm, inputStream);\n          }\n        }\n\n        // Parse command name.\n        var commandMatch = inputStream.match(/^(\\w+)/);\n        if (commandMatch) {\n          result.commandName = commandMatch[1];\n        } else {\n          result.commandName = inputStream.match(/.*/)[0];\n        }\n\n        return result;\n      },\n      parseLineSpec_: function(cm, inputStream) {\n        var numberMatch = inputStream.match(/^(\\d+)/);\n        if (numberMatch) {\n          // Absolute line number plus offset (N+M or N-M) is probably a typo,\n          // not something the user actually wanted. (NB: vim does allow this.)\n          return parseInt(numberMatch[1], 10) - 1;\n        }\n        switch (inputStream.next()) {\n          case '.':\n            return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n          case '$':\n            return this.parseLineSpecOffset_(inputStream, cm.lastLine());\n          case '\\'':\n            var markName = inputStream.next();\n            var markPos = getMarkPos(cm, cm.state.vim, markName);\n            if (!markPos) throw new Error('Mark not set');\n            return this.parseLineSpecOffset_(inputStream, markPos.line);\n          case '-':\n          case '+':\n            inputStream.backUp(1);\n            // Offset is relative to current line if not otherwise specified.\n            return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n          default:\n            inputStream.backUp(1);\n            return undefined;\n        }\n      },\n      parseLineSpecOffset_: function(inputStream, line) {\n        var offsetMatch = inputStream.match(/^([+-])?(\\d+)/);\n        if (offsetMatch) {\n          var offset = parseInt(offsetMatch[2], 10);\n          if (offsetMatch[1] == \"-\") {\n            line -= offset;\n          } else {\n            line += offset;\n          }\n        }\n        return line;\n      },\n      parseCommandArgs_: function(inputStream, params, command) {\n        if (inputStream.eol()) {\n          return;\n        }\n        params.argString = inputStream.match(/.*/)[0];\n        // Parse command-line arguments\n        var delim = command.argDelimiter || /\\s+/;\n        var args = trim(params.argString).split(delim);\n        if (args.length && args[0]) {\n          params.args = args;\n        }\n      },\n      matchCommand_: function(commandName) {\n        // Return the command in the command map that matches the shortest\n        // prefix of the passed in command name. The match is guaranteed to be\n        // unambiguous if the defaultExCommandMap's shortNames are set up\n        // correctly. (see @code{defaultExCommandMap}).\n        for (var i = commandName.length; i > 0; i--) {\n          var prefix = commandName.substring(0, i);\n          if (this.commandMap_[prefix]) {\n            var command = this.commandMap_[prefix];\n            if (command.name.indexOf(commandName) === 0) {\n              return command;\n            }\n          }\n        }\n        return null;\n      },\n      buildCommandMap_: function() {\n        this.commandMap_ = {};\n        for (var i = 0; i < defaultExCommandMap.length; i++) {\n          var command = defaultExCommandMap[i];\n          var key = command.shortName || command.name;\n          this.commandMap_[key] = command;\n        }\n      },\n      map: function(lhs, rhs, ctx) {\n        if (lhs != ':' && lhs.charAt(0) == ':') {\n          if (ctx) { throw Error('Mode not supported for ex mappings'); }\n          var commandName = lhs.substring(1);\n          if (rhs != ':' && rhs.charAt(0) == ':') {\n            // Ex to Ex mapping\n            this.commandMap_[commandName] = {\n              name: commandName,\n              type: 'exToEx',\n              toInput: rhs.substring(1),\n              user: true\n            };\n          } else {\n            // Ex to key mapping\n            this.commandMap_[commandName] = {\n              name: commandName,\n              type: 'exToKey',\n              toKeys: rhs,\n              user: true\n            };\n          }\n        } else {\n          if (rhs != ':' && rhs.charAt(0) == ':') {\n            // Key to Ex mapping.\n            var mapping = {\n              keys: lhs,\n              type: 'keyToEx',\n              exArgs: { input: rhs.substring(1) }\n            };\n            if (ctx) { mapping.context = ctx; }\n            defaultKeymap.unshift(mapping);\n          } else {\n            // Key to key mapping\n            var mapping = {\n              keys: lhs,\n              type: 'keyToKey',\n              toKeys: rhs\n            };\n            if (ctx) { mapping.context = ctx; }\n            defaultKeymap.unshift(mapping);\n          }\n        }\n      },\n      unmap: function(lhs, ctx) {\n        if (lhs != ':' && lhs.charAt(0) == ':') {\n          // Ex to Ex or Ex to key mapping\n          if (ctx) { throw Error('Mode not supported for ex mappings'); }\n          var commandName = lhs.substring(1);\n          if (this.commandMap_[commandName] && this.commandMap_[commandName].user) {\n            delete this.commandMap_[commandName];\n            return;\n          }\n        } else {\n          // Key to Ex or key to key mapping\n          var keys = lhs;\n          for (var i = 0; i < defaultKeymap.length; i++) {\n            if (keys == defaultKeymap[i].keys\n                && defaultKeymap[i].context === ctx) {\n              defaultKeymap.splice(i, 1);\n              return;\n            }\n          }\n        }\n        throw Error('No such mapping.');\n      }\n    };\n\n    var exCommands = {\n      colorscheme: function(cm, params) {\n        if (!params.args || params.args.length < 1) {\n          showConfirm(cm, cm.getOption('theme'));\n          return;\n        }\n        cm.setOption('theme', params.args[0]);\n      },\n      map: function(cm, params, ctx) {\n        var mapArgs = params.args;\n        if (!mapArgs || mapArgs.length < 2) {\n          if (cm) {\n            showConfirm(cm, 'Invalid mapping: ' + params.input);\n          }\n          return;\n        }\n        exCommandDispatcher.map(mapArgs[0], mapArgs[1], ctx);\n      },\n      imap: function(cm, params) { this.map(cm, params, 'insert'); },\n      nmap: function(cm, params) { this.map(cm, params, 'normal'); },\n      vmap: function(cm, params) { this.map(cm, params, 'visual'); },\n      unmap: function(cm, params, ctx) {\n        var mapArgs = params.args;\n        if (!mapArgs || mapArgs.length < 1) {\n          if (cm) {\n            showConfirm(cm, 'No such mapping: ' + params.input);\n          }\n          return;\n        }\n        exCommandDispatcher.unmap(mapArgs[0], ctx);\n      },\n      move: function(cm, params) {\n        commandDispatcher.processCommand(cm, cm.state.vim, {\n            type: 'motion',\n            motion: 'moveToLineOrEdgeOfDocument',\n            motionArgs: { forward: false, explicitRepeat: true,\n              linewise: true },\n            repeatOverride: params.line+1});\n      },\n      set: function(cm, params) {\n        var setArgs = params.args;\n        // Options passed through to the setOption/getOption calls. May be passed in by the\n        // local/global versions of the set command\n        var setCfg = params.setCfg || {};\n        if (!setArgs || setArgs.length < 1) {\n          if (cm) {\n            showConfirm(cm, 'Invalid mapping: ' + params.input);\n          }\n          return;\n        }\n        var expr = setArgs[0].split('=');\n        var optionName = expr[0];\n        var value = expr[1];\n        var forceGet = false;\n\n        if (optionName.charAt(optionName.length - 1) == '?') {\n          // If post-fixed with ?, then the set is actually a get.\n          if (value) { throw Error('Trailing characters: ' + params.argString); }\n          optionName = optionName.substring(0, optionName.length - 1);\n          forceGet = true;\n        }\n        if (value === undefined && optionName.substring(0, 2) == 'no') {\n          // To set boolean options to false, the option name is prefixed with\n          // 'no'.\n          optionName = optionName.substring(2);\n          value = false;\n        }\n\n        var optionIsBoolean = options[optionName] && options[optionName].type == 'boolean';\n        if (optionIsBoolean && value == undefined) {\n          // Calling set with a boolean option sets it to true.\n          value = true;\n        }\n        // If no value is provided, then we assume this is a get.\n        if (!optionIsBoolean && value === undefined || forceGet) {\n          var oldValue = getOption(optionName, cm, setCfg);\n          if (oldValue instanceof Error) {\n            showConfirm(cm, oldValue.message);\n          } else if (oldValue === true || oldValue === false) {\n            showConfirm(cm, ' ' + (oldValue ? '' : 'no') + optionName);\n          } else {\n            showConfirm(cm, '  ' + optionName + '=' + oldValue);\n          }\n        } else {\n          var setOptionReturn = setOption(optionName, value, cm, setCfg);\n          if (setOptionReturn instanceof Error) {\n            showConfirm(cm, setOptionReturn.message);\n          }\n        }\n      },\n      setlocal: function (cm, params) {\n        // setCfg is passed through to setOption\n        params.setCfg = {scope: 'local'};\n        this.set(cm, params);\n      },\n      setglobal: function (cm, params) {\n        // setCfg is passed through to setOption\n        params.setCfg = {scope: 'global'};\n        this.set(cm, params);\n      },\n      registers: function(cm, params) {\n        var regArgs = params.args;\n        var registers = vimGlobalState.registerController.registers;\n        var regInfo = '----------Registers----------<br><br>';\n        if (!regArgs) {\n          for (var registerName in registers) {\n            var text = registers[registerName].toString();\n            if (text.length) {\n              regInfo += '\"' + registerName + '    ' + text + '<br>';\n            }\n          }\n        } else {\n          var registerName;\n          regArgs = regArgs.join('');\n          for (var i = 0; i < regArgs.length; i++) {\n            registerName = regArgs.charAt(i);\n            if (!vimGlobalState.registerController.isValidRegister(registerName)) {\n              continue;\n            }\n            var register = registers[registerName] || new Register();\n            regInfo += '\"' + registerName + '    ' + register.toString() + '<br>';\n          }\n        }\n        showConfirm(cm, regInfo);\n      },\n      sort: function(cm, params) {\n        var reverse, ignoreCase, unique, number, pattern;\n        function parseArgs() {\n          if (params.argString) {\n            var args = new CodeMirror.StringStream(params.argString);\n            if (args.eat('!')) { reverse = true; }\n            if (args.eol()) { return; }\n            if (!args.eatSpace()) { return 'Invalid arguments'; }\n            var opts = args.match(/([dinuox]+)?\\s*(\\/.+\\/)?\\s*/);\n            if (!opts && !args.eol()) { return 'Invalid arguments'; }\n            if (opts[1]) {\n              ignoreCase = opts[1].indexOf('i') != -1;\n              unique = opts[1].indexOf('u') != -1;\n              var decimal = opts[1].indexOf('d') != -1 || opts[1].indexOf('n') != -1 && 1;\n              var hex = opts[1].indexOf('x') != -1 && 1;\n              var octal = opts[1].indexOf('o') != -1 && 1;\n              if (decimal + hex + octal > 1) { return 'Invalid arguments'; }\n              number = decimal && 'decimal' || hex && 'hex' || octal && 'octal';\n            }\n            if (opts[2]) {\n              pattern = new RegExp(opts[2].substr(1, opts[2].length - 2), ignoreCase ? 'i' : '');\n            }\n          }\n        }\n        var err = parseArgs();\n        if (err) {\n          showConfirm(cm, err + ': ' + params.argString);\n          return;\n        }\n        var lineStart = params.line || cm.firstLine();\n        var lineEnd = params.lineEnd || params.line || cm.lastLine();\n        if (lineStart == lineEnd) { return; }\n        var curStart = Pos(lineStart, 0);\n        var curEnd = Pos(lineEnd, lineLength(cm, lineEnd));\n        var text = cm.getRange(curStart, curEnd).split('\\n');\n        var numberRegex = pattern ? pattern :\n           (number == 'decimal') ? /(-?)([\\d]+)/ :\n           (number == 'hex') ? /(-?)(?:0x)?([0-9a-f]+)/i :\n           (number == 'octal') ? /([0-7]+)/ : null;\n        var radix = (number == 'decimal') ? 10 : (number == 'hex') ? 16 : (number == 'octal') ? 8 : null;\n        var numPart = [], textPart = [];\n        if (number || pattern) {\n          for (var i = 0; i < text.length; i++) {\n            var matchPart = pattern ? text[i].match(pattern) : null;\n            if (matchPart && matchPart[0] != '') {\n              numPart.push(matchPart);\n            } else if (!pattern && numberRegex.exec(text[i])) {\n              numPart.push(text[i]);\n            } else {\n              textPart.push(text[i]);\n            }\n          }\n        } else {\n          textPart = text;\n        }\n        function compareFn(a, b) {\n          if (reverse) { var tmp; tmp = a; a = b; b = tmp; }\n          if (ignoreCase) { a = a.toLowerCase(); b = b.toLowerCase(); }\n          var anum = number && numberRegex.exec(a);\n          var bnum = number && numberRegex.exec(b);\n          if (!anum) { return a < b ? -1 : 1; }\n          anum = parseInt((anum[1] + anum[2]).toLowerCase(), radix);\n          bnum = parseInt((bnum[1] + bnum[2]).toLowerCase(), radix);\n          return anum - bnum;\n        }\n        function comparePatternFn(a, b) {\n          if (reverse) { var tmp; tmp = a; a = b; b = tmp; }\n          if (ignoreCase) { a[0] = a[0].toLowerCase(); b[0] = b[0].toLowerCase(); }\n          return (a[0] < b[0]) ? -1 : 1;\n        }\n        numPart.sort(pattern ? comparePatternFn : compareFn);\n        if (pattern) {\n          for (var i = 0; i < numPart.length; i++) {\n            numPart[i] = numPart[i].input;\n          }\n        } else if (!number) { textPart.sort(compareFn); }\n        text = (!reverse) ? textPart.concat(numPart) : numPart.concat(textPart);\n        if (unique) { // Remove duplicate lines\n          var textOld = text;\n          var lastLine;\n          text = [];\n          for (var i = 0; i < textOld.length; i++) {\n            if (textOld[i] != lastLine) {\n              text.push(textOld[i]);\n            }\n            lastLine = textOld[i];\n          }\n        }\n        cm.replaceRange(text.join('\\n'), curStart, curEnd);\n      },\n      global: function(cm, params) {\n        // a global command is of the form\n        // :[range]g/pattern/[cmd]\n        // argString holds the string /pattern/[cmd]\n        var argString = params.argString;\n        if (!argString) {\n          showConfirm(cm, 'Regular Expression missing from global');\n          return;\n        }\n        // range is specified here\n        var lineStart = (params.line !== undefined) ? params.line : cm.firstLine();\n        var lineEnd = params.lineEnd || params.line || cm.lastLine();\n        // get the tokens from argString\n        var tokens = splitBySlash(argString);\n        var regexPart = argString, cmd;\n        if (tokens.length) {\n          regexPart = tokens[0];\n          cmd = tokens.slice(1, tokens.length).join('/');\n        }\n        if (regexPart) {\n          // If regex part is empty, then use the previous query. Otherwise\n          // use the regex part as the new query.\n          try {\n           updateSearchQuery(cm, regexPart, true /** ignoreCase */,\n             true /** smartCase */);\n          } catch (e) {\n           showConfirm(cm, 'Invalid regex: ' + regexPart);\n           return;\n          }\n        }\n        // now that we have the regexPart, search for regex matches in the\n        // specified range of lines\n        var query = getSearchState(cm).getQuery();\n        var matchedLines = [], content = '';\n        for (var i = lineStart; i <= lineEnd; i++) {\n          var matched = query.test(cm.getLine(i));\n          if (matched) {\n            matchedLines.push(i+1);\n            content+= cm.getLine(i) + '<br>';\n          }\n        }\n        // if there is no [cmd], just display the list of matched lines\n        if (!cmd) {\n          showConfirm(cm, content);\n          return;\n        }\n        var index = 0;\n        var nextCommand = function() {\n          if (index < matchedLines.length) {\n            var command = matchedLines[index] + cmd;\n            exCommandDispatcher.processCommand(cm, command, {\n              callback: nextCommand\n            });\n          }\n          index++;\n        };\n        nextCommand();\n      },\n      substitute: function(cm, params) {\n        if (!cm.getSearchCursor) {\n          throw new Error('Search feature not available. Requires searchcursor.js or ' +\n              'any other getSearchCursor implementation.');\n        }\n        var argString = params.argString;\n        var tokens = argString ? splitBySeparator(argString, argString[0]) : [];\n        var regexPart, replacePart = '', trailing, flagsPart, count;\n        var confirm = false; // Whether to confirm each replace.\n        var global = false; // True to replace all instances on a line, false to replace only 1.\n        if (tokens.length) {\n          regexPart = tokens[0];\n          replacePart = tokens[1];\n          if (regexPart && regexPart[regexPart.length - 1] === '$') {\n            regexPart = regexPart.slice(0, regexPart.length - 1) + '\\\\n';\n            replacePart = replacePart ? replacePart + '\\n' : '\\n';\n          }\n          if (replacePart !== undefined) {\n            if (getOption('pcre')) {\n              replacePart = unescapeRegexReplace(replacePart);\n            } else {\n              replacePart = translateRegexReplace(replacePart);\n            }\n            vimGlobalState.lastSubstituteReplacePart = replacePart;\n          }\n          trailing = tokens[2] ? tokens[2].split(' ') : [];\n        } else {\n          // either the argString is empty or its of the form ' hello/world'\n          // actually splitBySlash returns a list of tokens\n          // only if the string starts with a '/'\n          if (argString && argString.length) {\n            showConfirm(cm, 'Substitutions should be of the form ' +\n                ':s/pattern/replace/');\n            return;\n          }\n        }\n        // After the 3rd slash, we can have flags followed by a space followed\n        // by count.\n        if (trailing) {\n          flagsPart = trailing[0];\n          count = parseInt(trailing[1]);\n          if (flagsPart) {\n            if (flagsPart.indexOf('c') != -1) {\n              confirm = true;\n              flagsPart.replace('c', '');\n            }\n            if (flagsPart.indexOf('g') != -1) {\n              global = true;\n              flagsPart.replace('g', '');\n            }\n            regexPart = regexPart.replace(/\\//g, \"\\\\/\") + '/' + flagsPart;\n          }\n        }\n        if (regexPart) {\n          // If regex part is empty, then use the previous query. Otherwise use\n          // the regex part as the new query.\n          try {\n            updateSearchQuery(cm, regexPart, true /** ignoreCase */,\n              true /** smartCase */);\n          } catch (e) {\n            showConfirm(cm, 'Invalid regex: ' + regexPart);\n            return;\n          }\n        }\n        replacePart = replacePart || vimGlobalState.lastSubstituteReplacePart;\n        if (replacePart === undefined) {\n          showConfirm(cm, 'No previous substitute regular expression');\n          return;\n        }\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n        var lineStart = (params.line !== undefined) ? params.line : cm.getCursor().line;\n        var lineEnd = params.lineEnd || lineStart;\n        if (lineStart == cm.firstLine() && lineEnd == cm.lastLine()) {\n          lineEnd = Infinity;\n        }\n        if (count) {\n          lineStart = lineEnd;\n          lineEnd = lineStart + count - 1;\n        }\n        var startPos = clipCursorToContent(cm, Pos(lineStart, 0));\n        var cursor = cm.getSearchCursor(query, startPos);\n        doReplace(cm, confirm, global, lineStart, lineEnd, cursor, query, replacePart, params.callback);\n      },\n      redo: CodeMirror.commands.redo,\n      undo: CodeMirror.commands.undo,\n      write: function(cm) {\n        if (CodeMirror.commands.save) {\n          // If a save command is defined, call it.\n          CodeMirror.commands.save(cm);\n        } else if (cm.save) {\n          // Saves to text area if no save command is defined and cm.save() is available.\n          cm.save();\n        }\n      },\n      nohlsearch: function(cm) {\n        clearSearchHighlight(cm);\n      },\n      yank: function (cm) {\n        var cur = copyCursor(cm.getCursor());\n        var line = cur.line;\n        var lineText = cm.getLine(line);\n        vimGlobalState.registerController.pushText(\n          '0', 'yank', lineText, true, true);\n      },\n      delmarks: function(cm, params) {\n        if (!params.argString || !trim(params.argString)) {\n          showConfirm(cm, 'Argument required');\n          return;\n        }\n\n        var state = cm.state.vim;\n        var stream = new CodeMirror.StringStream(trim(params.argString));\n        while (!stream.eol()) {\n          stream.eatSpace();\n\n          // Record the streams position at the beginning of the loop for use\n          // in error messages.\n          var count = stream.pos;\n\n          if (!stream.match(/[a-zA-Z]/, false)) {\n            showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n            return;\n          }\n\n          var sym = stream.next();\n          // Check if this symbol is part of a range\n          if (stream.match('-', true)) {\n            // This symbol is part of a range.\n\n            // The range must terminate at an alphabetic character.\n            if (!stream.match(/[a-zA-Z]/, false)) {\n              showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n              return;\n            }\n\n            var startMark = sym;\n            var finishMark = stream.next();\n            // The range must terminate at an alphabetic character which\n            // shares the same case as the start of the range.\n            if (isLowerCase(startMark) && isLowerCase(finishMark) ||\n                isUpperCase(startMark) && isUpperCase(finishMark)) {\n              var start = startMark.charCodeAt(0);\n              var finish = finishMark.charCodeAt(0);\n              if (start >= finish) {\n                showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n                return;\n              }\n\n              // Because marks are always ASCII values, and we have\n              // determined that they are the same case, we can use\n              // their char codes to iterate through the defined range.\n              for (var j = 0; j <= finish - start; j++) {\n                var mark = String.fromCharCode(start + j);\n                delete state.marks[mark];\n              }\n            } else {\n              showConfirm(cm, 'Invalid argument: ' + startMark + '-');\n              return;\n            }\n          } else {\n            // This symbol is a valid mark, and is not part of a range.\n            delete state.marks[sym];\n          }\n        }\n      }\n    };\n\n    var exCommandDispatcher = new ExCommandDispatcher();\n\n    /**\n    * @param {CodeMirror} cm CodeMirror instance we are in.\n    * @param {boolean} confirm Whether to confirm each replace.\n    * @param {Cursor} lineStart Line to start replacing from.\n    * @param {Cursor} lineEnd Line to stop replacing at.\n    * @param {RegExp} query Query for performing matches with.\n    * @param {string} replaceWith Text to replace matches with. May contain $1,\n    *     $2, etc for replacing captured groups using Javascript replace.\n    * @param {function()} callback A callback for when the replace is done.\n    */\n    function doReplace(cm, confirm, global, lineStart, lineEnd, searchCursor, query,\n        replaceWith, callback) {\n      // Set up all the functions.\n      cm.state.vim.exMode = true;\n      var done = false;\n      var lastPos = searchCursor.from();\n      function replaceAll() {\n        cm.operation(function() {\n          while (!done) {\n            replace();\n            next();\n          }\n          stop();\n        });\n      }\n      function replace() {\n        var text = cm.getRange(searchCursor.from(), searchCursor.to());\n        var newText = text.replace(query, replaceWith);\n        searchCursor.replace(newText);\n      }\n      function next() {\n        // The below only loops to skip over multiple occurrences on the same\n        // line when 'global' is not true.\n        while(searchCursor.findNext() &&\n              isInRange(searchCursor.from(), lineStart, lineEnd)) {\n          if (!global && lastPos && searchCursor.from().line == lastPos.line) {\n            continue;\n          }\n          cm.scrollIntoView(searchCursor.from(), 30);\n          cm.setSelection(searchCursor.from(), searchCursor.to());\n          lastPos = searchCursor.from();\n          done = false;\n          return;\n        }\n        done = true;\n      }\n      function stop(close) {\n        if (close) { close(); }\n        cm.focus();\n        if (lastPos) {\n          cm.setCursor(lastPos);\n          var vim = cm.state.vim;\n          vim.exMode = false;\n          vim.lastHPos = vim.lastHSPos = lastPos.ch;\n        }\n        if (callback) { callback(); }\n      }\n      function onPromptKeyDown(e, _value, close) {\n        // Swallow all keys.\n        CodeMirror.e_stop(e);\n        var keyName = CodeMirror.keyName(e);\n        switch (keyName) {\n          case 'Y':\n            replace(); next(); break;\n          case 'N':\n            next(); break;\n          case 'A':\n            // replaceAll contains a call to close of its own. We don't want it\n            // to fire too early or multiple times.\n            var savedCallback = callback;\n            callback = undefined;\n            cm.operation(replaceAll);\n            callback = savedCallback;\n            break;\n          case 'L':\n            replace();\n            // fall through and exit.\n          case 'Q':\n          case 'Esc':\n          case 'Ctrl-C':\n          case 'Ctrl-[':\n            stop(close);\n            break;\n        }\n        if (done) { stop(close); }\n        return true;\n      }\n\n      // Actually do replace.\n      next();\n      if (done) {\n        showConfirm(cm, 'No matches for ' + query.source);\n        return;\n      }\n      if (!confirm) {\n        replaceAll();\n        if (callback) { callback(); }\n        return;\n      }\n      showPrompt(cm, {\n        prefix: 'replace with <strong>' + replaceWith + '</strong> (y/n/a/q/l)',\n        onKeyDown: onPromptKeyDown\n      });\n    }\n\n    CodeMirror.keyMap.vim = {\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n\n    function exitInsertMode(cm) {\n      var vim = cm.state.vim;\n      var macroModeState = vimGlobalState.macroModeState;\n      var insertModeChangeRegister = vimGlobalState.registerController.getRegister('.');\n      var isPlaying = macroModeState.isPlaying;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      // In case of visual block, the insertModeChanges are not saved as a\n      // single word, so we convert them to a single word\n      // so as to update the \". register as expected in real vim.\n      var text = [];\n      if (!isPlaying) {\n        var selLength = lastChange.inVisualBlock && vim.lastSelection ?\n            vim.lastSelection.visualBlock.height : 1;\n        var changes = lastChange.changes;\n        var text = [];\n        var i = 0;\n        // In case of multiple selections in blockwise visual,\n        // the inserted text, for example: 'f<Backspace>oo', is stored as\n        // 'f', 'f', InsertModeKey 'o', 'o', 'o', 'o'. (if you have a block with 2 lines).\n        // We push the contents of the changes array as per the following:\n        // 1. In case of InsertModeKey, just increment by 1.\n        // 2. In case of a character, jump by selLength (2 in the example).\n        while (i < changes.length) {\n          // This loop will convert 'ff<bs>oooo' to 'f<bs>oo'.\n          text.push(changes[i]);\n          if (changes[i] instanceof InsertModeKey) {\n             i++;\n          } else {\n             i+= selLength;\n          }\n        }\n        lastChange.changes = text;\n        cm.off('change', onChange);\n        CodeMirror.off(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n      }\n      if (!isPlaying && vim.insertModeRepeat > 1) {\n        // Perform insert mode repeat for commands like 3,a and 3,o.\n        repeatLastEdit(cm, vim, vim.insertModeRepeat - 1,\n            true /** repeatForInsert */);\n        vim.lastEditInputState.repeatOverride = vim.insertModeRepeat;\n      }\n      delete vim.insertModeRepeat;\n      vim.insertMode = false;\n      cm.setCursor(cm.getCursor().line, cm.getCursor().ch-1);\n      cm.setOption('keyMap', 'vim');\n      cm.setOption('disableInput', true);\n      cm.toggleOverwrite(false); // exit replace mode if we were in it.\n      // update the \". register before exiting insert mode\n      insertModeChangeRegister.setText(lastChange.changes.join(''));\n      CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n      if (macroModeState.isRecording) {\n        logInsertModeChange(macroModeState);\n      }\n    }\n\n    function _mapCommand(command) {\n      defaultKeymap.unshift(command);\n    }\n\n    function mapCommand(keys, type, name, args, extra) {\n      var command = {keys: keys, type: type};\n      command[type] = name;\n      command[type + \"Args\"] = args;\n      for (var key in extra)\n        command[key] = extra[key];\n      _mapCommand(command);\n    }\n\n    // The timeout in milliseconds for the two-character ESC keymap should be\n    // adjusted according to your typing speed to prevent false positives.\n    defineOption('insertModeEscKeysTimeout', 200, 'number');\n\n    CodeMirror.keyMap['vim-insert'] = {\n      // TODO: override navigation keys so that Esc will cancel automatic\n      // indentation from o, O, i_<CR>\n      fallthrough: ['default'],\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n\n    CodeMirror.keyMap['vim-replace'] = {\n      'Backspace': 'goCharLeft',\n      fallthrough: ['vim-insert'],\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n\n    function executeMacroRegister(cm, vim, macroModeState, registerName) {\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (registerName == ':') {\n        // Read-only register containing last Ex command.\n        if (register.keyBuffer[0]) {\n          exCommandDispatcher.processCommand(cm, register.keyBuffer[0]);\n        }\n        macroModeState.isPlaying = false;\n        return;\n      }\n      var keyBuffer = register.keyBuffer;\n      var imc = 0;\n      macroModeState.isPlaying = true;\n      macroModeState.replaySearchQueries = register.searchQueries.slice(0);\n      for (var i = 0; i < keyBuffer.length; i++) {\n        var text = keyBuffer[i];\n        var match, key;\n        while (text) {\n          // Pull off one command key, which is either a single character\n          // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.\n          match = (/<\\w+-.+?>|<\\w+>|./).exec(text);\n          key = match[0];\n          text = text.substring(match.index + key.length);\n          CodeMirror.Vim.handleKey(cm, key, 'macro');\n          if (vim.insertMode) {\n            var changes = register.insertModeChanges[imc++].changes;\n            vimGlobalState.macroModeState.lastInsertModeChanges.changes =\n                changes;\n            repeatInsertModeChanges(cm, changes, 1);\n            exitInsertMode(cm);\n          }\n        }\n      }\n      macroModeState.isPlaying = false;\n    }\n\n    function logKey(macroModeState, key) {\n      if (macroModeState.isPlaying) { return; }\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register) {\n        register.pushText(key);\n      }\n    }\n\n    function logInsertModeChange(macroModeState) {\n      if (macroModeState.isPlaying) { return; }\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register && register.pushInsertModeChanges) {\n        register.pushInsertModeChanges(macroModeState.lastInsertModeChanges);\n      }\n    }\n\n    function logSearchQuery(macroModeState, query) {\n      if (macroModeState.isPlaying) { return; }\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register && register.pushSearchQuery) {\n        register.pushSearchQuery(query);\n      }\n    }\n\n    /**\n     * Listens for changes made in insert mode.\n     * Should only be active in insert mode.\n     */\n    function onChange(cm, changeObj) {\n      var macroModeState = vimGlobalState.macroModeState;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      if (!macroModeState.isPlaying) {\n        while(changeObj) {\n          lastChange.expectCursorActivityForChange = true;\n          if (changeObj.origin == '+input' || changeObj.origin == 'paste'\n              || changeObj.origin === undefined /* only in testing */) {\n            var text = changeObj.text.join('\\n');\n            if (lastChange.maybeReset) {\n              lastChange.changes = [];\n              lastChange.maybeReset = false;\n            }\n            if (cm.state.overwrite && !/\\n/.test(text)) {\n                lastChange.changes.push([text]);\n            } else {\n                lastChange.changes.push(text);\n            }\n          }\n          // Change objects may be chained with next.\n          changeObj = changeObj.next;\n        }\n      }\n    }\n\n    /**\n    * Listens for any kind of cursor activity on CodeMirror.\n    */\n    function onCursorActivity(cm) {\n      var vim = cm.state.vim;\n      if (vim.insertMode) {\n        // Tracking cursor activity in insert mode (for macro support).\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isPlaying) { return; }\n        var lastChange = macroModeState.lastInsertModeChanges;\n        if (lastChange.expectCursorActivityForChange) {\n          lastChange.expectCursorActivityForChange = false;\n        } else {\n          // Cursor moved outside the context of an edit. Reset the change.\n          lastChange.maybeReset = true;\n        }\n      } else if (!cm.curOp.isVimOp) {\n        handleExternalSelection(cm, vim);\n      }\n      if (vim.visualMode) {\n        updateFakeCursor(cm);\n      }\n    }\n    function updateFakeCursor(cm) {\n      var vim = cm.state.vim;\n      var from = clipCursorToContent(cm, copyCursor(vim.sel.head));\n      var to = offsetCursor(from, 0, 1);\n      if (vim.fakeCursor) {\n        vim.fakeCursor.clear();\n      }\n      vim.fakeCursor = cm.markText(from, to, {className: 'cm-animate-fat-cursor'});\n    }\n    function handleExternalSelection(cm, vim) {\n      var anchor = cm.getCursor('anchor');\n      var head = cm.getCursor('head');\n      // Enter or exit visual mode to match mouse selection.\n      if (vim.visualMode && !cm.somethingSelected()) {\n        exitVisualMode(cm, false);\n      } else if (!vim.visualMode && !vim.insertMode && cm.somethingSelected()) {\n        vim.visualMode = true;\n        vim.visualLine = false;\n        CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\"});\n      }\n      if (vim.visualMode) {\n        // Bind CodeMirror selection model to vim selection model.\n        // Mouse selections are considered visual characterwise.\n        var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;\n        var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;\n        head = offsetCursor(head, 0, headOffset);\n        anchor = offsetCursor(anchor, 0, anchorOffset);\n        vim.sel = {\n          anchor: anchor,\n          head: head\n        };\n        updateMark(cm, vim, '<', cursorMin(head, anchor));\n        updateMark(cm, vim, '>', cursorMax(head, anchor));\n      } else if (!vim.insertMode) {\n        // Reset lastHPos if selection was modified by something outside of vim mode e.g. by mouse.\n        vim.lastHPos = cm.getCursor().ch;\n      }\n    }\n\n    /** Wrapper for special keys pressed in insert mode */\n    function InsertModeKey(keyName) {\n      this.keyName = keyName;\n    }\n\n    /**\n    * Handles raw key down events from the text area.\n    * - Should only be active in insert mode.\n    * - For recording deletes in insert mode.\n    */\n    function onKeyEventTargetKeyDown(e) {\n      var macroModeState = vimGlobalState.macroModeState;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      var keyName = CodeMirror.keyName(e);\n      if (!keyName) { return; }\n      function onKeyFound() {\n        if (lastChange.maybeReset) {\n          lastChange.changes = [];\n          lastChange.maybeReset = false;\n        }\n        lastChange.changes.push(new InsertModeKey(keyName));\n        return true;\n      }\n      if (keyName.indexOf('Delete') != -1 || keyName.indexOf('Backspace') != -1) {\n        CodeMirror.lookupKey(keyName, 'vim-insert', onKeyFound);\n      }\n    }\n\n    /**\n     * Repeats the last edit, which includes exactly 1 command and at most 1\n     * insert. Operator and motion commands are read from lastEditInputState,\n     * while action commands are read from lastEditActionCommand.\n     *\n     * If repeatForInsert is true, then the function was called by\n     * exitInsertMode to repeat the insert mode changes the user just made. The\n     * corresponding enterInsertMode call was made with a count.\n     */\n    function repeatLastEdit(cm, vim, repeat, repeatForInsert) {\n      var macroModeState = vimGlobalState.macroModeState;\n      macroModeState.isPlaying = true;\n      var isAction = !!vim.lastEditActionCommand;\n      var cachedInputState = vim.inputState;\n      function repeatCommand() {\n        if (isAction) {\n          commandDispatcher.processAction(cm, vim, vim.lastEditActionCommand);\n        } else {\n          commandDispatcher.evalInput(cm, vim);\n        }\n      }\n      function repeatInsert(repeat) {\n        if (macroModeState.lastInsertModeChanges.changes.length > 0) {\n          // For some reason, repeat cw in desktop VIM does not repeat\n          // insert mode changes. Will conform to that behavior.\n          repeat = !vim.lastEditActionCommand ? 1 : repeat;\n          var changeObject = macroModeState.lastInsertModeChanges;\n          repeatInsertModeChanges(cm, changeObject.changes, repeat);\n        }\n      }\n      vim.inputState = vim.lastEditInputState;\n      if (isAction && vim.lastEditActionCommand.interlaceInsertRepeat) {\n        // o and O repeat have to be interlaced with insert repeats so that the\n        // insertions appear on separate lines instead of the last line.\n        for (var i = 0; i < repeat; i++) {\n          repeatCommand();\n          repeatInsert(1);\n        }\n      } else {\n        if (!repeatForInsert) {\n          // Hack to get the cursor to end up at the right place. If I is\n          // repeated in insert mode repeat, cursor will be 1 insert\n          // change set left of where it should be.\n          repeatCommand();\n        }\n        repeatInsert(repeat);\n      }\n      vim.inputState = cachedInputState;\n      if (vim.insertMode && !repeatForInsert) {\n        // Don't exit insert mode twice. If repeatForInsert is set, then we\n        // were called by an exitInsertMode call lower on the stack.\n        exitInsertMode(cm);\n      }\n      macroModeState.isPlaying = false;\n    }\n\n    function repeatInsertModeChanges(cm, changes, repeat) {\n      function keyHandler(binding) {\n        if (typeof binding == 'string') {\n          CodeMirror.commands[binding](cm);\n        } else {\n          binding(cm);\n        }\n        return true;\n      }\n      var head = cm.getCursor('head');\n      var inVisualBlock = vimGlobalState.macroModeState.lastInsertModeChanges.inVisualBlock;\n      if (inVisualBlock) {\n        // Set up block selection again for repeating the changes.\n        var vim = cm.state.vim;\n        var lastSel = vim.lastSelection;\n        var offset = getOffset(lastSel.anchor, lastSel.head);\n        selectForInsert(cm, head, offset.line + 1);\n        repeat = cm.listSelections().length;\n        cm.setCursor(head);\n      }\n      for (var i = 0; i < repeat; i++) {\n        if (inVisualBlock) {\n          cm.setCursor(offsetCursor(head, i, 0));\n        }\n        for (var j = 0; j < changes.length; j++) {\n          var change = changes[j];\n          if (change instanceof InsertModeKey) {\n            CodeMirror.lookupKey(change.keyName, 'vim-insert', keyHandler);\n          } else if (typeof change == \"string\") {\n            var cur = cm.getCursor();\n            cm.replaceRange(change, cur, cur);\n          } else {\n            var start = cm.getCursor();\n            var end = offsetCursor(start, 0, change[0].length);\n            cm.replaceRange(change[0], start, end);\n          }\n        }\n      }\n      if (inVisualBlock) {\n        cm.setCursor(offsetCursor(head, 0, 1));\n      }\n    }\n\n    resetVimGlobalState();\n    return vimApi;\n  };\n  // Initialize Vim and make it available as an API.\n  CodeMirror.Vim = Vim();\n});\n"],"sourceRoot":""}