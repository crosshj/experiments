{"version":3,"sources":["webpack:///./src/app/overmind/effects/vscode/LinterWorker/index.js","webpack:///../common/lib/utils/diff/index.js","webpack:///../common/lib/utils/diff/lcs.js","webpack:///./src/app/utils/monaco-index-converter.js"],"names":["module","exports","Worker","Object","defineProperty","value","getTextOperation","findDiff","ot_1","lcs_1","originalText","modifiedText","pretty","stringDiff","ot","TextOperation","Math","max","length","delete","insert","console","warn","diffs","lastPos","forEach","change","start","originalStart","end","originalLength","retain","oldText","substr","newText","modifiedStart","modifiedLength","baseLength","__esModule","DiffChange","this","prototype","getOriginalEnd","getModifiedEnd","createStringSequence","a","getLength","getElementAtIndex","pos","charCodeAt","original","modified","LcsDiff","ComputeDiff","Debug","Assert","condition","message","Error","MyArray","Copy","sourceArray","sourceIndex","destinationArray","destinationIndex","i","DiffChangeHelper","m_changes","m_originalStart","Number","MAX_VALUE","m_modifiedStart","m_originalCount","m_modifiedCount","MarkNextChange","push","AddOriginalElement","originalIndex","modifiedIndex","min","AddModifiedElement","getChanges","getReverseChanges","reverse","originalSequence","newSequence","continueProcessingPredicate","OriginalSequence","ModifiedSequence","ContinueProcessingPredicate","m_forwardHistory","m_reverseHistory","ElementsAreEqual","newIndex","OriginalElementsAreEqual","index1","index2","ModifiedElementsAreEqual","_ComputeDiff","originalEnd","modifiedEnd","changes","ComputeDiffRecursive","ShiftChanges","quitEarlyArr","midOriginalArr","midModifiedArr","result","ComputeRecursionPoint","midOriginal","midModified","leftChanges","rightChanges","ConcatenateChanges","WALKTRACE","diagonalForwardBase","diagonalForwardStart","diagonalForwardEnd","diagonalForwardOffset","diagonalReverseBase","diagonalReverseStart","diagonalReverseEnd","diagonalReverseOffset","forwardPoints","reversePoints","deltaIsEven","forwardChanges","diagonal","reverseChanges","changeHelper","diagonalMin","diagonalMax","diagonalRelative","lastOriginalIndex","MIN_VALUE","historyIndex","originalStartPoint","modifiedStartPoint","lastForwardChange","numDifferences","tempOriginalIndex","maxDifferences","numDiagonals","Array","furthestOriginalIndex","furthestModifiedIndex","ClipDiagonalBound","abs","MaxDifferencesHistory","matchLengthOfLongest","temp","mergedDiffs","originalStop","modifiedStop","checkOriginal","checkModified","mergedChangeArr","ChangesOverlap","prevChange","bestDelta","bestScore","_boundaryScore","delta","score","_OriginalIsBoundary","index","element","test","_OriginalRegionIsBoundary","_ModifiedIsBoundary","_ModifiedRegionIsBoundary","left","right","diagonalBaseIndex","diffEven","lineAndColumnToIndex","lines","lineNumber","column","currentLine","indexToLineAndColumn","offset","line"],"mappings":"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","file":"static/js/default~app~monaco-editor.f753584b3.chunk.js","sourcesContent":["module.exports = function() {\n  return new Worker(\"/\" + \"monaco-linter.e5920657.worker.js\");\n};","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.getTextOperation = exports.findDiff = void 0;\r\nconst ot_1 = require(\"ot\");\r\nconst lcs_1 = require(\"./lcs\");\r\nconst MAX_DIFF_SIZE = 10000;\r\nfunction findDiff(originalText, modifiedText, pretty) {\r\n    return lcs_1.stringDiff(originalText, modifiedText, pretty);\r\n}\r\nexports.findDiff = findDiff;\r\nfunction getTextOperation(originalText, modifiedText) {\r\n    const ot = new ot_1.TextOperation();\r\n    if (Math.max(originalText.length, modifiedText.length) > MAX_DIFF_SIZE) {\r\n        ot.delete(originalText.length);\r\n        ot.insert(modifiedText);\r\n        // eslint-disable-next-line\r\n        console.warn('Not optimizing edits, file is larger than ' + MAX_DIFF_SIZE + 'b');\r\n        return ot;\r\n    }\r\n    const diffs = findDiff(originalText, modifiedText, false);\r\n    let lastPos = 0;\r\n    diffs.forEach(change => {\r\n        const start = change.originalStart;\r\n        const end = change.originalStart + change.originalLength;\r\n        if (start - lastPos !== 0) {\r\n            ot.retain(start - lastPos);\r\n        }\r\n        lastPos = end;\r\n        const oldText = originalText.substr(start, change.originalLength);\r\n        const newText = modifiedText.substr(change.modifiedStart, change.modifiedLength);\r\n        if (oldText !== newText) {\r\n            ot.insert(newText);\r\n            ot.delete(change.originalLength);\r\n        }\r\n    });\r\n    ot.retain(originalText.length - ot.baseLength);\r\n    return ot;\r\n}\r\nexports.getTextOperation = getTextOperation;\r\n","/* eslint-disable */\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nexports.__esModule = true;\n/**\n * Represents information about a specific difference between two sequences.\n */\n\nvar DiffChange =\n/** @class */\nfunction () {\n  /**\n   * Constructs a new DiffChange with the given sequence information\n   * and content.\n   */\n  function DiffChange(originalStart, originalLength, modifiedStart, modifiedLength) {\n    //Debug.Assert(originalLength > 0 || modifiedLength > 0, \"originalLength and modifiedLength cannot both be <= 0\");\n    this.originalStart = originalStart;\n    this.originalLength = originalLength;\n    this.modifiedStart = modifiedStart;\n    this.modifiedLength = modifiedLength;\n  }\n  /**\n   * The end point (exclusive) of the change in the original sequence.\n   */\n\n\n  DiffChange.prototype.getOriginalEnd = function () {\n    return this.originalStart + this.originalLength;\n  };\n  /**\n   * The end point (exclusive) of the change in the modified sequence.\n   */\n\n\n  DiffChange.prototype.getModifiedEnd = function () {\n    return this.modifiedStart + this.modifiedLength;\n  };\n\n  return DiffChange;\n}();\n\nfunction createStringSequence(a) {\n  return {\n    getLength: function getLength() {\n      return a.length;\n    },\n    getElementAtIndex: function getElementAtIndex(pos) {\n      return a.charCodeAt(pos);\n    }\n  };\n}\n\nfunction stringDiff(original, modified, pretty) {\n  return new LcsDiff(createStringSequence(original), createStringSequence(modified)).ComputeDiff(pretty);\n}\n\nexports.stringDiff = stringDiff; //\n// The code below has been ported from a C# implementation in VS\n//\n\nvar Debug =\n/** @class */\nfunction () {\n  function Debug() {}\n\n  Debug.Assert = function (condition, message) {\n    if (!condition) {\n      throw new Error(message);\n    }\n  };\n\n  return Debug;\n}();\n\nexports.Debug = Debug;\n\nvar MyArray =\n/** @class */\nfunction () {\n  function MyArray() {}\n  /**\n   * Copies a range of elements from an Array starting at the specified source index and pastes\n   * them to another Array starting at the specified destination index. The length and the indexes\n   * are specified as 64-bit integers.\n   * sourceArray:\n   *\t\tThe Array that contains the data to copy.\n   * sourceIndex:\n   *\t\tA 64-bit integer that represents the index in the sourceArray at which copying begins.\n   * destinationArray:\n   *\t\tThe Array that receives the data.\n   * destinationIndex:\n   *\t\tA 64-bit integer that represents the index in the destinationArray at which storing begins.\n   * length:\n   *\t\tA 64-bit integer that represents the number of elements to copy.\n   */\n\n\n  MyArray.Copy = function (sourceArray, sourceIndex, destinationArray, destinationIndex, length) {\n    for (var i = 0; i < length; i++) {\n      destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];\n    }\n  };\n\n  return MyArray;\n}();\n\nexports.MyArray = MyArray; //*****************************************************************************\n// LcsDiff.cs\n//\n// An implementation of the difference algorithm described in\n// \"An O(ND) Difference Algorithm and its variations\" by Eugene W. Myers\n//\n// Copyright (C) 2008 Microsoft Corporation @minifier_do_not_preserve\n//*****************************************************************************\n// Our total memory usage for storing history is (worst-case):\n// 2 * [(MaxDifferencesHistory + 1) * (MaxDifferencesHistory + 1) - 1] * sizeof(int)\n// 2 * [1448*1448 - 1] * 4 = 16773624 = 16MB\n\nvar MaxDifferencesHistory = 1447; //let MaxDifferencesHistory = 100;\n\n/**\n * A utility class which helps to create the set of DiffChanges from\n * a difference operation. This class accepts original DiffElements and\n * modified DiffElements that are involved in a particular change. The\n * MarktNextChange() method can be called to mark the separation between\n * distinct changes. At the end, the Changes property can be called to retrieve\n * the constructed changes.\n */\n\nvar DiffChangeHelper =\n/** @class */\nfunction () {\n  /**\n   * Constructs a new DiffChangeHelper for the given DiffSequences.\n   */\n  function DiffChangeHelper() {\n    this.m_changes = [];\n    this.m_originalStart = Number.MAX_VALUE;\n    this.m_modifiedStart = Number.MAX_VALUE;\n    this.m_originalCount = 0;\n    this.m_modifiedCount = 0;\n  }\n  /**\n   * Marks the beginning of the next change in the set of differences.\n   */\n\n\n  DiffChangeHelper.prototype.MarkNextChange = function () {\n    // Only add to the list if there is something to add\n    if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\n      // Add the new change to our list\n      this.m_changes.push(new DiffChange(this.m_originalStart, this.m_originalCount, this.m_modifiedStart, this.m_modifiedCount));\n    } // Reset for the next change\n\n\n    this.m_originalCount = 0;\n    this.m_modifiedCount = 0;\n    this.m_originalStart = Number.MAX_VALUE;\n    this.m_modifiedStart = Number.MAX_VALUE;\n  };\n  /**\n   * Adds the original element at the given position to the elements\n   * affected by the current change. The modified index gives context\n   * to the change position with respect to the original sequence.\n   * @param originalIndex The index of the original element to add.\n   * @param modifiedIndex The index of the modified element that provides corresponding position in the modified sequence.\n   */\n\n\n  DiffChangeHelper.prototype.AddOriginalElement = function (originalIndex, modifiedIndex) {\n    // The 'true' start index is the smallest of the ones we've seen\n    this.m_originalStart = Math.min(this.m_originalStart, originalIndex);\n    this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);\n    this.m_originalCount++;\n  };\n  /**\n   * Adds the modified element at the given position to the elements\n   * affected by the current change. The original index gives context\n   * to the change position with respect to the modified sequence.\n   * @param originalIndex The index of the original element that provides corresponding position in the original sequence.\n   * @param modifiedIndex The index of the modified element to add.\n   */\n\n\n  DiffChangeHelper.prototype.AddModifiedElement = function (originalIndex, modifiedIndex) {\n    // The 'true' start index is the smallest of the ones we've seen\n    this.m_originalStart = Math.min(this.m_originalStart, originalIndex);\n    this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);\n    this.m_modifiedCount++;\n  };\n  /**\n   * Retrieves all of the changes marked by the class.\n   */\n\n\n  DiffChangeHelper.prototype.getChanges = function () {\n    if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\n      // Finish up on whatever is left\n      this.MarkNextChange();\n    }\n\n    return this.m_changes;\n  };\n  /**\n   * Retrieves all of the changes marked by the class in the reverse order\n   */\n\n\n  DiffChangeHelper.prototype.getReverseChanges = function () {\n    if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\n      // Finish up on whatever is left\n      this.MarkNextChange();\n    }\n\n    this.m_changes.reverse();\n    return this.m_changes;\n  };\n\n  return DiffChangeHelper;\n}();\n/**\n * An implementation of the difference algorithm described in\n * \"An O(ND) Difference Algorithm and its variations\" by Eugene W. Myers\n */\n\n\nvar LcsDiff =\n/** @class */\nfunction () {\n  /**\n   * Constructs the DiffFinder\n   */\n  function LcsDiff(originalSequence, newSequence, continueProcessingPredicate) {\n    if (continueProcessingPredicate === void 0) {\n      continueProcessingPredicate = null;\n    }\n\n    this.OriginalSequence = originalSequence;\n    this.ModifiedSequence = newSequence;\n    this.ContinueProcessingPredicate = continueProcessingPredicate;\n    this.m_forwardHistory = [];\n    this.m_reverseHistory = [];\n  }\n\n  LcsDiff.prototype.ElementsAreEqual = function (originalIndex, newIndex) {\n    return this.OriginalSequence.getElementAtIndex(originalIndex) === this.ModifiedSequence.getElementAtIndex(newIndex);\n  };\n\n  LcsDiff.prototype.OriginalElementsAreEqual = function (index1, index2) {\n    return this.OriginalSequence.getElementAtIndex(index1) === this.OriginalSequence.getElementAtIndex(index2);\n  };\n\n  LcsDiff.prototype.ModifiedElementsAreEqual = function (index1, index2) {\n    return this.ModifiedSequence.getElementAtIndex(index1) === this.ModifiedSequence.getElementAtIndex(index2);\n  };\n\n  LcsDiff.prototype.ComputeDiff = function (pretty) {\n    return this._ComputeDiff(0, this.OriginalSequence.getLength() - 1, 0, this.ModifiedSequence.getLength() - 1, pretty);\n  };\n  /**\n   * Computes the differences between the original and modified input\n   * sequences on the bounded range.\n   * @returns An array of the differences between the two input sequences.\n   */\n\n\n  LcsDiff.prototype._ComputeDiff = function (originalStart, originalEnd, modifiedStart, modifiedEnd, pretty) {\n    var quitEarlyArr = [false];\n    var changes = this.ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr);\n\n    if (pretty) {\n      // We have to clean up the computed diff to be more intuitive\n      // but it turns out this cannot be done correctly until the entire set\n      // of diffs have been computed\n      return this.ShiftChanges(changes);\n    }\n\n    return changes;\n  };\n  /**\n   * Private helper method which computes the differences on the bounded range\n   * recursively.\n   * @returns An array of the differences between the two input sequences.\n   */\n\n\n  LcsDiff.prototype.ComputeDiffRecursive = function (originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr) {\n    quitEarlyArr[0] = false; // Find the start of the differences\n\n    while (originalStart <= originalEnd && modifiedStart <= modifiedEnd && this.ElementsAreEqual(originalStart, modifiedStart)) {\n      originalStart++;\n      modifiedStart++;\n    } // Find the end of the differences\n\n\n    while (originalEnd >= originalStart && modifiedEnd >= modifiedStart && this.ElementsAreEqual(originalEnd, modifiedEnd)) {\n      originalEnd--;\n      modifiedEnd--;\n    } // In the special case where we either have all insertions or all deletions or the sequences are identical\n\n\n    if (originalStart > originalEnd || modifiedStart > modifiedEnd) {\n      var changes = void 0;\n\n      if (modifiedStart <= modifiedEnd) {\n        Debug.Assert(originalStart === originalEnd + 1, 'originalStart should only be one more than originalEnd'); // All insertions\n\n        changes = [new DiffChange(originalStart, 0, modifiedStart, modifiedEnd - modifiedStart + 1)];\n      } else if (originalStart <= originalEnd) {\n        Debug.Assert(modifiedStart === modifiedEnd + 1, 'modifiedStart should only be one more than modifiedEnd'); // All deletions\n\n        changes = [new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, 0)];\n      } else {\n        Debug.Assert(originalStart === originalEnd + 1, 'originalStart should only be one more than originalEnd');\n        Debug.Assert(modifiedStart === modifiedEnd + 1, 'modifiedStart should only be one more than modifiedEnd'); // Identical sequences - No differences\n\n        changes = [];\n      }\n\n      return changes;\n    } // This problem can be solved using the Divide-And-Conquer technique.\n\n\n    var midOriginalArr = [0],\n        midModifiedArr = [0];\n    var result = this.ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr);\n    var midOriginal = midOriginalArr[0];\n    var midModified = midModifiedArr[0];\n\n    if (result !== null) {\n      // Result is not-null when there was enough memory to compute the changes while\n      // searching for the recursion point\n      return result;\n    } else if (!quitEarlyArr[0]) {\n      // We can break the problem down recursively by finding the changes in the\n      // First Half:   (originalStart, modifiedStart) to (midOriginal, midModified)\n      // Second Half:  (midOriginal + 1, minModified + 1) to (originalEnd, modifiedEnd)\n      // NOTE: ComputeDiff() is inclusive, therefore the second range starts on the next point\n      var leftChanges = this.ComputeDiffRecursive(originalStart, midOriginal, modifiedStart, midModified, quitEarlyArr);\n      var rightChanges = [];\n\n      if (!quitEarlyArr[0]) {\n        rightChanges = this.ComputeDiffRecursive(midOriginal + 1, originalEnd, midModified + 1, modifiedEnd, quitEarlyArr);\n      } else {\n        // We did't have time to finish the first half, so we don't have time to compute this half.\n        // Consider the entire rest of the sequence different.\n        rightChanges = [new DiffChange(midOriginal + 1, originalEnd - (midOriginal + 1) + 1, midModified + 1, modifiedEnd - (midModified + 1) + 1)];\n      }\n\n      return this.ConcatenateChanges(leftChanges, rightChanges);\n    } // If we hit here, we quit early, and so can't return anything meaningful\n\n\n    return [new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)];\n  };\n\n  LcsDiff.prototype.WALKTRACE = function (diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr) {\n    var forwardChanges = null,\n        reverseChanges = null; // First, walk backward through the forward diagonals history\n\n    var changeHelper = new DiffChangeHelper();\n    var diagonalMin = diagonalForwardStart;\n    var diagonalMax = diagonalForwardEnd;\n    var diagonalRelative = midOriginalArr[0] - midModifiedArr[0] - diagonalForwardOffset;\n    var lastOriginalIndex = Number.MIN_VALUE;\n    var historyIndex = this.m_forwardHistory.length - 1;\n    var diagonal;\n\n    do {\n      // Get the diagonal index from the relative diagonal number\n      diagonal = diagonalRelative + diagonalForwardBase; // Figure out where we came from\n\n      if (diagonal === diagonalMin || diagonal < diagonalMax && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1]) {\n        // Vertical line (the element is an insert)\n        originalIndex = forwardPoints[diagonal + 1];\n        modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;\n\n        if (originalIndex < lastOriginalIndex) {\n          changeHelper.MarkNextChange();\n        }\n\n        lastOriginalIndex = originalIndex;\n        changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex);\n        diagonalRelative = diagonal + 1 - diagonalForwardBase; //Setup for the next iteration\n      } else {\n        // Horizontal line (the element is a deletion)\n        originalIndex = forwardPoints[diagonal - 1] + 1;\n        modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;\n\n        if (originalIndex < lastOriginalIndex) {\n          changeHelper.MarkNextChange();\n        }\n\n        lastOriginalIndex = originalIndex - 1;\n        changeHelper.AddOriginalElement(originalIndex, modifiedIndex + 1);\n        diagonalRelative = diagonal - 1 - diagonalForwardBase; //Setup for the next iteration\n      }\n\n      if (historyIndex >= 0) {\n        forwardPoints = this.m_forwardHistory[historyIndex];\n        diagonalForwardBase = forwardPoints[0]; //We stored this in the first spot\n\n        diagonalMin = 1;\n        diagonalMax = forwardPoints.length - 1;\n      }\n    } while (--historyIndex >= -1); // Ironically, we get the forward changes as the reverse of the\n    // order we added them since we technically added them backwards\n\n\n    forwardChanges = changeHelper.getReverseChanges();\n\n    if (quitEarlyArr[0]) {\n      // TODO: Calculate a partial from the reverse diagonals.\n      //       For now, just assume everything after the midOriginal/midModified point is a diff\n      var originalStartPoint = midOriginalArr[0] + 1;\n      var modifiedStartPoint = midModifiedArr[0] + 1;\n\n      if (forwardChanges !== null && forwardChanges.length > 0) {\n        var lastForwardChange = forwardChanges[forwardChanges.length - 1];\n        originalStartPoint = Math.max(originalStartPoint, lastForwardChange.getOriginalEnd());\n        modifiedStartPoint = Math.max(modifiedStartPoint, lastForwardChange.getModifiedEnd());\n      }\n\n      reverseChanges = [new DiffChange(originalStartPoint, originalEnd - originalStartPoint + 1, modifiedStartPoint, modifiedEnd - modifiedStartPoint + 1)];\n    } else {\n      // Now walk backward through the reverse diagonals history\n      changeHelper = new DiffChangeHelper();\n      diagonalMin = diagonalReverseStart;\n      diagonalMax = diagonalReverseEnd;\n      diagonalRelative = midOriginalArr[0] - midModifiedArr[0] - diagonalReverseOffset;\n      lastOriginalIndex = Number.MAX_VALUE;\n      historyIndex = deltaIsEven ? this.m_reverseHistory.length - 1 : this.m_reverseHistory.length - 2;\n\n      do {\n        // Get the diagonal index from the relative diagonal number\n        diagonal = diagonalRelative + diagonalReverseBase; // Figure out where we came from\n\n        if (diagonal === diagonalMin || diagonal < diagonalMax && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1]) {\n          // Horizontal line (the element is a deletion))\n          originalIndex = reversePoints[diagonal + 1] - 1;\n          modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;\n\n          if (originalIndex > lastOriginalIndex) {\n            changeHelper.MarkNextChange();\n          }\n\n          lastOriginalIndex = originalIndex + 1;\n          changeHelper.AddOriginalElement(originalIndex + 1, modifiedIndex + 1);\n          diagonalRelative = diagonal + 1 - diagonalReverseBase; //Setup for the next iteration\n        } else {\n          // Vertical line (the element is an insertion)\n          originalIndex = reversePoints[diagonal - 1];\n          modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;\n\n          if (originalIndex > lastOriginalIndex) {\n            changeHelper.MarkNextChange();\n          }\n\n          lastOriginalIndex = originalIndex;\n          changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex + 1);\n          diagonalRelative = diagonal - 1 - diagonalReverseBase; //Setup for the next iteration\n        }\n\n        if (historyIndex >= 0) {\n          reversePoints = this.m_reverseHistory[historyIndex];\n          diagonalReverseBase = reversePoints[0]; //We stored this in the first spot\n\n          diagonalMin = 1;\n          diagonalMax = reversePoints.length - 1;\n        }\n      } while (--historyIndex >= -1); // There are cases where the reverse history will find diffs that\n      // are correct, but not intuitive, so we need shift them.\n\n\n      reverseChanges = changeHelper.getChanges();\n    }\n\n    return this.ConcatenateChanges(forwardChanges, reverseChanges);\n  };\n  /**\n   * Given the range to compute the diff on, this method finds the point:\n   * (midOriginal, midModified)\n   * that exists in the middle of the LCS of the two sequences and\n   * is the point at which the LCS problem may be broken down recursively.\n   * This method will try to keep the LCS trace in memory. If the LCS recursion\n   * point is calculated and the full trace is available in memory, then this method\n   * will return the change list.\n   * @param originalStart The start bound of the original sequence range\n   * @param originalEnd The end bound of the original sequence range\n   * @param modifiedStart The start bound of the modified sequence range\n   * @param modifiedEnd The end bound of the modified sequence range\n   * @param midOriginal The middle point of the original sequence range\n   * @param midModified The middle point of the modified sequence range\n   * @returns The diff changes, if available, otherwise null\n   */\n\n\n  LcsDiff.prototype.ComputeRecursionPoint = function (originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr) {\n    var originalIndex, modifiedIndex;\n    var diagonalForwardStart = 0,\n        diagonalForwardEnd = 0;\n    var diagonalReverseStart = 0,\n        diagonalReverseEnd = 0;\n    var numDifferences; // To traverse the edit graph and produce the proper LCS, our actual\n    // start position is just outside the given boundary\n\n    originalStart--;\n    modifiedStart--; // We set these up to make the compiler happy, but they will\n    // be replaced before we return with the actual recursion point\n\n    midOriginalArr[0] = 0;\n    midModifiedArr[0] = 0; // Clear out the history\n\n    this.m_forwardHistory = [];\n    this.m_reverseHistory = []; // Each cell in the two arrays corresponds to a diagonal in the edit graph.\n    // The integer value in the cell represents the originalIndex of the furthest\n    // reaching point found so far that ends in that diagonal.\n    // The modifiedIndex can be computed mathematically from the originalIndex and the diagonal number.\n\n    var maxDifferences = originalEnd - originalStart + (modifiedEnd - modifiedStart);\n    var numDiagonals = maxDifferences + 1;\n    var forwardPoints = new Array(numDiagonals);\n    var reversePoints = new Array(numDiagonals); // diagonalForwardBase: Index into forwardPoints of the diagonal which passes through (originalStart, modifiedStart)\n    // diagonalReverseBase: Index into reversePoints of the diagonal which passes through (originalEnd, modifiedEnd)\n\n    var diagonalForwardBase = modifiedEnd - modifiedStart;\n    var diagonalReverseBase = originalEnd - originalStart; // diagonalForwardOffset: Geometric offset which allows modifiedIndex to be computed from originalIndex and the\n    //    diagonal number (relative to diagonalForwardBase)\n    // diagonalReverseOffset: Geometric offset which allows modifiedIndex to be computed from originalIndex and the\n    //    diagonal number (relative to diagonalReverseBase)\n\n    var diagonalForwardOffset = originalStart - modifiedStart;\n    var diagonalReverseOffset = originalEnd - modifiedEnd; // delta: The difference between the end diagonal and the start diagonal. This is used to relate diagonal numbers\n    //   relative to the start diagonal with diagonal numbers relative to the end diagonal.\n    // The Even/Oddn-ness of this delta is important for determining when we should check for overlap\n\n    var delta = diagonalReverseBase - diagonalForwardBase;\n    var deltaIsEven = delta % 2 === 0; // Here we set up the start and end points as the furthest points found so far\n    // in both the forward and reverse directions, respectively\n\n    forwardPoints[diagonalForwardBase] = originalStart;\n    reversePoints[diagonalReverseBase] = originalEnd; // Remember if we quit early, and thus need to do a best-effort result instead of a real result.\n\n    quitEarlyArr[0] = false; // A couple of points:\n    // --With this method, we iterate on the number of differences between the two sequences.\n    //   The more differences there actually are, the longer this will take.\n    // --Also, as the number of differences increases, we have to search on diagonals further\n    //   away from the reference diagonal (which is diagonalForwardBase for forward, diagonalReverseBase for reverse).\n    // --We extend on even diagonals (relative to the reference diagonal) only when numDifferences\n    //   is even and odd diagonals only when numDifferences is odd.\n\n    var diagonal, tempOriginalIndex;\n\n    for (numDifferences = 1; numDifferences <= maxDifferences / 2 + 1; numDifferences++) {\n      var furthestOriginalIndex = 0;\n      var furthestModifiedIndex = 0; // Run the algorithm in the forward direction\n\n      diagonalForwardStart = this.ClipDiagonalBound(diagonalForwardBase - numDifferences, numDifferences, diagonalForwardBase, numDiagonals);\n      diagonalForwardEnd = this.ClipDiagonalBound(diagonalForwardBase + numDifferences, numDifferences, diagonalForwardBase, numDiagonals);\n\n      for (diagonal = diagonalForwardStart; diagonal <= diagonalForwardEnd; diagonal += 2) {\n        // STEP 1: We extend the furthest reaching point in the present diagonal\n        // by looking at the diagonals above and below and picking the one whose point\n        // is further away from the start point (originalStart, modifiedStart)\n        if (diagonal === diagonalForwardStart || diagonal < diagonalForwardEnd && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1]) {\n          originalIndex = forwardPoints[diagonal + 1];\n        } else {\n          originalIndex = forwardPoints[diagonal - 1] + 1;\n        }\n\n        modifiedIndex = originalIndex - (diagonal - diagonalForwardBase) - diagonalForwardOffset; // Save the current originalIndex so we can test for false overlap in step 3\n\n        tempOriginalIndex = originalIndex; // STEP 2: We can continue to extend the furthest reaching point in the present diagonal\n        // so long as the elements are equal.\n\n        while (originalIndex < originalEnd && modifiedIndex < modifiedEnd && this.ElementsAreEqual(originalIndex + 1, modifiedIndex + 1)) {\n          originalIndex++;\n          modifiedIndex++;\n        }\n\n        forwardPoints[diagonal] = originalIndex;\n\n        if (originalIndex + modifiedIndex > furthestOriginalIndex + furthestModifiedIndex) {\n          furthestOriginalIndex = originalIndex;\n          furthestModifiedIndex = modifiedIndex;\n        } // STEP 3: If delta is odd (overlap first happens on forward when delta is odd)\n        // and diagonal is in the range of reverse diagonals computed for numDifferences-1\n        // (the previous iteration; we haven't computed reverse diagonals for numDifferences yet)\n        // then check for overlap.\n\n\n        if (!deltaIsEven && Math.abs(diagonal - diagonalReverseBase) <= numDifferences - 1) {\n          if (originalIndex >= reversePoints[diagonal]) {\n            midOriginalArr[0] = originalIndex;\n            midModifiedArr[0] = modifiedIndex;\n\n            if (tempOriginalIndex <= reversePoints[diagonal] && MaxDifferencesHistory > 0 && numDifferences <= MaxDifferencesHistory + 1) {\n              // BINGO! We overlapped, and we have the full trace in memory!\n              return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\n            } else {\n              // Either false overlap, or we didn't have enough memory for the full trace\n              // Just return the recursion point\n              return null;\n            }\n          }\n        }\n      } // Check to see if we should be quitting early, before moving on to the next iteration.\n\n\n      var matchLengthOfLongest = (furthestOriginalIndex - originalStart + (furthestModifiedIndex - modifiedStart) - numDifferences) / 2;\n\n      if (this.ContinueProcessingPredicate !== null && !this.ContinueProcessingPredicate(furthestOriginalIndex, this.OriginalSequence, matchLengthOfLongest)) {\n        // We can't finish, so skip ahead to generating a result from what we have.\n        quitEarlyArr[0] = true; // Use the furthest distance we got in the forward direction.\n\n        midOriginalArr[0] = furthestOriginalIndex;\n        midModifiedArr[0] = furthestModifiedIndex;\n\n        if (matchLengthOfLongest > 0 && MaxDifferencesHistory > 0 && numDifferences <= MaxDifferencesHistory + 1) {\n          // Enough of the history is in memory to walk it backwards\n          return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\n        } else {\n          // We didn't actually remember enough of the history.\n          //Since we are quiting the diff early, we need to shift back the originalStart and modified start\n          //back into the boundary limits since we decremented their value above beyond the boundary limit.\n          originalStart++;\n          modifiedStart++;\n          return [new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)];\n        }\n      } // Run the algorithm in the reverse direction\n\n\n      diagonalReverseStart = this.ClipDiagonalBound(diagonalReverseBase - numDifferences, numDifferences, diagonalReverseBase, numDiagonals);\n      diagonalReverseEnd = this.ClipDiagonalBound(diagonalReverseBase + numDifferences, numDifferences, diagonalReverseBase, numDiagonals);\n\n      for (diagonal = diagonalReverseStart; diagonal <= diagonalReverseEnd; diagonal += 2) {\n        // STEP 1: We extend the furthest reaching point in the present diagonal\n        // by looking at the diagonals above and below and picking the one whose point\n        // is further away from the start point (originalEnd, modifiedEnd)\n        if (diagonal === diagonalReverseStart || diagonal < diagonalReverseEnd && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1]) {\n          originalIndex = reversePoints[diagonal + 1] - 1;\n        } else {\n          originalIndex = reversePoints[diagonal - 1];\n        }\n\n        modifiedIndex = originalIndex - (diagonal - diagonalReverseBase) - diagonalReverseOffset; // Save the current originalIndex so we can test for false overlap\n\n        tempOriginalIndex = originalIndex; // STEP 2: We can continue to extend the furthest reaching point in the present diagonal\n        // as long as the elements are equal.\n\n        while (originalIndex > originalStart && modifiedIndex > modifiedStart && this.ElementsAreEqual(originalIndex, modifiedIndex)) {\n          originalIndex--;\n          modifiedIndex--;\n        }\n\n        reversePoints[diagonal] = originalIndex; // STEP 4: If delta is even (overlap first happens on reverse when delta is even)\n        // and diagonal is in the range of forward diagonals computed for numDifferences\n        // then check for overlap.\n\n        if (deltaIsEven && Math.abs(diagonal - diagonalForwardBase) <= numDifferences) {\n          if (originalIndex <= forwardPoints[diagonal]) {\n            midOriginalArr[0] = originalIndex;\n            midModifiedArr[0] = modifiedIndex;\n\n            if (tempOriginalIndex >= forwardPoints[diagonal] && MaxDifferencesHistory > 0 && numDifferences <= MaxDifferencesHistory + 1) {\n              // BINGO! We overlapped, and we have the full trace in memory!\n              return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\n            } else {\n              // Either false overlap, or we didn't have enough memory for the full trace\n              // Just return the recursion point\n              return null;\n            }\n          }\n        }\n      } // Save current vectors to history before the next iteration\n\n\n      if (numDifferences <= MaxDifferencesHistory) {\n        // We are allocating space for one extra int, which we fill with\n        // the index of the diagonal base index\n        var temp = new Array(diagonalForwardEnd - diagonalForwardStart + 2);\n        temp[0] = diagonalForwardBase - diagonalForwardStart + 1;\n        MyArray.Copy(forwardPoints, diagonalForwardStart, temp, 1, diagonalForwardEnd - diagonalForwardStart + 1);\n        this.m_forwardHistory.push(temp);\n        temp = new Array(diagonalReverseEnd - diagonalReverseStart + 2);\n        temp[0] = diagonalReverseBase - diagonalReverseStart + 1;\n        MyArray.Copy(reversePoints, diagonalReverseStart, temp, 1, diagonalReverseEnd - diagonalReverseStart + 1);\n        this.m_reverseHistory.push(temp);\n      }\n    } // If we got here, then we have the full trace in history. We just have to convert it to a change list\n    // NOTE: This part is a bit messy\n\n\n    return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\n  };\n  /**\n   * Shifts the given changes to provide a more intuitive diff.\n   * While the first element in a diff matches the first element after the diff,\n   * we shift the diff down.\n   *\n   * @param changes The list of changes to shift\n   * @returns The shifted changes\n   */\n\n\n  LcsDiff.prototype.ShiftChanges = function (changes) {\n    var mergedDiffs;\n\n    do {\n      mergedDiffs = false; // Shift all the changes down first\n\n      for (var i = 0; i < changes.length; i++) {\n        var change = changes[i];\n        var originalStop = i < changes.length - 1 ? changes[i + 1].originalStart : this.OriginalSequence.getLength();\n        var modifiedStop = i < changes.length - 1 ? changes[i + 1].modifiedStart : this.ModifiedSequence.getLength();\n        var checkOriginal = change.originalLength > 0;\n        var checkModified = change.modifiedLength > 0;\n\n        while (change.originalStart + change.originalLength < originalStop && change.modifiedStart + change.modifiedLength < modifiedStop && (!checkOriginal || this.OriginalElementsAreEqual(change.originalStart, change.originalStart + change.originalLength)) && (!checkModified || this.ModifiedElementsAreEqual(change.modifiedStart, change.modifiedStart + change.modifiedLength))) {\n          change.originalStart++;\n          change.modifiedStart++;\n        }\n      } // Build up the new list (we have to build a new list because we\n      // might have changes we can merge together now)\n\n\n      var result = new Array();\n      var mergedChangeArr = [null];\n\n      for (var i = 0; i < changes.length; i++) {\n        if (i < changes.length - 1 && this.ChangesOverlap(changes[i], changes[i + 1], mergedChangeArr)) {\n          mergedDiffs = true;\n          result.push(mergedChangeArr[0]);\n          i++;\n        } else {\n          result.push(changes[i]);\n        }\n      }\n\n      changes = result;\n    } while (mergedDiffs); // Shift changes back up until we hit empty or whitespace-only lines\n\n\n    for (var i = changes.length - 1; i >= 0; i--) {\n      var change = changes[i];\n      var originalStop = 0;\n      var modifiedStop = 0;\n\n      if (i > 0) {\n        var prevChange = changes[i - 1];\n\n        if (prevChange.originalLength > 0) {\n          originalStop = prevChange.originalStart + prevChange.originalLength;\n        }\n\n        if (prevChange.modifiedLength > 0) {\n          modifiedStop = prevChange.modifiedStart + prevChange.modifiedLength;\n        }\n      }\n\n      var checkOriginal = change.originalLength > 0;\n      var checkModified = change.modifiedLength > 0;\n      var bestDelta = 0;\n\n      var bestScore = this._boundaryScore(change.originalStart, change.originalLength, change.modifiedStart, change.modifiedLength);\n\n      for (var delta = 1;; delta++) {\n        var originalStart = change.originalStart - delta;\n        var modifiedStart = change.modifiedStart - delta;\n\n        if (originalStart < originalStop || modifiedStart < modifiedStop) {\n          break;\n        }\n\n        if (checkOriginal && !this.OriginalElementsAreEqual(originalStart, originalStart + change.originalLength)) {\n          break;\n        }\n\n        if (checkModified && !this.ModifiedElementsAreEqual(modifiedStart, modifiedStart + change.modifiedLength)) {\n          break;\n        }\n\n        var score = this._boundaryScore(originalStart, change.originalLength, modifiedStart, change.modifiedLength);\n\n        if (score > bestScore) {\n          bestScore = score;\n          bestDelta = delta;\n        }\n      }\n\n      change.originalStart -= bestDelta;\n      change.modifiedStart -= bestDelta;\n    }\n\n    return changes;\n  };\n\n  LcsDiff.prototype._OriginalIsBoundary = function (index) {\n    if (index <= 0 || index >= this.OriginalSequence.getLength() - 1) {\n      return true;\n    }\n\n    var element = this.OriginalSequence.getElementAtIndex(index);\n    return typeof element === 'string' && /^\\s*$/.test(element);\n  };\n\n  LcsDiff.prototype._OriginalRegionIsBoundary = function (originalStart, originalLength) {\n    if (this._OriginalIsBoundary(originalStart) || this._OriginalIsBoundary(originalStart - 1)) {\n      return true;\n    }\n\n    if (originalLength > 0) {\n      var originalEnd = originalStart + originalLength;\n\n      if (this._OriginalIsBoundary(originalEnd - 1) || this._OriginalIsBoundary(originalEnd)) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  LcsDiff.prototype._ModifiedIsBoundary = function (index) {\n    if (index <= 0 || index >= this.ModifiedSequence.getLength() - 1) {\n      return true;\n    }\n\n    var element = this.ModifiedSequence.getElementAtIndex(index);\n    return typeof element === 'string' && /^\\s*$/.test(element);\n  };\n\n  LcsDiff.prototype._ModifiedRegionIsBoundary = function (modifiedStart, modifiedLength) {\n    if (this._ModifiedIsBoundary(modifiedStart) || this._ModifiedIsBoundary(modifiedStart - 1)) {\n      return true;\n    }\n\n    if (modifiedLength > 0) {\n      var modifiedEnd = modifiedStart + modifiedLength;\n\n      if (this._ModifiedIsBoundary(modifiedEnd - 1) || this._ModifiedIsBoundary(modifiedEnd)) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  LcsDiff.prototype._boundaryScore = function (originalStart, originalLength, modifiedStart, modifiedLength) {\n    var originalScore = this._OriginalRegionIsBoundary(originalStart, originalLength) ? 1 : 0;\n    var modifiedScore = this._ModifiedRegionIsBoundary(modifiedStart, modifiedLength) ? 1 : 0;\n    return originalScore + modifiedScore;\n  };\n  /**\n   * Concatenates the two input DiffChange lists and returns the resulting\n   * list.\n   * @param The left changes\n   * @param The right changes\n   * @returns The concatenated list\n   */\n\n\n  LcsDiff.prototype.ConcatenateChanges = function (left, right) {\n    var mergedChangeArr = [];\n    var result = null;\n\n    if (left.length === 0 || right.length === 0) {\n      return right.length > 0 ? right : left;\n    } else if (this.ChangesOverlap(left[left.length - 1], right[0], mergedChangeArr)) {\n      // Since we break the problem down recursively, it is possible that we\n      // might recurse in the middle of a change thereby splitting it into\n      // two changes. Here in the combining stage, we detect and fuse those\n      // changes back together\n      result = new Array(left.length + right.length - 1);\n      MyArray.Copy(left, 0, result, 0, left.length - 1);\n      result[left.length - 1] = mergedChangeArr[0];\n      MyArray.Copy(right, 1, result, left.length, right.length - 1);\n      return result;\n    } else {\n      result = new Array(left.length + right.length);\n      MyArray.Copy(left, 0, result, 0, left.length);\n      MyArray.Copy(right, 0, result, left.length, right.length);\n      return result;\n    }\n  };\n  /**\n   * Returns true if the two changes overlap and can be merged into a single\n   * change\n   * @param left The left change\n   * @param right The right change\n   * @param mergedChange The merged change if the two overlap, null otherwise\n   * @returns True if the two changes overlap\n   */\n\n\n  LcsDiff.prototype.ChangesOverlap = function (left, right, mergedChangeArr) {\n    Debug.Assert(left.originalStart <= right.originalStart, 'Left change is not less than or equal to right change');\n    Debug.Assert(left.modifiedStart <= right.modifiedStart, 'Left change is not less than or equal to right change');\n\n    if (left.originalStart + left.originalLength >= right.originalStart || left.modifiedStart + left.modifiedLength >= right.modifiedStart) {\n      var originalStart = left.originalStart;\n      var originalLength = left.originalLength;\n      var modifiedStart = left.modifiedStart;\n      var modifiedLength = left.modifiedLength;\n\n      if (left.originalStart + left.originalLength >= right.originalStart) {\n        originalLength = right.originalStart + right.originalLength - left.originalStart;\n      }\n\n      if (left.modifiedStart + left.modifiedLength >= right.modifiedStart) {\n        modifiedLength = right.modifiedStart + right.modifiedLength - left.modifiedStart;\n      }\n\n      mergedChangeArr[0] = new DiffChange(originalStart, originalLength, modifiedStart, modifiedLength);\n      return true;\n    } else {\n      mergedChangeArr[0] = null;\n      return false;\n    }\n  };\n  /**\n   * Helper method used to clip a diagonal index to the range of valid\n   * diagonals. This also decides whether or not the diagonal index,\n   * if it exceeds the boundary, should be clipped to the boundary or clipped\n   * one inside the boundary depending on the Even/Odd status of the boundary\n   * and numDifferences.\n   * @param diagonal The index of the diagonal to clip.\n   * @param numDifferences The current number of differences being iterated upon.\n   * @param diagonalBaseIndex The base reference diagonal.\n   * @param numDiagonals The total number of diagonals.\n   * @returns The clipped diagonal index.\n   */\n\n\n  LcsDiff.prototype.ClipDiagonalBound = function (diagonal, numDifferences, diagonalBaseIndex, numDiagonals) {\n    if (diagonal >= 0 && diagonal < numDiagonals) {\n      // Nothing to clip, its in range\n      return diagonal;\n    } // diagonalsBelow: The number of diagonals below the reference diagonal\n    // diagonalsAbove: The number of diagonals above the reference diagonal\n\n\n    var diagonalsBelow = diagonalBaseIndex;\n    var diagonalsAbove = numDiagonals - diagonalBaseIndex - 1;\n    var diffEven = numDifferences % 2 === 0;\n\n    if (diagonal < 0) {\n      var lowerBoundEven = diagonalsBelow % 2 === 0;\n      return diffEven === lowerBoundEven ? 0 : 1;\n    } else {\n      var upperBoundEven = diagonalsAbove % 2 === 0;\n      return diffEven === upperBoundEven ? numDiagonals - 1 : numDiagonals - 2;\n    }\n  };\n\n  return LcsDiff;\n}();\n\nexports.LcsDiff = LcsDiff;","export function lineAndColumnToIndex(lines, lineNumber, column) {\n  let currentLine = 0;\n  let index = 0;\n\n  while (currentLine + 1 < lineNumber) {\n    index += lines[currentLine].length;\n    index += 1; // Linebreak character\n    currentLine += 1;\n  }\n\n  index += column - 1;\n\n  return index;\n}\n\nexport function indexToLineAndColumn(lines, index) {\n  let offset = 0;\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n    if (offset + line.length + 1 > index) {\n      return {\n        lineNumber: i + 1,\n        column: index - offset + 1,\n      };\n    }\n\n    // + 1 is for the linebreak character which is not included\n    offset += line.length + 1;\n  }\n\n  // +2 for column (length is already a +1), because +1 for Monaco and +1 for linebreak\n  return {\n    lineNumber: lines.length,\n    column: (lines[lines.length - 1] || '').length + 1,\n  };\n}\n"],"sourceRoot":""}