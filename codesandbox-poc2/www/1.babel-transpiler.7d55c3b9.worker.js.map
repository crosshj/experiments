{"version":3,"sources":["webpack:///C:/repos/codesandbox-client/node_modules/babel-plugin-syntax-jsx/lib/index.js","webpack:///C:/repos/codesandbox-client/node_modules/babel-plugin-transform-vue-jsx/index.js","webpack:///C:/repos/codesandbox-client/node_modules/babel-plugin-transform-vue-jsx/lib/group-props.js","webpack:///C:/repos/codesandbox-client/node_modules/babel-plugin-transform-vue-jsx/lib/make-map.js","webpack:///C:/repos/codesandbox-client/node_modules/babel-plugin-transform-vue-jsx/lib/must-use-prop.js"],"names":["exports","__esModule","default","manipulateOptions","opts","parserOpts","plugins","push","module","esutils","require","groupProps","mustUseProp","babel","t","types","inherits","visitor","JSXNamespacedName","path","buildCodeFrameError","JSXElement","exit","file","callExpr","parent","children","react","buildChildren","tagName","tagExpr","convertJSXIdentifier","node","isJSXIdentifier","name","isReferenced","thisExpression","keyword","isIdentifierNameES6","stringLiteral","type","isJSXMemberExpression","memberExpression","object","property","args","isIdentifier","isLiteral","value","isCompatTag","attribs","attributes","length","_props","objs","pushProps","objectExpression","prop","shift","isJSXSpreadAttribute","argument","_isSpread","convertAttribute","map","o","properties","helper","addImport","callExpression","arrayExpression","buildOpeningElementAttributes","identifier","buildElementCall","get","arguments","_prettyCall","replaceWith","traverse","params","jsxChecker","hasJsx","this","isInsideJsxExpression","parentPath","isJSXExpressionContainer","isRender","key","unshiftContainer","variableDeclaration","variableDeclarator","numericLiteral","JSXOpeningElement","tag","typeAttribute","find","attributePath","isStringLiteral","forEach","attribute","attr","JSXIdentifier","expression","convertAttributeValue","booleanLiteral","replace","isValidIdentifier","objectProperty","isTopLevel","makeMap","nestableRE","dirRE","xlinkRE","props","newProps","currentNestedObjects","Object","create","nestMatch","match","prefix","suffix","_","$1","$2","toLowerCase","nestedProp","nestedObject","test","dirs","directives","elements","attrs","JSON","stringify","m","p1","str","list","split","i","val","acceptValue","includes"],"mappings":"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","file":"1.babel-transpiler.7d55c3b9.worker.js","sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\n\nexports.default = function () {\n  return {\n    manipulateOptions: function manipulateOptions(opts, parserOpts) {\n      parserOpts.plugins.push(\"jsx\");\n    }\n  };\n};\n\nmodule.exports = exports[\"default\"];","var esutils = require('esutils')\nvar groupProps = require('./lib/group-props')\nvar mustUseProp = require('./lib/must-use-prop')\n\nvar isInsideJsxExpression = function (t, path) {\n  if (!path.parentPath) {\n    return false\n  }\n  if (t.isJSXExpressionContainer(path.parentPath)) {\n    return true\n  }\n  return isInsideJsxExpression(t, path.parentPath)\n}\n\nmodule.exports = function (babel) {\n  var t = babel.types\n\n  return {\n    inherits: require('babel-plugin-syntax-jsx'),\n    visitor: {\n      JSXNamespacedName (path) {\n        throw path.buildCodeFrameError(\n          'Namespaced tags/attributes are not supported. JSX is not XML.\\n' +\n          'For attributes like xlink:href, use xlinkHref instead.'\n        )\n      },\n      JSXElement: {\n        exit (path, file) {\n          // turn tag into createElement call\n          var callExpr = buildElementCall(path.get('openingElement'), file)\n          if (path.node.children.length) {\n            // add children array as 3rd arg\n            callExpr.arguments.push(t.arrayExpression(path.node.children))\n            if (callExpr.arguments.length >= 3) {\n              callExpr._prettyCall = true\n            }\n          }\n          path.replaceWith(t.inherits(callExpr, path.node))\n        }\n      },\n      'Program' (path) {\n        path.traverse({\n          'ObjectMethod|ClassMethod' (path) {\n            const params = path.get('params')\n            // do nothing if there is (h) param\n            if (params.length && params[0].node.name === 'h') {\n              return\n            }\n            // do nothing if there is no JSX inside\n            const jsxChecker = {\n              hasJsx: false\n            }\n            path.traverse({\n              JSXElement () {\n                this.hasJsx = true\n              }\n            }, jsxChecker)\n            if (!jsxChecker.hasJsx) {\n              return\n            }\n            // do nothing if this method is a part of JSX expression\n            if (isInsideJsxExpression(t, path)) {\n              return\n            }\n            const isRender = path.node.key.name === 'render'\n            // inject h otherwise\n            path.get('body').unshiftContainer('body', t.variableDeclaration('const', [\n              t.variableDeclarator(\n                t.identifier('h'),\n                (\n                  isRender\n                    ? t.memberExpression(\n                      t.identifier('arguments'),\n                      t.numericLiteral(0),\n                      true\n                    )\n                    : t.memberExpression(\n                      t.thisExpression(),\n                      t.identifier('$createElement')\n                    )\n                )\n              )\n            ]))\n          },\n          JSXOpeningElement (path) {\n            const tag = path.get('name').node.name\n            const attributes = path.get('attributes')\n            const typeAttribute = attributes.find(attributePath => attributePath.node.name && attributePath.node.name.name === 'type')\n            const type = typeAttribute && t.isStringLiteral(typeAttribute.node.value) ? typeAttribute.node.value.value : null\n\n            attributes.forEach(attributePath => {\n              const attribute = attributePath.get('name')\n\n              if (!attribute.node) {\n                return\n              }\n\n              const attr = attribute.node.name\n\n              if (mustUseProp(tag, type, attr) && t.isJSXExpressionContainer(attributePath.node.value)) {\n                attribute.replaceWith(t.JSXIdentifier(`domProps-${attr}`))\n              }\n            })\n          }\n        })\n      }\n    }\n  }\n\n  function buildElementCall (path, file) {\n    path.parent.children = t.react.buildChildren(path.parent)\n    var tagExpr = convertJSXIdentifier(path.node.name, path.node)\n    var args = []\n\n    var tagName\n    if (t.isIdentifier(tagExpr)) {\n      tagName = tagExpr.name\n    } else if (t.isLiteral(tagExpr)) {\n      tagName = tagExpr.value\n    }\n\n    if (t.react.isCompatTag(tagName)) {\n      args.push(t.stringLiteral(tagName))\n    } else {\n      args.push(tagExpr)\n    }\n\n    var attribs = path.node.attributes\n    if (attribs.length) {\n      attribs = buildOpeningElementAttributes(attribs, file)\n      args.push(attribs)\n    }\n    return t.callExpression(t.identifier('h'), args)\n  }\n\n  function convertJSXIdentifier (node, parent) {\n    if (t.isJSXIdentifier(node)) {\n      if (node.name === 'this' && t.isReferenced(node, parent)) {\n        return t.thisExpression()\n      } else if (esutils.keyword.isIdentifierNameES6(node.name)) {\n        node.type = 'Identifier'\n      } else {\n        return t.stringLiteral(node.name)\n      }\n    } else if (t.isJSXMemberExpression(node)) {\n      return t.memberExpression(\n        convertJSXIdentifier(node.object, node),\n        convertJSXIdentifier(node.property, node)\n      )\n    }\n    return node\n  }\n\n  /**\n   * The logic for this is quite terse. It's because we need to\n   * support spread elements. We loop over all attributes,\n   * breaking on spreads, we then push a new object containing\n   * all prior attributes to an array for later processing.\n   */\n\n  function buildOpeningElementAttributes (attribs, file) {\n    var _props = []\n    var objs = []\n\n    function pushProps () {\n      if (!_props.length) return\n      objs.push(t.objectExpression(_props))\n      _props = []\n    }\n\n    while (attribs.length) {\n      var prop = attribs.shift()\n      if (t.isJSXSpreadAttribute(prop)) {\n        pushProps()\n        prop.argument._isSpread = true\n        objs.push(prop.argument)\n      } else {\n        _props.push(convertAttribute(prop))\n      }\n    }\n\n    pushProps()\n\n    objs = objs.map(function (o) {\n      return o._isSpread ? o : groupProps(o.properties, t)\n    })\n\n    if (objs.length === 1) {\n      // only one object\n      attribs = objs[0]\n    } else if (objs.length) {\n      // add prop merging helper\n      var helper = file.addImport('babel-helper-vue-jsx-merge-props', 'default', '_mergeJSXProps')\n      // spread it\n      attribs = t.callExpression(\n        helper,\n        [t.arrayExpression(objs)]\n      )\n    }\n    return attribs\n  }\n\n  function convertAttribute (node) {\n    var value = convertAttributeValue(node.value || t.booleanLiteral(true))\n    if (t.isStringLiteral(value) && !t.isJSXExpressionContainer(node.value)) {\n      value.value = value.value.replace(/\\n\\s+/g, ' ')\n    }\n    if (t.isValidIdentifier(node.name.name)) {\n      node.name.type = 'Identifier'\n    } else {\n      node.name = t.stringLiteral(node.name.name)\n    }\n    return t.inherits(t.objectProperty(node.name, value), node)\n  }\n\n  function convertAttributeValue (node) {\n    if (t.isJSXExpressionContainer(node)) {\n      return node.expression\n    } else {\n      return node\n    }\n  }\n}\n","var makeMap = require('./make-map')\nvar isTopLevel = makeMap('class,staticClass,style,key,ref,refInFor,slot,scopedSlots')\nvar nestableRE = /^(props|domProps|on|nativeOn|hook)([\\-_A-Z])/\nvar dirRE = /^v-/\nvar xlinkRE = /^xlink([A-Z])/\n\nmodule.exports = function groupProps (props, t) {\n  var newProps = []\n  var currentNestedObjects = Object.create(null)\n  props.forEach(function (prop) {\n    var name = prop.key.value || prop.key.name\n    if (isTopLevel(name)) {\n      // top-level special props\n      newProps.push(prop)\n    } else {\n      // nested modules\n      var nestMatch = name.match(nestableRE)\n      if (nestMatch) {\n        var prefix = nestMatch[1]\n        var suffix = name.replace(nestableRE, function (_, $1, $2) {\n          return $2 === '-' ? '' : $2.toLowerCase()\n        })\n        var nestedProp = t.objectProperty(t.stringLiteral(suffix), prop.value)\n        var nestedObject = currentNestedObjects[prefix]\n        if (!nestedObject) {\n          nestedObject = currentNestedObjects[prefix] = t.objectProperty(\n            t.identifier(prefix),\n            t.objectExpression([nestedProp])\n          )\n          newProps.push(nestedObject)\n        } else {\n          nestedObject.value.properties.push(nestedProp)\n        }\n      } else if (dirRE.test(name)) {\n        // custom directive\n        name = name.replace(dirRE, '')\n        var dirs = currentNestedObjects.directives\n        if (!dirs) {\n          dirs = currentNestedObjects.directives = t.objectProperty(\n            t.identifier('directives'),\n            t.arrayExpression([])\n          )\n          newProps.push(dirs)\n        }\n        dirs.value.elements.push(t.objectExpression([\n          t.objectProperty(\n            t.identifier('name'),\n            t.stringLiteral(name)\n          ),\n          t.objectProperty(\n            t.identifier('value'),\n            prop.value\n          )\n        ]))\n      } else {\n        // rest are nested under attrs\n        var attrs = currentNestedObjects.attrs\n        // guard xlink attributes\n        if (xlinkRE.test(prop.key.name)) {\n          prop.key.name = JSON.stringify(prop.key.name.replace(xlinkRE, function (m, p1) {\n            return 'xlink:' + p1.toLowerCase()\n          }))\n        }\n        if (!attrs) {\n          attrs = currentNestedObjects.attrs = t.objectProperty(\n            t.identifier('attrs'),\n            t.objectExpression([prop])\n          )\n          newProps.push(attrs)\n        } else {\n          attrs.value.properties.push(prop)\n        }\n      }\n    }\n  })\n  return t.objectExpression(newProps)\n}\n","module.exports = function makeMap (str) {\n  var map = Object.create(null)\n  var list = str.split(',')\n  for (var i = 0; i < list.length; i++) {\n    map[list[i]] = true\n  }\n  return val => map[val]\n}\n","const acceptValue = ['input','textarea','option','select']\nmodule.exports = (tag, type, attr) => {\n  return (\n    (attr === 'value' && acceptValue.includes(tag)) && type !== 'button' ||\n    (attr === 'selected' && tag === 'option') ||\n    (attr === 'checked' && tag === 'input') ||\n    (attr === 'muted' && tag === 'video')\n  )\n}\n"],"sourceRoot":""}