"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = require("../utils");
var interfaces_1 = require("./interfaces");
/**
 * Represents a textual document.
 */
var Document = /** @class */ (function () {
    function Document() {
        /**
         * Current version of the document.
         */
        this.version = 0;
        this.fragments = [];
        this.languageId = '';
    }
    Document.prototype.addFragment = function (document) {
        this.fragments.push(document);
        return document;
    };
    Document.prototype.findFragment = function (predicate) {
        return this.fragments.find(predicate);
    };
    /**
     * Get the length of the document's content
     */
    Document.prototype.getTextLength = function () {
        return this.getText().length;
    };
    /**
     * Update the text between two positions.
     * @param text The new text slice
     * @param start Start offset of the new text
     * @param end End offset of the new text
     */
    Document.prototype.update = function (text, start, end) {
        var content = this.getText();
        this.setText(content.slice(0, start) + text + content.slice(end));
    };
    /**
     * Get the line and character based on the offset
     * @param offset The index of the position
     */
    Document.prototype.positionAt = function (offset) {
        offset = utils_1.clamp(offset, 0, this.getTextLength());
        var lineOffsets = this.getLineOffsets();
        var low = 0;
        var high = lineOffsets.length;
        if (high === 0) {
            return interfaces_1.Position.create(0, offset);
        }
        while (low < high) {
            var mid = Math.floor((low + high) / 2);
            if (lineOffsets[mid] > offset) {
                high = mid;
            }
            else {
                low = mid + 1;
            }
        }
        // low is the least x for which the line offset is larger than the current offset
        // or array.length if no line offset is larger than the current offset
        var line = low - 1;
        return interfaces_1.Position.create(line, offset - lineOffsets[line]);
    };
    /**
     * Get the index of the line and character position
     * @param position Line and character position
     */
    Document.prototype.offsetAt = function (position) {
        var lineOffsets = this.getLineOffsets();
        if (position.line >= lineOffsets.length) {
            return this.getTextLength();
        }
        else if (position.line < 0) {
            return 0;
        }
        var lineOffset = lineOffsets[position.line];
        var nextLineOffset = position.line + 1 < lineOffsets.length
            ? lineOffsets[position.line + 1]
            : this.getTextLength();
        return utils_1.clamp(nextLineOffset, lineOffset, lineOffset + position.character);
    };
    Document.prototype.getLineOffsets = function () {
        var lineOffsets = [];
        var text = this.getText();
        var isLineStart = true;
        for (var i = 0; i < text.length; i++) {
            if (isLineStart) {
                lineOffsets.push(i);
                isLineStart = false;
            }
            var ch = text.charAt(i);
            isLineStart = ch === '\r' || ch === '\n';
            if (ch === '\r' && i + 1 < text.length && text.charAt(i + 1) === '\n') {
                i++;
            }
        }
        if (isLineStart && text.length > 0) {
            lineOffsets.push(text.length);
        }
        return lineOffsets;
    };
    Object.defineProperty(Document.prototype, "uri", {
        /**
         * Implements TextDocument
         */
        get: function () {
            return this.getURL();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Document.prototype, "lineCount", {
        get: function () {
            return this.getText().split(/\r?\n/).length;
        },
        enumerable: true,
        configurable: true
    });
    return Document;
}());
exports.Document = Document;
//# sourceMappingURL=Document.js.map